<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hansol</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="한솔이블로그">
<meta property="og:type" content="website">
<meta property="og:title" content="Hansol">
<meta property="og:url" content="https://hansol-jeong.github.io/index.html">
<meta property="og:site_name" content="Hansol">
<meta property="og:description" content="한솔이블로그">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hansol">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hansol" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hansol</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hansol-jeong.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-MultiThread(6)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/30/MultiThread(6)/" class="article-date">
  <time datetime="2020-10-29T23:44:34.000Z" itemprop="datePublished">2020-10-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/til/">til</a>►<a class="article-category-link" href="/categories/java/til/MultiThread/">MultiThread</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/30/MultiThread(6)/">MultiThread(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MultiThread-6"><a href="#MultiThread-6" class="headerlink" title="MultiThread(6)"></a>MultiThread(6)</h1><h1 id="synchronizedList"><a href="#synchronizedList" class="headerlink" title="synchronizedList"></a>synchronizedList</h1><pre><code>List&lt;Integer&gt; list1 = new Vector&lt;&gt;();  
List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();  
List&lt;Integer&gt; list3 = Collections.synchronizedList(list2);  
// list3: list2의 싱크된 버전  


for (int i = 0; i &lt; 1000; i++) &#123;  
    new Thread(() -&gt; &#123;  
        for (int j = 0; j &lt; 100; j++) &#123;  
            list1.add(1);  
  &#125;  
    &#125;).start();  
&#125;  

for (int i = 0; i &lt; 1000; i++) &#123;  
    new Thread(() -&gt; &#123;  
        for (int j = 0; j &lt; 100; j++) &#123;  
            list3.add(1);  
  &#125;  
    &#125;).start();  
&#125;  



Thread.sleep(1000);  

System.out.println(list1.size());  
System.out.println(list2.size());</code></pre>
<p>  리스트를 sync해서 쓸 수 있는데 대표적으로 우리가 아는 sync된 리스트는 Vector이다. 때문에 기본적으로 벡터는 다른 자료구조에 비해 느린 이유가 여기있다. 따로 Vector를 쓰지 않고 싱크된 자료구조를 쓰고 싶다면 위의 코드처럼 Collections.synchronizedList(list) 로 만들어 주면 될 것이다.</p>
<h1 id="쓰레드-풀-Thread-Pool"><a href="#쓰레드-풀-Thread-Pool" class="headerlink" title="쓰레드 풀(Thread Pool)"></a>쓰레드 풀(Thread Pool)</h1><p>  쓰레드는 생성하고 관리하기가 어렵다. 때문에 쓰레드 풀이란 것이있다. 이미 만들어진 쓰레드 뭉텅이에 SynchronousQueue(작업 큐)를 제출(submit)해주면 된다. 이 스레드 풀을 생성하는 방법은 Executors.newCachedThreadPool(), Executors.newFixedThreadPool(n),new ThreadPoolExecutor ( 여러가지 ) 이렇게 세 가지가 있으며 공통점은 작업큐를 제출할 때 작업큐는 Runnable객체 또는 Callable객체여야 한다는 것이다. 활용 예는 아래와 같다.</p>
<pre><code>public class Main &#123;  
    public static void main(String[] args) throws InterruptedException &#123;  
        ExecutorService pool1 = Executors.newCachedThreadPool();  
  /**  
 * newCachedThreadPool * - 초기 스레드가 0개 -&gt; 오버헤드가 없다.  
 * - 코어 스레드가 0개(일하지 않아도 살려두는 스레드)  
 * - 요청 작업보다 스레드가 부족하면 새 스레드를 생성  
  * - 60초 동안 일하지 않은 스레드는 제거  
  */  
  ExecutorService pool2 = Executors.newFixedThreadPool(10);  
  /**  
 *  newFixedThreadPool *  - 최대 스레드 nThread개  
  *  - 코어 스레드 nThread개  
  *  - 요청 작업보다 스레드가 부족하면 새 스레드 생성  
  *  - 작업하지 않는 스레드도 제거하지 않고 동작  
  */  

  ExecutorService es = new ThreadPoolExecutor (  
                10, //코어 스레드  
  100, // 최대 스레드 개수  
  120, // 스레드가 이 시간동안 일 하지 않으면 제거  
  TimeUnit.SECONDS,  
 new SynchronousQueue&lt;Runnable&gt;() // 요청 -&gt; 작업을 쌓아둔 큐 -&gt;스레드 풀  
  );  
  //2.스레드에 할당할 작업 생성  
  class Work implements Runnable &#123;  

            @Override  
  public void run() &#123;  
                for(int i = 0; i&lt; 100; i++) &#123;  
                    System.out.println(i);  
  &#125;  
            &#125;  
        &#125;  
        class CallableWork implements Callable&lt;String&gt; &#123;  

            @Override  
  public String call() throws Exception &#123;  
                return &quot;작업종료&quot;;  
  &#125;  
        &#125;  
        //3.스레드에 작업 요청  
  Future&lt;String&gt; future;  
  future=pool1.submit(new CallableWork());  
 for (int i = 0; i&lt;100; i++) &#123;  
            pool1.submit(new Work());  
 ;  &#125;//4. 스레드 종료(동기화)  
 //스레드 풀은 자동 종료가 안되기 때문에, 직접 스레드풀을 종료해 주어야 한다.  
  pool1.shutdown(); // Thread.join()과 마찬가지로 끝나길 기다려서 종료  
  Thread.sleep(1000);  
 try &#123;  
            System.out.println(future.get()); //get()은 Blocking method 즉59번 째 줄에 future에 값이 들어오기 전까진 get()에서 블러킹한다.  
 //get()을 영원히 기다릴 수 도 있음으로 timeout 설정 가능  
  future.cancel(true); //실행중인 Callable객체를 강제종료 인터럽트해서 강제종료  
  System.out.println(future.isCancelled());  
  System.out.println(future.isDone());  
  &#125; catch (InterruptedException e) &#123;  
            e.printStackTrace();  
  &#125; catch (ExecutionException e) &#123;  
            e.printStackTrace();  
  &#125;  
    &#125;  
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/10/30/MultiThread(6)/" data-id="ckgz8uao3000ajwv17cla76fx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MultiThread/" rel="tag">MultiThread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread(4)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/29/MultiThread(4)/" class="article-date">
  <time datetime="2020-10-28T23:23:44.000Z" itemprop="datePublished">2020-10-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/til/">til</a>►<a class="article-category-link" href="/categories/java/til/MultiThread/">MultiThread</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/29/MultiThread(4)/">MultiThread</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MultiThread-4"><a href="#MultiThread-4" class="headerlink" title="MultiThread(4)"></a>MultiThread(4)</h1><p>멀티 쓰레드 프로그래밍: 여러개의 스레드를 사용하는 프로그래밍 기법!</p>
<ul>
<li>Thread: 최소의 프로세스 동작단위 -&gt; 하나의 프로세스는 여러개의 스레드를 가질 수 있다.</li>
<li>Process: OS로부터 메모리를 할당받아 동작하는 프로그램의 동작 단위, 프로그램이 실제로 메모리에 상주하면서 동작할 때 프로세스가 된다.(프로그램을 실행할 때, 멀티 프로세스로 동작하는 프로그램도 있다.)</li>
</ul>
<h2 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h2><p>wait() 중인 다른 스레드를 하나 동작 상태로 만든다.</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h2><p>Lock을 반환하고 대기 상태로 들어간다.</p>
<ul>
<li>여러 동작을 병렬적으로 처리하여 CPU 사용율 향상 (CPU Utilization) (ex. 인코딩, 랜더링, 배치작업 (DB 정리, 로그처리 등…)    </li>
<li>시간이 걸리는 동작을 분리하여 프로그램의 응답성 향상(ex. GUI, 게임, 앱, 웹API, …)</li>
</ul>
<h1 id="notify-와-wait-을-사용한-멀티스레드-구현"><a href="#notify-와-wait-을-사용한-멀티스레드-구현" class="headerlink" title="notify() 와 wait() 을 사용한 멀티스레드 구현"></a>notify() 와 wait() 을 사용한 멀티스레드 구현</h1><pre><code>    class WorkObject &#123;  
    public synchronized void methodA() &#123;  
        System.out.println(&quot;methodA() called&quot;);  
  notify(); // wait()중인 다른 스레드를 하나 동작 상태로 만든다.  
  try &#123;  
            wait(); // Lock을 반환하고 대기 상태로 들어감.  
  &#125; catch (InterruptedException e) &#123;  
            e.printStackTrace();  
  &#125;  
    &#125;  
   public synchronized void methodB() &#123;  
        System.out.println(&quot;methodB() called&quot;);  
  notify();  
 try &#123;  
            wait();  
  &#125; catch (InterruptedException e) &#123;  
            e.printStackTrace();  
  &#125;  

    &#125;  
&#125;  

class MyThread extends Thread &#123;  
    private final WorkObject workObject;  
 private boolean isA;  

 public MyThread(WorkObject workObject, boolean isA) &#123; // Dependency Injection  
  this.workObject = workObject;  
 this.isA = isA;  
  &#125;  

    @Override  
  public void run() &#123;  
        for (int i = 0; i &lt; 10; i++) &#123;  
            if (isA) &#123;  
                workObject.methodA();  
  &#125; else &#123;  
                workObject.methodB();  
  &#125;  
        &#125;  
    &#125;  
&#125;  

public class Main &#123;  
    public static void main(String[] args) &#123;  
        WorkObject sharedObj = new WorkObject();  

  Thread p1 = new MyThread(sharedObj, true);  
  Thread p2 = new MyThread(sharedObj, false);  

  p1.start();  
  p2.start();  
  &#125;  
&#125;</code></pre>
<p>  코드가 좀 길다. 하지만 자를 수 없었다. 결론적으론 메소드 A와 메소드 B가 있고 각 각 다른 쓰레드에서 p1,p2를 실행시켜 각 각 run()을 주고받는다. p1은 run에서 메소드A만 10번을 실행할 것이고 p2는 메소드 B만 10번을 실행할 것이다. 이 때  각 메소드의 동작을 살펴보면 메소드 A와B는 모두 method called메시지를 출력 후 notify()를 실행한다. 이로 써 wait()중인 다른 스레드를 동작상태로 만들고 자신은 뒤이어 wait()으로 대기상태에 들어간다. 이를 주고받으며 서로 10번씩 20번을 하면 동작이 끝난다.</p>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p> 세마포의 사전적 의미는 횟대(깃발)이다.<br> n개의 깃발을 놓고, 여러 스레드가 경쟁하도록 하는 sync기법이다.<br> n=1이면,  BinarySemaphore라고 하며, Lock과 유사하게 동작</p>
<pre><code>public class Main &#123;  
    public static void main(String[] args) &#123;  
        Semaphore sem = new Semaphore(1);  
  System.out.println(sem.availablePermits());  
//  
//        try &#123; // Blocking으로 동작  
//            sem.acquire(12);  
//        &#125; catch (InterruptedException e) &#123;  
//            e.printStackTrace();  
//        &#125;  
//        sem.acquireUninterruptibly(); // interrupt()에 반응하지 않음  
  System.out.println(sem.tryAcquire()); // Blocking하지 않고, 실패하면 false 리턴  
  try &#123;  
            System.out.println(sem.tryAcquire(2000, TimeUnit.MILLISECONDS)); // Blocking하지 않고, 실패하면 false 리턴  
  &#125; catch (InterruptedException e) &#123;  
            e.printStackTrace();  
  &#125;  
        System.out.println(sem.availablePermits());
  sem.release();  
  System.out.println(sem.availablePermits());  
  &#125;  
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/10/29/MultiThread(4)/" data-id="ckgz8uanx0003jwv1bcr87qd3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MultiThread/" rel="tag">MultiThread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread(5)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/29/MultiThread(5)/" class="article-date">
  <time datetime="2020-10-28T23:16:42.000Z" itemprop="datePublished">2020-10-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/til/">til</a>►<a class="article-category-link" href="/categories/java/til/MultiThread/">MultiThread</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/29/MultiThread(5)/">MultiThread</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="식사하는-철학자들"><a href="#식사하는-철학자들" class="headerlink" title="식사하는 철학자들"></a>식사하는 철학자들</h1><p> 철학자들(Circle)이 식사를 하려합니다. 식사를 하기 위해선 양손에 포크가 필요한데요, 반드시 양손에 두개의 포크를 가진 사람만이 식사를 할 수 있습니다. 때문에 식사를 못한사람은 식사를 하고있는 사람이 포크를 내려놓을 때 까지 기다려야 합니다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A((Circle)) -- fork --&gt; B((Circle))</span><br><span class="line">B((Circle)) -- fork --&gt; C((Circle))</span><br><span class="line">C((Circle)) -- fork --&gt; D((Circle))</span><br><span class="line">D((Circle)) -- fork --&gt; E((Circle))</span><br><span class="line">E((Circle)) -- fork --&gt; A((Circle))</span><br></pre></td></tr></table></figure>


<h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code> class Philosopher extends Thread &#123;  
 private final int id;  각각의 철학자를 나타냅니다
 private final Fork left;  그 철학자 왼쪽의 포크 상태
 private final Fork right;  오른쪽의 포크 상태

 public Philosopher(int id, Fork left, Fork right) &#123;  
        this.id = id;  
 this.left = left;  
 this.right = right;  
  &#125;  

    @Override  
  public void run() &#123;  
        while (true) &#123;  
            try &#123;  
                left.acquire(); 왼쪽 포크(세마포)를 얻기를 시도한다.
//                System.out.println(id + &quot;: left taken.&quot;);  
  &#125; catch (InterruptedException e) &#123;  
                e.printStackTrace();  
  &#125;  

            try &#123;  
                if (!right.tryAcquire(1000, TimeUnit.MILLISECONDS)) &#123;  
                    left.release();  
  Thread.yield();  
 continue;  &#125;  오른쪽 포크가 없는 상태라면 1초후 강제로 왼쪽 포크(세마포)를 해제한다. 그리고 쓰레드를 양보한다.
//                System.out.println(id + &quot;: right taken.&quot;);  
  &#125; catch (InterruptedException e) &#123;  
                e.printStackTrace();  
  &#125;  

            try &#123;  
                System.out.println(id + &quot; is eating.&quot;);  
  Thread.sleep(2000);  
  &#125; catch (InterruptedException e) &#123;  
                e.printStackTrace();  
  &#125;  

            left.release();  
  right.release();  
  Thread.yield();  
  &#125;  
    &#125;  
&#125;  

class Fork extends Semaphore &#123;  

    public Fork() &#123;  
        super(1);  
  &#125;  
&#125;  

public class Main &#123;  
    public static void main(String[] args) &#123;  
        Philosopher[] phils = new Philosopher[5];  
  Fork[] forks = new Fork[5];  

 for (int i = 0; i &lt; 5; i++) &#123;  
            forks[i] = new Fork();  
  &#125;  

        for (int i = 0; i &lt; 5 - 1; i++) &#123;  
            phils[i] = new Philosopher(i, forks[i], forks[(i + 1) % 5]);  
  &#125;  
        phils[4] = new Philosopher(4, forks[0], forks[4]);  

 for (int i = 0; i &lt; 5; i++) &#123;  
            phils[i].start();  
  &#125;  
    &#125;  
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/10/29/MultiThread(5)/" data-id="ckgz8uao00006jwv121b1cgi4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MultiThread/" rel="tag">MultiThread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread(3)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/28/MultiThread(3)/" class="article-date">
  <time datetime="2020-10-27T23:53:51.000Z" itemprop="datePublished">2020-10-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/til/">til</a>►<a class="article-category-link" href="/categories/java/til/MultiThread/">MultiThread</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/28/MultiThread(3)/">MultiThread</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MultiThread-3"><a href="#MultiThread-3" class="headerlink" title="MultiThread(3)"></a>MultiThread(3)</h1><h1 id="Daemon-thread"><a href="#Daemon-thread" class="headerlink" title="Daemon thread"></a>Daemon thread</h1><ul>
<li>다른 모든 스레드가 종료될 경우, 스스로 종료되는 메소드이다. </li>
<li>무한 루프로 대기하면서 동작하는 구현이 많다 -&gt; 무한루프로 대기하다가 다른거 끝나면 실행되는 구조</li>
<li>일정시간마다 동작하며, interrupt등에 의해서 동작한다.</li>
</ul>
<h1 id="활용-예"><a href="#활용-예" class="headerlink" title="# 활용 예"></a># 활용 예</h1><pre><code> class AutoSaver extends Thread &#123;  
    public AutoSaver() &#123;  
        this.setDaemon(true); // 메인 스레드가 종료되면 스스로 종료되도록 데몬 설정  
  &#125;  

    @Override  
  public void run() &#123;  
        while (true) &#123;  
            try &#123;  
                Thread.sleep(5000);  
  &#125; catch (InterruptedException e) &#123;  
                e.printStackTrace();  
  &#125;  
            // Save Something...  
  System.out.println(&quot;Auto Save Done!&quot;);  
  &#125;  
    &#125;  
&#125;  

public class Main &#123;  
    public static void main(String[] args) throws InterruptedException &#123;  

        new AutoSaver().start();  

 for (int i = 0; i &lt; 15; i++) &#123;  
            Thread.sleep(1000);  
  System.out.println(&quot;Working&quot;);  
  &#125;  
    &#125;  
&#125;</code></pre>
<h1 id="Intrinsic-Lock-고유-락-과-synchronized-키워드"><a href="#Intrinsic-Lock-고유-락-과-synchronized-키워드" class="headerlink" title="Intrinsic Lock(고유 락) 과 synchronized 키워드"></a>Intrinsic Lock(고유 락) 과 synchronized 키워드</h1><ul>
<li>자바의 모든 객체는 고유 락을 가지고 있음<ul>
<li>객체의 소유권을 한정하는 내부적인 구현 -&gt; 소유권은 독점적이다.</li>
</ul>
</li>
<li>synchronized를 이용하면 객체의 고유 락의 소유권을 가져올 수 있다.<ul>
<li>소유권이 이미 점유된 경우에는 Blocking으로 동작한다!</li>
</ul>
</li>
</ul>
<h2 id="사용-예-1-멀티스레드-동작에-취약한-구현"><a href="#사용-예-1-멀티스레드-동작에-취약한-구현" class="headerlink" title="사용 예(1) 멀티스레드 동작에 취약한 구현"></a>사용 예(1) 멀티스레드 동작에 취약한 구현</h2><pre><code>  class Counter &#123;  
    private int count = 0;  
 public int increaseCount() &#123;  
        return ++count; // 읽고, 수정하고, 쓰는 작업  
  // 경쟁적으로 동작하다 보면, 읽고 수정하고 쓰기 전에 다른 쓰레드가 읽는 경우가 발생  
  &#125;  

    public int getCount() &#123;  
        return count;  
  &#125;  
&#125;</code></pre>
<p> 해당 코드를 멀티쓰레드로 돌릴 경우 누가먼저 돌아갈 지 알 수 없으며 실행이 겹칠 수 있다. 그러면 카운트가 안될 수도 있어!</p>
<h2 id="사용-예-2-Intrinsic-Lock을-이용한-구현"><a href="#사용-예-2-Intrinsic-Lock을-이용한-구현" class="headerlink" title="사용 예(2) Intrinsic Lock을 이용한 구현"></a>사용 예(2) Intrinsic Lock을 이용한 구현</h2><pre><code>     class Counter &#123;  
    private Object lock = new Object();  
 private int count = 0;  
 public int increaseCount() &#123;  
        synchronized (lock) &#123;  
            return ++count; // 읽고, 수정하고, 쓰는 작업  
  &#125;  
    &#125;  

    public int getCount() &#123;  
        return count;  
  &#125;  
&#125;</code></pre>
<p> 해당 쓰레드에서 오브젝트객체인 lock을 점유하지 않았다면 메소드 실행 불가능 때문에 한번에 하나의 쓰레드만 실행된다. 이를 좀더 간편하게 object객체를 자기자신 this로 선언하면</p>
<pre><code>class Counter &#123;  
    private int count = 0;  
 public int increaseCount() &#123;  
        synchronized (this) &#123;  
            return ++count; // 읽고, 수정하고, 쓰는 작업  
  &#125;  
    &#125;  

    public int getCount() &#123;  
        return count;  
  &#125;  
&#125;</code></pre>
<p> 요로케 this로 줄일 수 있고 더 나아가서는</p>
<pre><code>class Counter &#123;  
    private int count = 0;  
 public synchronized int increaseCount() &#123;  
        return ++count; // 읽고, 수정하고, 쓰는 작업  
  &#125;  

    public int getCount() &#123;  
        return count;  
  &#125;  
&#125;</code></pre>
<p> 이렇게 메소드에 synchronized키워드를 사용할 수 있다. 세 경우 모두 해당 객체를 소유하지 못했다면 Blocking된다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/10/28/MultiThread(3)/" data-id="ckgz8uanz0005jwv19gf52s4y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MultiThread/" rel="tag">MultiThread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread(2)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/27/MultiThread(2)/" class="article-date">
  <time datetime="2020-10-27T14:02:46.000Z" itemprop="datePublished">2020-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/til/">til</a>►<a class="article-category-link" href="/categories/java/til/MultiThread/">MultiThread</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/27/MultiThread(2)/">MultiThread</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MultiThread-2"><a href="#MultiThread-2" class="headerlink" title="MultiThread(2)"></a>MultiThread(2)</h1><p> MultiThread(1) 에서 우리는 join()을 통해 다음 쓰레드로 연결시키는 방법에 대해 알아봤습니다. 하지만 이보다 더 활용성이 높은 yield()가 있습니다.</p>
<h2 id="Yield"><a href="#Yield" class="headerlink" title="Yield()"></a>Yield()</h2><p> yield()함수는 join()과 마찬가지로 다음 쓰레드로 이동하는 역할을 합니다 하지만 다른점이 있다면 yield() 이름과 마찬가지로 다른스레드로 ‘양보’하고 자신은 바로 실행 ‘대기’에 들어간다는 점입니다. 이는 다시 실행될 수 있는 여지를 남깁니다.</p>
<h2 id="사용-예-Code"><a href="#사용-예-Code" class="headerlink" title="사용 예(Code)"></a>사용 예(Code)</h2><ul>
<li>디버깅이 어렵다 -&gt; 쓰레드가 동시에 동작하기 때문에, 디버거로 확인하기 어려움. -&gt; 디버거를 쓰거나, 디버깅을 하기 위한 코드를 추가하면 동작이 변한다.</li>
<li>구현이 어렵다. 쓰레드간의 동기화를 하기 위한 구현이 어렵다. 쉽게 동기화하면 느려진다. -&gt; Context Switching 오버헤드가 있기 때문에 동기화를 잘 못하면 오히려 더 느려진다.</li>
</ul>
<h2 id="쓰레드를-생성하는-3가지-방법"><a href="#쓰레드를-생성하는-3가지-방법" class="headerlink" title="쓰레드를 생성하는 3가지 방법"></a>쓰레드를 생성하는 3가지 방법</h2><h2 id="1-Extends-를-통한-생성"><a href="#1-Extends-를-통한-생성" class="headerlink" title="1. Extends 를 통한 생성"></a>1. Extends 를 통한 생성</h2><pre><code>class MyThread extends Thread &#123;  
@Override  
 public void run() &#123;  
    for (int i = 0; i &lt; 10; i++) &#123;  
        System.out.print(i);  
  &#125;  
    System.out.println();  
    &#125;  
&#125;</code></pre>
<h2 id="2-익명의-내부클래스-를-통한-생성"><a href="#2-익명의-내부클래스-를-통한-생성" class="headerlink" title="2. 익명의 내부클래스 를 통한 생성"></a>2. 익명의 내부클래스 를 통한 생성</h2><pre><code>    Thread p1 = new Thread(new Runnable() &#123; // 1. 익명 내부 클래스  
  @Override  
  public void run() &#123;  
        try &#123;  
            Thread.sleep(50);  
  &#125; catch (InterruptedException e) &#123;  
            e.printStackTrace();  
  &#125;  
        System.out.println(&quot;Hello Thread&quot;);  
  &#125;  
&#125;);</code></pre>
<h2 id="3-람다식을-통한-생성"><a href="#3-람다식을-통한-생성" class="headerlink" title="3. 람다식을 통한 생성"></a>3. 람다식을 통한 생성</h2><pre><code>Thread p2 = new Thread(() -&gt; &#123; // 2. 람다식 구현  
  System.out.println(&quot;Thread by lambda&quot;);  
 while (true) &#123;  

    &#125;  
&#125;);</code></pre>
<h1 id="쓰레드-실행"><a href="#쓰레드-실행" class="headerlink" title="쓰레드 실행"></a>쓰레드 실행</h1><p> 쓰레드는 .start()함수를 통해 실행되며, 한번 실행되면 재사용이 불가합니다. 때문에 실행이 아닌 테스트를 하려면 메인쓰레드로 접근하는 .run()을 사용 하면 됩니다. run은 Thread 에 implement한 Runnable() 인터페이스를 오버라이드한 함수로 쓰레드 실행에 영향을 주지 않습니다.</p>
<h2 id="Sleep-Join"><a href="#Sleep-Join" class="headerlink" title="Sleep(), Join();"></a>Sleep(), Join();</h2><p> 멀티쓰레드의 실행 순서는 OS가 관여하므로(Priority, Starve) 어떤것이 먼저 실행 될지 정확하게 알 수 없습니다. 이를 해결하기 위해 쓰레드를 Thread.sleep(millis) 해주면 해당 쓰레드는 해당 시간 때문에 대기합니다. 하지만 이는 사용자가 직접 얼마나 기다릴 지 기입해야하고 예측해야 하기 때문에 비효율 적입니다. 이를 위해 Join()을 써봅니다.<br>  Join()은 예를들어 p2라는 쓰레드가 실행되고 있다면 다음 쓰레드 전에 p2.join()메소드를 호출합니다. 그렇다면 p2 쓰레드가 끝난 후 다음 쓰레드가 실행될 것입니다. p2.join(millis) 는 해당 시간 동안 기다리고 시간이 되면 강제로 다음 쓰레드를 실행합니다.</p>
<h2 id="구현-후-즉시-실행"><a href="#구현-후-즉시-실행" class="headerlink" title="구현 후 즉시 실행"></a>구현 후 즉시 실행</h2><p>  쓰레드의 레퍼런스를 일일히 지정해주지 않아도 되는 경우가 있습니다. 이 경우</p>
<pre><code>new Thread(() -&gt; &#123;  
    System.out.println(&quot;IDEA&quot;);  
&#125;).start(); // 이렇게 하면 join 등 활용이 어려움</code></pre>
<p>   이런식으로 레퍼런스를 지정해 주지 않고 실행하면 속도가 빨라지지만, 객체지정이 안되어있으니 join등 후에 사용이 어려울 것입니다.</p>
<h2 id="yield-로-멀티쓰레드-동작-컨트롤하기-잘-섞어보기-FEAT-신제용강사님"><a href="#yield-로-멀티쓰레드-동작-컨트롤하기-잘-섞어보기-FEAT-신제용강사님" class="headerlink" title="yield()로 멀티쓰레드 동작 컨트롤하기(잘 섞어보기) FEAT.신제용강사님"></a>yield()로 멀티쓰레드 동작 컨트롤하기(잘 섞어보기) FEAT.신제용강사님</h2><p> 도와주세요 신제용강사님<br>    Thread p1 = new Thread(() -&gt; {<br>        for (int i = 0; i &lt; 1000; i++) {<br>            System.out.print(“~”);<br>            Thread.yield(); // 다른 스레드로 양보하고 바로 실행 대기<br>            try {<br>                Thread.sleep(1000); // Running 상태에서 Timed_Waiting 상태로 이동<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    });<br>여기서 yield를 해도 잘 섞이지 않앗던 이유와 sleep을 해주면 잘섞이던 이유가 기억이안납니다..!</p>
<p><img src="https://ca.slack-edge.com/T017RKADVUJ-U017RQZMW2W-gdacf126aa0d-48"><br>yield는 양보하고, 곧바로 자기 자신도 실행 대기로 가지만<br>sleep은 대기상태로 일정 시간동안 있기 때문에 그 사이에 다른 스레드가 동작할 가능성이 더 높기 때문입니다!</p>
<p><img src="https://ca.slack-edge.com/T017RKADVUJ-U017RNXV534-fcab42309467-48"></p>
<p>맞습니다 기억낫습니다<img src="https://a.slack-edge.com/production-standard-emoji-assets/10.2/google-medium/1f44d.png" alt=":+1:"><br> 위에서 볼 수 있듯 양보하면 자기자신도 실행다기로 가지만 일정시간동안 대기하면서 다른 스레드가 동작할 가능성이 더 높다!</p>
<h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h2><p> p1.interrupt(); 기존 동작을 방해하고 반응을 강제하는 메소드이며 이름과 똑같이 기존 메소드 동작을 방해하고 해당 메소드를 강제 실행시키는 메소드이다.</p>
<ul>
<li>주로 임베디드에서 많이 사용</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/10/27/MultiThread(2)/" data-id="ckgz8uanu0001jwv1bcpd7c9k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MultiThread/" rel="tag">MultiThread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MultiThread(1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/26/MultiThread(1)/" class="article-date">
  <time datetime="2020-10-26T13:11:23.000Z" itemprop="datePublished">2020-10-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/til/">til</a>►<a class="article-category-link" href="/categories/java/til/MultiThread/">MultiThread</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/26/MultiThread(1)/">MultiThread</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MultiThread-1"><a href="#MultiThread-1" class="headerlink" title="MultiThread(1)"></a>MultiThread(1)</h1><p>멀티 쓰레드 프로그래밍: 여러개의 스레드를 사용하는 프로그래밍 기법!</p>
<ul>
<li>Thread: 최소의 프로세스 동작단위 -&gt; 하나의 프로세스는 여러개의 스레드를 가질 수 있다.</li>
<li>Process: OS로부터 메모리를 할당받아 동작하는 프로그램의 동작 단위, 프로그램이 실제로 메모리에 상주하면서 동작할 때 프로세스가 된다.(프로그램을 실행할 때, 멀티 프로세스로 동작하는 프로그램도 있다.)</li>
</ul>
<h1 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h1><ul>
<li>여러 동작을 병렬적으로 처리하여 CPU 사용율 향상 (CPU Utilization) (ex. 인코딩, 랜더링, 배치작업 (DB 정리, 로그처리 등…)    </li>
<li>시간이 걸리는 동작을 분리하여 프로그램의 응답성 향상(ex. GUI, 게임, 앱, 웹API, …)</li>
</ul>
<h1 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h1><ul>
<li>디버깅이 어렵다 -&gt; 쓰레드가 동시에 동작하기 때문에, 디버거로 확인하기 어려움. -&gt; 디버거를 쓰거나, 디버깅을 하기 위한 코드를 추가하면 동작이 변한다.</li>
<li>구현이 어렵다. 쓰레드간의 동기화를 하기 위한 구현이 어렵다. 쉽게 동기화하면 느려진다. -&gt; Context Switching 오버헤드가 있기 때문에 동기화를 잘 못하면 오히려 더 느려진다.</li>
</ul>
<h2 id="쓰레드를-생성하는-3가지-방법"><a href="#쓰레드를-생성하는-3가지-방법" class="headerlink" title="쓰레드를 생성하는 3가지 방법"></a>쓰레드를 생성하는 3가지 방법</h2><h2 id="1-Extends-를-통한-생성"><a href="#1-Extends-를-통한-생성" class="headerlink" title="1. Extends 를 통한 생성"></a>1. Extends 를 통한 생성</h2><pre><code>class MyThread extends Thread &#123;  
@Override  
 public void run() &#123;  
    for (int i = 0; i &lt; 10; i++) &#123;  
        System.out.print(i);  
  &#125;  
    System.out.println();  
    &#125;  
&#125;</code></pre>
<h2 id="2-익명의-내부클래스-를-통한-생성"><a href="#2-익명의-내부클래스-를-통한-생성" class="headerlink" title="2. 익명의 내부클래스 를 통한 생성"></a>2. 익명의 내부클래스 를 통한 생성</h2><pre><code>    Thread p1 = new Thread(new Runnable() &#123; // 1. 익명 내부 클래스  
  @Override  
  public void run() &#123;  
        try &#123;  
            Thread.sleep(50);  
  &#125; catch (InterruptedException e) &#123;  
            e.printStackTrace();  
  &#125;  
        System.out.println(&quot;Hello Thread&quot;);  
  &#125;  
&#125;);</code></pre>
<h2 id="3-람다식을-통한-생성"><a href="#3-람다식을-통한-생성" class="headerlink" title="3. 람다식을 통한 생성"></a>3. 람다식을 통한 생성</h2><pre><code>Thread p2 = new Thread(() -&gt; &#123; // 2. 람다식 구현  
  System.out.println(&quot;Thread by lambda&quot;);  
 while (true) &#123;  

    &#125;  
&#125;);</code></pre>
<h1 id="쓰레드-실행"><a href="#쓰레드-실행" class="headerlink" title="쓰레드 실행"></a>쓰레드 실행</h1><p> 쓰레드는 .start()함수를 통해 실행되며, 한번 실행되면 재사용이 불가합니다. 때문에 실행이 아닌 테스트를 하려면 메인쓰레드로 접근하는 .run()을 사용 하면 됩니다. run은 Thread 에 implement한 Runnable() 인터페이스를 오버라이드한 함수로 쓰레드 실행에 영향을 주지 않습니다.</p>
<h2 id="Sleep-Join"><a href="#Sleep-Join" class="headerlink" title="Sleep(), Join();"></a>Sleep(), Join();</h2><p> 멀티쓰레드의 실행 순서는 OS가 관여하므로(Priority, Starve) 어떤것이 먼저 실행 될지 정확하게 알 수 없습니다. 이를 해결하기 위해 쓰레드를 Thread.sleep(millis) 해주면 해당 쓰레드는 해당 시간 때문에 대기합니다. 하지만 이는 사용자가 직접 얼마나 기다릴 지 기입해야하고 예측해야 하기 때문에 비효율 적입니다. 이를 위해 Join()을 써봅니다.<br>  Join()은 예를들어 p2라는 쓰레드가 실행되고 있다면 다음 쓰레드 전에 p2.join()메소드를 호출합니다. 그렇다면 p2 쓰레드가 끝난 후 다음 쓰레드가 실행될 것입니다. p2.join(millis) 는 해당 시간 동안 기다리고 시간이 되면 강제로 다음 쓰레드를 실행합니다.</p>
<h2 id="구현-후-즉시-실행"><a href="#구현-후-즉시-실행" class="headerlink" title="구현 후 즉시 실행"></a>구현 후 즉시 실행</h2><p>  쓰레드의 레퍼런스를 일일히 지정해주지 않아도 되는 경우가 있습니다. 이 경우</p>
<pre><code>new Thread(() -&gt; &#123;  
    System.out.println(&quot;IDEA&quot;);  
&#125;).start(); // 이렇게 하면 join 등 활용이 어려움</code></pre>
<p>   이런식으로 레퍼런스를 지정해 주지 않고 실행하면 속도가 빨라지지만, 객체지정이 안되어있으니 join등 후에 사용이 어려울 것입니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/10/26/MultiThread(1)/" data-id="ckgz8uann0000jwv1dhxvei2y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MultiThread/" rel="tag">MultiThread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Generic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/14/Generic/" class="article-date">
  <time datetime="2020-08-14T01:57:53.000Z" itemprop="datePublished">2020-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/14/Generic/">Generic</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Generics</h1>
 &nbsp;&nbsp;&nbsp;&nbsp;제네릭... 제네릭...넘모싫어요   
  <h2>왜 필요할까요?</h2> <div image>
  <img src="./img/salt.jpg" width="300" height="200"></div>
*소금이 필요한 이유와 같다 할 수 있죠.
<h2>왜 쓸까요?</h2>
* 제네릭은 편리합니다.
 &nbsp;&nbsp;&nbsp;&nbsp;어떤 점에서 편리할까요. 제네릭의 형태를 한번 뜯어봅시다   
<pre><code> class GenericFoo<T> &#123; // T: 타입 파라미터   
    String name;
    T memberVar;

<pre><code>public GenericFoo(String name, T memberVar) &#123;
    this.name = name;
    this.memberVar = memberVar;
&#125;</code></pre>
<p>}<br></code></pre> &nbsp;&nbsp;&nbsp;&nbsp;이런 형태를 한번 생각해 볼 수 있어요. 클래스    GenericFoo는 T타입파라미터를 멤버변수로 가지고 있습니다. primitive자료형을 제외한 어떠한    자료형도 여기에 올 수 있다는 것이에요. 그럼 생성자로 넘어가 볼까요<br> &nbsp;&nbsp;&nbsp;&nbsp;생성자에서 name과 memberVar을 변수로 받고있어요, 말했듯이 T는 어떠한   객체일수도 있고, String이라거나 할튼 primitive 빼곤 다 되요. 그러면 입력된 memberVar는 인스턴스 변수   memberVar로 저장될것이에요 물론 입력파라미터 자료형 그대로요.<br> &nbsp;&nbsp;&nbsp;&nbsp;뭔가 아이디어가 마구 새미소사요. 저렇게 입력파라미터를 정하지 않았다면,   넣는대로 정해진다면 우리는 오버로딩 오버라이딩을 줄여줄 수 있을것이라고 예상이 되요(아니말고)<br> 이것에 대한 테스트는 뒤로미루고 제네릭의 특수한 케이스에 공부하도록 해요<br> &nbsp;&nbsp;&nbsp;&nbsp;* 문법적 문제가 있는 경우<br> <pre><code><br> class GenericBar<'T'> &#123;<br>    // static T classVar; // not possible<br>    public static <T> T staicMethod(T var) &#123; &#125; // not possible</p>
<pre><code>// T memberVar = new T(); not possible
/*
&#123;
    Object obj = new Object();
    if (obj instanceof T) &#123; // not possible
    &#125;
&#125;*/</code></pre>
<p>}<br></code></pre> &nbsp;&nbsp;&nbsp;&nbsp;쟈 제가 코드에 싹다 주석처리를 해놨죠? 저거 싹다 오류나요 왜그런지 하나씩 짚어보도록 하죠(* 첫째 줄에 ‘T’는 원래 작은 따옴표 안붙이는데 마크다운에서 T가 안보이길래 붙였어요)<br> <pre><code><br>class GenericMethod &#123;</p>
<pre><code>public static &lt;T&gt; T staticMethod (T t) &#123;
    return t;
&#125;

public int method(int x) &#123;
    return x;
&#125;
public &lt;T&gt; T method(T x) &#123;
    return x;
&#125;</code></pre>
<p>}<br></code></pre>&nbsp;&nbsp;&nbsp;&nbsp;비교를 위해 문제가 일어나지 않는 코드와 비교해 볼 겁니다.<br>&nbsp;&nbsp;&nbsp;&nbsp;우리는 항상 근본을 중요시하죠, 정몽주느낌이에요. 그래서 근본을 따져봅시다. 우선 아래 클래스의  <pre><code><br> public static <T> T staticMethod (T t) &#123;<br>        return t;<br>    &#125;<br></code></pre>이건 되는데</p>
<pre><code> 
public static <T> T staicMethod(T var) &#123; &#125;
</code></pre>&nbsp;&nbsp;&nbsp;&nbsp;이건 안된다는 것이에요 어째서 일까요? 답은 '근본'에 있습니다.<img src="./img/근본론.jpg" width="300" height="200">

<p>&nbsp;&nbsp;&nbsp;&nbsp;차근 차근 살펴보죠 우선 class GenericBar&lt;’T’&gt;이 아이는 객체를 생성할 때<br>GenericFoo&lt;’String’&gt; foo = new GenericFoo&lt;’String’&gt;이런식으로 객체를 생성할때 자료형을 정해줍니다.   그리고 class GenericMethod 이 아이는 객체를 생성할 때 보통 클래스마냥 GenericMethod Foo = new    GenericMethod요로코롬 만들어 주면 되겟죠, 전자와 후자의 차이가뭘까요? 일단 후자는 객체를 생성하기 위한 모든조건이 갖추어져있습니다. 이에 이견은 있을 수 없죠. 그런데 전자는 클래스 자체가 제네릭이고 객체가 생성되기 전에 클래스 단에서 제네릭의 자료형이 정해지지 않았어요 뭐 여기까진 괜찮아요 그런데말입니다<br><img src="./img/images.jpg" width="300" height="200"><br>&nbsp;&nbsp;&nbsp;&nbsp;안전성의 문제가 대두됩니다. static T classVar;을 보죠 객체가 생성되기 전에   생성되는 클래스 변수T의 T가 뭔지 몰라요. 객체를 생성해야 하는데 객체를 생성하면서 T를 결정하고 그 후에   T를 요구하면 모를까 객체 생성전부터 T를 요구하네요 빡치게 난 이걸 줄 수 없어요 근데 만들래요 그러니까   엎어버리는겁니다(아님말고)<br>public static <T> T staicMethod(T var) { } 이것 역시 마찬가지에요. 난 너에게 T를 준적이 없는데 먼저 staticMethod를 T를이용해서 정의하래요.<br><img src="./img/nick.jpg" width="300" height="200">아니 이건 너무한거아니냐고. 그래서 자바가 엎어버리고 빨간줄 그어버리는 겁니다. 뭔가 설명이 부족하지만 난여기까지에요 미안해요 카메라맨.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/08/14/Generic/" data-id="ckesqyyiv0000ykv11jqqdz4n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Enum" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/14/Enum/" class="article-date">
  <time datetime="2020-08-14T01:08:22.000Z" itemprop="datePublished">2020-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/til/">til</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/14/Enum/">Enum</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Enumeration</h1>
부장님: 난 짜장면.   
사원1 : 저도 짜장면이요.   
사원2 : 저도 짜장먹겠습니다.   
신짜오 : 저도짜장이요.   
신입 : 저는 짬뽕먹겠습니다.   
*모두 경악한다*   
부장님: Enum....!!!!Enumeration!!!!   
#
 &nbsp;&nbsp;&nbsp;&nbsp;그래요 오늘은 이넘이에요 이넘에 대해 알아보도록 하겟숴요    

<pre><code> enum Job &#123; 
                STUDENT, MARKETING, DEVELOPER, CHIEF_EXECUTIONAL_OFFICER; // 열거형 상수
            &#125;</code></pre>
<p> &nbsp;&nbsp;&nbsp;&nbsp;기본적으로 이넘은 이렇게 씁니다. 근데 이넘의 안에있는 STUDENT, MARKETING 등은 각각 객체입니다. 뭔소리냐구요? 나도 혼란스럽지만 우리같이 해보죠   </p>
<pre><code>enum Family &#123;
               FATHER("아버지"), MOTHER("어머니"), SON("아들"), DAUGHTER("딸"); // 열거형 상수(객체)
               private String koreanWord; // 멤버 변수(객체에 속하는 변수)

               // private은 생략 가능, public 불가능
               private Family(String koreanWord) &#123;
                   this.koreanWord = koreanWord;
               &#125;

               public String getKoreanWord() &#123;
                   return koreanWord;
               &#125;

               public void setKoreanWord(String koreanWord) &#123;
                   this.koreanWord = koreanWord;
               &#125;
           &#125; </code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;위의 코드를 같이 보시죠. 열거형 Family 클래스가 있어요. 안에는 아빠 엄마 아들 딸들이 들어있네요. 단란한 가족이네요. 멤버 변수로써 koreanWork가 있습니다.<br>이제 이 아이들이 어떻게 동작하는지 해석해봐요.<br> &nbsp;&nbsp;&nbsp;&nbsp;멤버변수 아래를 보시면 Family생성자가 보여요 이 생성자는 문자열을 받아서 koreanWord값을 지정해주네요? 그럼 저 생성자는 어떻게 쓰면 좋은것일까요 get-set은 너무당연한거니까 걍넘어갑시다<br> 쟈 한번 보죠 떨리네요 내가말하는게 맞는지아닌지 모호한지아닌지 오류가있는지아닌지 90%확률로 있긴한데 이쪽분야가 용어하나에도 민감하다보니까 무슨말을 할수가 없어요 근데 여긴 내블로그니까 맘대로 싸지를거에요<br> 혹시 보시고 ‘아 자바 저렇게 하는거 아닌데…’하셔도 어쩔 수 없습니다. 쟈 그럼한번 보죠 enum Family클래스안에 원소들은 객체입니다. 즉 Family클래스의 객체인거죠 Family의 생성자는 문자열을 입력으로<br> 받을 수 있고, 즉 FATHER MOTHER… 얘네도 다 문자열을 입력으로 받을 수 있어요. 그 문자열은 private String koreanWord로 저장되겟죠? 그럼 이게 도대체 어떻게 쓰이는 걸까요 그것도 예제를 통해 알아보죠   </p>
<pre><code>        Family fam = Family.SON;
                   Family Fam = Family.SON;
                   System.out.println(fam.getKoreanWord());
                    fam.setKoreanWord("버린 자식");
                    Fam.setKoreanWord("거둬진 자식");
                   System.out.println(fam.getKoreanWord());
                   System.out.println(Family.SON.getKoreanWord()); </code></pre>
<p> &nbsp;&nbsp;&nbsp;&nbsp; 아주 아름다운 코드네요 이뻐요 잘빠졌어요 쟈 해석해봅시다. Family 클래스 틀의 레퍼런스 fam은 SON객체를 생성하죠(아님말고), 아니 여기선<br> 생성한다기보단 불러온다는게 맞을거에요 SON객체는 하나거든요 그래서 불러와서 System.out.println(fam.getKoreanWord()); 을 하면 모가 나올까욘 답은   </p>
<ul>
<li><em>바람이 세차게 부는 1970s 기차역 앞</em>   </li>
<li>???:나물사세요… 나물… 나물한단 사고가세요   </li>
<li>행인1:에잇 아줌마 비켜요 길막지말고   </li>
<li><em>나물 바구니를 발로차는 행인, ???은 쓰러지고만다</em>   </li>
<li>???:아이고,,,안되는데 만식이 공책필요하다했는데…아이고,,,아까워서 어쩌나   </li>
<li>퍽!   </li>
<li><em>‘퍽!’소리와 함께 나뒹굴어지는 행인</em>   </li>
<li>아들:이게…!      </li>
<li>어머니:…”아들”…! 안돼…!<br>&nbsp;&nbsp;&nbsp;&nbsp;네 맞아요 답은 “아들”이었습니다. fam객체는 SON으로 대입시켰고 SON은 파라미터 변수로 “아들”을 줬었죠. Family클래스의 생성자는 koreanWord를 변경했고 다시말해서<br>SON객체의 koreanWord는 “아들”로 변경됬을 것이며 그 결과 fam.getKoreanWord는 “아들”이란 값을 갖고 있을 것이에요. 여기서 fam.set…을 하면 SON객체의 koreanWord를 변경할것입니다.<br>아까 제가 객체를 생성하는게 아니라 불러오는 거라고 했죠 진짠지 같이 한번 보죠. SON객체를 ‘???’ 하고있는 fam과 Fam을 만들었 습니다. 이때 각각 버린자식과 거둬진 자식을 세팅했을 때<br>각각 다른값이 출력되면 새로운 SON을 만든것이겠고, 같다면 SON하나를 공유할 거에요 그럼 결과 같이 보시죠<pre><code>거둬진 자식
거둬진 자식
</code></pre>
&nbsp;&nbsp;&nbsp;&nbsp; 다행이네요, 올겨울은 얼어죽진 않겠어요. 보시다시피 둘다 거둬졌으며 곧 fam과 Fam은 같은 SON을 가리키고 있다는 것을 알 수 있습니다.즉 ???=참조 라고 할 수 있겠네요(아님말고)<br>여기까지 Enum이었습니다 잘가라 이넘들아</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/08/14/Enum/" data-id="ckesqyyj60004ykv194kd3txe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Polymorphism2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/11/Polymorphism2/" class="article-date">
  <time datetime="2020-08-11T12:23:42.000Z" itemprop="datePublished">2020-08-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/til/">til</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/11/Polymorphism2/">Polymorphism2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Pholymorphism2</h1>
 &nbsp;&nbsp;&nbsp;&nbsp;네 폴리모피즘2입니다. 슬슬 어려워지네요, 하지만 우린 취업해서 엄마에게 효도해야겠죠. 엄마 조금만 기다려 아들이 효도할게   

  <h2>Interface</h2>
 &nbsp;&nbsp;&nbsp;&nbsp;다형성을 실현하는 방법중 하나로 인터페이스가 있습니다. 인터페이스는 추상메소드의 확장판인데요,어떤 특징이 있는지 같이 보시죠 물론 예시와 함께요   

 <pre><code> interface Walkable &#123;
                 void walk();
             &#125;

             interface Runnable &#123;
                 void run();
             &#125;

             interface Jumpable extends Walkable, Runnable &#123;
                 void jump();
             &#125;</code></pre>
<p> &nbsp;&nbsp;&nbsp;&nbsp;이 예제가 인터페이스의 특성을 아주 완벼쿠@하게 표현해 줍니다. 먼저 Walkable인터페이스를 보시죠, 해당 인터페이스는 안쪽에 walk메소드를 가지고 있습니다<br> 이는 추상메소드와 마찬가지로 반드시 구현시켜줘야 하죠, 특징적으로 앞에 public abstract가 생략되어서 그렇지 역시 추상메소드입니다.<br> &nbsp;&nbsp;&nbsp;&nbsp;아래 Runnable역시 추상메소드구요 여기서 아래 Jumpable이 보이네요, 추상 클래스와 인터페이스의 큰 차이점은 바로 다중 상속이<br> 되는가입니다. 추상 클래스든 뭐든 원래 상속은 extends키워드로 하나의 클래스밖에 상속할 수 없어요, 하지만 인터페이스는 몇개라도 상속 받을 수 있습니다. 멋지죠?<br> &nbsp;&nbsp;&nbsp;&nbsp;또 한가지 특징은 멤버변수는 항상public static final인데요 역시 생략가능합니다. 이를 제외하곤 원래 인터페이스는 별 특징이 없엇어요 하지만 JDK이후로 끔찍한<br> 혼종이 생기게 됩니다.<br>  <h2>Interface include default method</h2><br>  &nbsp;&nbsp;&nbsp;&nbsp;제목부터 무섭네요. 네 JDK1.8이후로 우리의 인터페이스는 원래 추상메소드만 가질수 있었는데 디폴트 함수도 가질 수 있게 되었습니다.<br>  똑똑하신 분들이 추가하신데는 다 이유가 있겠죠, 이유를 알아볼까요?<br>  <pre><code>   기존에 사용하던 인터페이스가 개선되어, 모든 자식 메소드에 동일하게<br>   &nbsp;&nbsp;&nbsp;&nbsp;구현되어야 하는 메소드가 생긴 경우에 쉽게 기능을 추가하기 위해 만들어짐</code></pre><br>   이라고 되있네요 역시 똑똑한 분들인것 같아요. 다시 풀어서 말해보죠. 여러개의 클래스에 A인터페이스가 상속되었습니다. 그런데 나란 놈은 몽총이라서 뒤늦게 해당 인터페이스에 뭔가를 추가하고싶어요<br>   그런데 만약에 내가 해당인터페이스를 이미 100개의 클래스에 상속시켜버렸다면 난 복붙을 100번해야해요 그런 일이 일어나지 않도록 한번에 추가할 수 있게 디폴트 메소드를 만든것입니다. 여러분 그런데 여기<br>   한가지 트릭이있어요. 저도 속았는데요, 디폴트 메소드는<br>   <pre><code>     default void defaultMethod() &#123; // 디폴트 메소드<br>                       System.out.println("Default method");<br>                   &#125;</code></pre><br>  요롯코롬 인터페이스 내부에 작성합니다. 언뜻보면 디폴트 접근제한자를 쓴 것 같지만 그게아니에요. 의미상으로 디폴트값을 나타내기 위해서 디폴트 접근제한자를 썻지만 여타 다른 메소드와<br>  동일하게 이녀석으 public입니다. 원래 인터페이스 안의 메소드는 모두 public으로 평등하니까요. 그렇다고해요 외워요그냥.<br>   &nbsp;&nbsp;&nbsp;&nbsp;여기서 끝난줄 아셧겠지만 트릭이 사실 한가지 더있습니다. 바로 이 아름다운 디폴트 메소드때문에 생김 참사인데요 코드를 보며 같이 보시죠<br>   <pre><code>class FooThree extends SuperFoo implements IFooTwo </code></pre><br>  &nbsp;&nbsp;&nbsp;&nbsp;이렇게 SuperFoo라는 일반 클래스와 IFooTwo라는 인터페이스를 상속받는 FooThree라는 클래스를 상상해 볼게요 이 때<br>  <pre><code> class SuperFoo &#123;<br>                  public void defaultMethod() &#123;<br>                      System.out.println("Default method in Super class");<br>                  &#125;<br>              &#125;<br>interface IFooTwo &#123;<br>    void abstractMethod();<br>    default void defaultMethod() &#123; // 디폴트 메소드<br>        System.out.println("Default method");<br>    &#125;<br>&#125;<br></code></pre><br> &nbsp;&nbsp;&nbsp;&nbsp;각각의 코드들은 이렇다고 해봅시다. 그러면 여기서 크고 아름다운 문제가 생겨버려요. 상속받은 SuperFoo도 defaultMethod를<br> 가지고 있고, IFooTwo인터페이스도 defaultMethod를 가지고 있네요. 그런데 두 메소드의 내용은 달라요. 과연 FooThree는 누구의 선택을 받을까요? 정답은 바로<br> SuperFoo입니다. Super라서 이긴건 아니구요. 본질을 따져봐야 해요. 원래 인터페이스는 default값을 가진다는 개념이 없엇죠. 하지만 편의성을 위해 나중에 생기긴 했어요<br> 하지만 그 편의성이 본질을 해칠 순 없습니다. 이녀석은 원래는 존재하면 안되는 아이에요. 족보로 따지면 ‘서자’인 셈이져. 반대로 우리 Super는 원래 족보상에 있는 ‘적자’일<br> 거에요. 클래스도 적자서자를 따지는 더러운 세상이져 아 참고로 인터페이스도 키워드가 interface지만 본질은 클래스입니다. 하여튼 답은 SuperFoo였어요.<br> #<br> 이렇게 Polymorphism2도 마쳐보았습니다 즐거우셨나요? 전 즐거웠어요 다음에 또봐요</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/08/11/Polymorphism2/" data-id="ckesqyyj70006ykv1faxp6914" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Polymorphism" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/Polymorphism/" class="article-date">
  <time datetime="2020-08-10T11:03:04.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/til/">til</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/Polymorphism/">Polymorphism1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Polymorphism</h1>
 &nbsp;&nbsp;&nbsp;&nbsp;네 그래요 오늘은 다형성에 대해 알아볼 거십니다.

  <h2>Override</h2>
  &nbsp;&nbsp;&nbsp;&nbsp;뜬금 없지만 제가 좋아하는 노래중 하나는 바로 JP SAXE의 If the world was ending   
  인데요, 처음에 그 노래를 듣고 검색하려고 구글에 override라고 쳤다가 도저히 안나왔던 기억이 있습니다. 알고보니   
  'over right' 였더군요. 그냥 그랬다구요 이제 들어가 보죠   
   #   
  &nbsp;&nbsp;&nbsp;&nbsp; 쟈 다형성을 형성하는 방법으로는 첫번째로 override가 있습니다.   
  override는 상속이 이루어진 경우에만 가능한데요 예를 들어보죠

<pre><code>class Foo &#123;
               static public String y = "Super Class";
               public String x = "Super";

               public void methodA() &#123;
                   System.out.println("Super Method");
               &#125;
           &#125;

           class Bar extends Foo &#123;
               static public String y = "Sub Class";
               public String x = "Sub";

               @Override
               public void methodA() &#123;
                   System.out.println("Sub Method");
               &#125;
           &#125; </code></pre>
<p> &nbsp;&nbsp;&nbsp;&nbsp;쟈 이경우는 Bar가 Foo를 상속했습니다. 그리고 methodA()를 Bar에서 오버라이드 하고있죠<br> 지금은 Foo를 상속한 Bar가 하나지만 Bar1,Bar2,Bar3…이렇게 여러개가 있다면 어떨까요? 맞습니다 필요한 자식 클래스로 필요<br> 할때마다 캐스팅 할 수 있겠죠 이렇게 오버라이딩을 통해 다형성을 실현할 수 있습니다.<br> <h2>Overload</h2><br>   &nbsp;&nbsp;&nbsp;&nbsp;네 두번째 방법은 오버로드인데요 오버로드는 상속이 필요없죠, 그저 필요한 메소드를<br>   상황에 맞게 바꿔쓰시면 됩니다. 이것도 예를 들어보죠</p>
<pre><code>     public Vector3D add(Vector3D x) &#123;
                    return new Vector3D(this.x + x.x,
                            this.y + x.y,
                            this.z + x.z);
                &#125;

                public Vector3D add(float x) &#123;
                    return new Vector3D(this.x + x,
                            this.y + x,
                            this.z + x);
                &#125;</code></pre>
<p> &nbsp;&nbsp;&nbsp;&nbsp; 무섭게 생겼죠? 그래요 나도 무서워요 벡터는 참 못생긴것 같아요 하지만 뜯어보면 이쁜구석이<br> 조금이라도 있을지 모르니 같이 보기로해요. 보면 같은 반환형(Vector3D)에 같은 메소드이름(add)를 가졌네요 그런데 다른게<br> 눈에 띄어요, 바로 파라미터값과 안에 내용이 미묘하게 조큼 다르죠? 그래요 이게 바로 오버로드에요 저그인구수 +8해주는 오버로드가<br> 생각나는 부분이지만 넘어가기로 해요. 결론적으로 오버로드는 파라미터 자료형 또는 갯수가 다를 때 내용을 다르게만들어서 필요할때<br> 바꿔쓸 수 있답니다. 이를 통해서 다형성을 실현할 수 있지요</p>
 <pre><code>     public Vector3D add(Vector3D x) &#123;
                     return new Vector3D(this.x + x.x,
                             this.y + x.y,
                             this.z + x.z);
                 &#125;

                 public Vector3D add(float x) &#123;
                     return new Vector3D(this.x + x,
                             this.y + x,
                             this.z + x);
                 &#125;</code></pre>
 <h2>AbstractClass</h2>
    &nbsp;&nbsp;&nbsp;&nbsp;세번째 방법도있어요 세번쨰는 추상클래스를 통한 다형성의 실현이에요 더럽게 종류도 많네요 하지만   
    여러분과 저는 취업을 해야하니 한번 같이 뜯어보도록 하죠. 저는 예시덕후라 또 예시 한번 가실게요
     <pre><code>abstract class AbstractFoo &#123;
                    int x, y;
                    public void method() &#123;
                        System.out.println("method");
                    &#125;
                    public abstract void abstractMethod();
                &#125;
                class Foo extends AbstractFoo &#123;
                    @Override
                    public void abstractMethod() &#123;
                        System.out.println("implemented abstractMethod");
                    &#125;
                &#125;&#125;</code></pre>무섭게 생겼네요 하지만 해야지 어쩌겠어요 보시면 abstractMethod();를 포함하고있는 클래스는   
                지금까지 우리가 보아온 녀석과 좀달라요. 주황버섯에서 뿔버섯이 됫달까요 그런느낌이죠 다들하시죠? abstract class AbstractFoo라고   
                앞에 abstract가 붙어 있어요 무슨뜻일까요? 네 잘알고 계시네요 추상이란 뜻이에요 추사랑아빠 추상 아니에요   
                그래서 이 추상 클래스, 추상메소드가 뭘 하느냐? 예를들면 가이드라인 같은거에요. 우리 같이 눈을감고 생각해보죠 당신은   
                공사장에서 현장안전관리요원으로 취직했어요 그리고 하루 공사가 끝날 때 꼭 체크해야 할 항목들이 있죠. 예를들면 
                * 개미굴이 몇개인지    
                * 두더지는 보이지않는지    
                * 비둘기는 몇kg정도인지    
               bsp;&nbsp;&nbsp; 체크하는 것들일 거에요 만약에 하나라도 체크를 안하고 퇴근한다면 공사장에 재앙이 생기기 때문에 이것은 회사에서 필수항목으로   
               체크하라고 가이드라인에 넣어놨다 해보죠. 이게바로 추상메소드입니다. 추상클래스에 추상메소드로 선언해 놓으면 당신은 그것을 무조건   
               구현해놔야해요 다시 위의 코드를 보죠 abstract class AbstractFoo 라는 가이드라인에서 public abstract void abstractMethod();항목은   
               꼭 구현해놓으라고 선언한 것이에요 그렇기 때문에 당신이 추상 클래스인 abstract class AbstractFoo를 상속받아서 새로운 클래스를   
               정의하고 싶다면  class Foo extends AbstractFoo에서 
                <pre><code> 
                @Override
                 public void abstractMethod() &#123;
                   System.out.println("implemented abstractMethod");
                  &#125;</code></pre>이부분을 구현해야 한다는 소리에요 안그러면 안되요 이게바로 추상 클래스입니다.



      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/08/10/Polymorphism/" data-id="ckesqyyj50003ykv10zeaayy9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/">til</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/MultiThread/">MultiThread</a></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MultiThread/" rel="tag">MultiThread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/MultiThread/" style="font-size: 13.33px;">MultiThread</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/java/" style="font-size: 16.67px;">java</a> <a href="/tags/til/" style="font-size: 20px;">til</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/30/MultiThread(6)/">MultiThread(1)</a>
          </li>
        
          <li>
            <a href="/2020/10/29/MultiThread(4)/">MultiThread</a>
          </li>
        
          <li>
            <a href="/2020/10/29/MultiThread(5)/">MultiThread</a>
          </li>
        
          <li>
            <a href="/2020/10/28/MultiThread(3)/">MultiThread</a>
          </li>
        
          <li>
            <a href="/2020/10/27/MultiThread(2)/">MultiThread</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Hansol<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>