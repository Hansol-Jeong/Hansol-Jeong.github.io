<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hansol</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="한솔이블로그">
<meta property="og:type" content="website">
<meta property="og:title" content="Hansol">
<meta property="og:url" content="https://hansol-jeong.github.io/index.html">
<meta property="og:site_name" content="Hansol">
<meta property="og:description" content="한솔이블로그">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hansol">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hansol" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hansol</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hansol-jeong.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Spring/springboot&amp;AWS/testCode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/01/Spring/springboot&AWS/testCode/" class="article-date">
  <time datetime="2020-12-31T18:42:14.000Z" itemprop="datePublished">2021-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringBoot-AWS/">SpringBoot&AWS</a>►<a class="article-category-link" href="/categories/SpringBoot-AWS/TestCode/">TestCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/01/Spring/springboot&AWS/testCode/">TestCode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="스프링부트에서-테스트-코드를-작성하자"><a href="#스프링부트에서-테스트-코드를-작성하자" class="headerlink" title="스프링부트에서 테스트 코드를 작성하자"></a>스프링부트에서 테스트 코드를 작성하자</h2><p>패스트 캠퍼스의 강사님들 또한 테스크 코드에 대해 많은 언급을 하셨었습니다. 그만큼 테스트 코드는 중요하다고 할 수 있습니다.</p>
<h3 id="TDD와-단위테스트는-다릅니다"><a href="#TDD와-단위테스트는-다릅니다" class="headerlink" title="TDD와 단위테스트는 다릅니다."></a>TDD와 단위테스트는 다릅니다.</h3><p> TDD: 테스트가 주도하는 개발, 테스트 코드를 먼저 작성하는 것부터 시작<br> 단위 테스트: 기능 단위의 테스트 코드를 작성</p>
<h3 id="단위-테스트의-필요성"><a href="#단위-테스트의-필요성" class="headerlink" title="단위 테스트의 필요성"></a>단위 테스트의 필요성</h3><ul>
<li><p>단위 테스트는 개발 단계 초기에 문제를 발견하도록 도와줍니다</p>
</li>
<li><p>단위 테스트는 개발자가 나중에 코드를 리팩토링 하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게 작동하는지 확인할 수 있습니다.</p>
</li>
<li><p>단위 테스트는 기능에 대한 불확실성을 감소시킬 수 있습니다</p>
</li>
<li><p>단위 테스트는 시스템에 대한 실제 문서를 제공합니다. 즉, 단위 테스트 자체가 문서로서 사용될 수 있습니다.<br>우선 스프링 메인 클래스부터 만들어보겠습니다.<br>   package com.example.admin;  </p>
<p>  import org.springframework.boot.SpringApplication;<br>  import org.springframework.boot.autoconfigure.SpringBootApplication;  </p>
<p>  @SpringBootApplication<br>  public class Application {  </p>
<pre><code>  public static void main(String[] args) &#123;  
      SpringApplication.run(Application.class, args);  
&#125;  </code></pre>
<p>  }<br>하나하나 보겠습니다. 모르는 건 없어야 합니다. @SpringBootApplication을 붙임으로 써 스프링 부트의 자동설정, 스프링 Bean읽기와 생성을 모두 자동으로 합니다. 여기서 자동설정은 매우 중요한 부분입니다. @AutoConfiguration이 @SpringBootApplication안에 래핑되어 있기 때문에 우리는 추가한 dependency에 대해서 일일히 bean등록을 할 필요가 없습니다.<br>SpringApplication.run으로 인해 내장WAS(Web Application Server)가 실행됩니다. 때문에 별도로 톰켓이 필요가 없습니다. 스프링 부트로 만들어진 Jar파일안에 있는 톰캣이 실행되기 때문입니다.<br><img src="https://user-images.githubusercontent.com/50402288/103354612-5b0ab680-4aef-11eb-8625-4be1ea0eba7c.png" alt="20201230213943"><br>디펜던시 안에 Jar파일로 톰켓이 있는 것을 볼 수 있습니다. 이 내장 WAS의 장점은 언제 어디서나 같은 환경을 제공한다는 것입니다. 톰켓 버전이 서로 달라도 내장 톰켓을 사용하니 충돌의 우려가 없습니다.</p>
<p>이제 테스트를 할 코드를 작성하기 전에 기능구현을 해보겠습니다.</p>
<p>   @RestController<br>  public class HelloController {  </p>
<pre><code>  @GetMapping(&quot;/hello&quot;)  
  public String hello() &#123;  
      return &quot;hello&quot;;  
&#125;  </code></pre>
<p>  }<br>아주 기본적인 코드입니다. 하지만 짚고넘어가야 할 점 또한 있습니다.</p>
<h3 id="RestController-V-S-Controller"><a href="#RestController-V-S-Controller" class="headerlink" title="RestController V.S Controller"></a>RestController V.S Controller</h3><p>지금까지 아무런 고민없이 둘을 혼합하여 써왔습니다. 그도 그럴것이 뭔가를 창조적으로 만들어내 본 적 없이 클론 코딩만 하다보니 둘의 차이점을 알지 못했습니다. 이젠 알아야 할 때입니다.<br>이론적으로 보면 RestController = Controller + ResponseBody입니다.</p>
<ul>
<li><p>Controller<br>String 값을 반환 하는 것이 가장 대표적인 형태이며 이로써 ViewResolver를 거쳐 jsp페이지를 보여줍니다.</p>
</li>
<li><p>ResponseBody<br>객체 자체의 값을 Json으로 변환하여 반환합니다.<br>때문에</p>
</li>
<li><p>RestController<br>Controller로써 기능하지만 ViewResolver를 거치치 않습니다. 때문에 특정 페이지로 매핑되지 않고 Json형태로 객체 자체의 값을 반환합니다.</p>
<h4 id="그렇다면-이것이-왜-쓰입니까"><a href="#그렇다면-이것이-왜-쓰입니까" class="headerlink" title="그렇다면 이것이 왜 쓰입니까?"></a>그렇다면 이것이 왜 쓰입니까?</h4><p>기존에는 Controller만으로도 충분했습니다. 필요에 따라서 ResponseBody를 붙여가며 상황에 따라서 값을 반환했습니다. 하지만 <strong>다양한 기기</strong>들에 대한 접속의 <strong>유연성</strong>이 대두되었습니다.<br>예를 들어보겠습니다. 저는 서버에서 ViewResolver를 통해 “/hello”라는 URI에 대해 hello.jsp라는 페이지를 출력하도록 하였습니다. 하지만 이는 다양한 클라이언트를 지원할 수 없습니다. windows에서는 지원이되지만 ios에서는 지원이 되지 않을 수 있고 다른 iot장비에서 jsp를 읽지 못할 수 있습니다. 때문에 서버는 클라이언트 측에 관여를 일 절 하지 않고 객체 자체의 정보만 전달해 주겠다는 것입니다. 이로써 서버-클라이언트의 분리가 더욱 확실해지고 다양한 미디어 기기에 대한 서버의 유연성이 대폭 증가됩니다.</p>
<h3 id="HelllowControllerTest"><a href="#HelllowControllerTest" class="headerlink" title="HelllowControllerTest"></a>HelllowControllerTest</h3><p>   @RunWith(SpringRunner.class)<br>@WebMvcTest(controllers = HelloController.class)<br>public class HelloControllerTest {  </p>
<pre><code>@Autowired  </code></pre>
<p>  private MockMvc mvc;  </p>
<p>  @Test<br>  public void hello_Returning() throws Exception {  </p>
<pre><code>    String hello = &quot;hello&quot;;  </code></pre>
<p>  mvc.perform(get(“/hello”))  </p>
<pre><code>            .andExpect(status().isOk())  
            .andExpect(content().string(hello));  </code></pre>
<p>  }  </p>
<p>}<br>매우 중요한 포인트라고 생각합니다. 여기에 우리가 하려던 단위 테스트의 기초부분이 모두 들어있습니다.</p>
</li>
<li><p>Runwith<br>우선 이 테스트는 Spring환경에서 실행되어야 합니다. 하지만 test패키지는 main패키지를 참조하지 않기 때문에 스프링 환경에서 실행하라고 명시해주어야 합니다. 이 때 @Runwith를 통해서 스프링 환경에서 실행하라고 알려주는 것입니다. 프레임워크로써 스프링을 추가합니다.</p>
</li>
</ul>
</li>
<li><p>WebMvcTest<br>스프링을 프레임워크로 추가했지만 여전히 부족합니다. 이 테스트가 수행되기 위해서는 스프링 부트로써 수행되어야 합니다. 이전에 우리는 스프링 부트로 실행하는 것을 명시하기위해서 @SpringBootApplication을 추가했었습니다. 이 안에는 일 전에 강조한 @AutoConfiguration이 래핑되어있습니다. 이는 사전에 클래스에 대한 객체를 생성합니다. 하지만 문제는 테스트만 하는데 많은 bean을 JVM에 띄울 이유가 없습니다. 때문에 @WebMvcTest를 통해 테스트에 필요한 구성만 bean으로 등록합니다.<br>(<em>하지만 의문점이 있습니다. 처음에는 @WebMvcTest(controllers = HelloController.class)에서 어떻게 HelloController클래스를 인식하는지 이해가 되지 않았습니다. 그래서 이 부분을 지우고 @WebMvcTest만 남기고 해당부분을 지웠음에도 잘 동작하였습니다. 이는 질문으로써 해결해야 할 것입니다.</em>)</p>
<ul>
<li><p>AutoConfiguration<br><a target="_blank" rel="noopener" href="http://dveamer.github.io/backend/SpringBootAutoConfiguration.html%EC%97%90">http://dveamer.github.io/backend/SpringBootAutoConfiguration.html에</a> 굉장히 잘 정리되어 있습니다.<br>spring.factories파일에 정의한 내용에 의해 JVM에 bean을 띄웁니다.<br><img src="https://user-images.githubusercontent.com/50402288/103390553-5e865800-4b58-11eb-9b14-e1cb5d0f566a.png" alt="20201231110708"><br>그렇다고 해서 저 수많은 객체들이 전부 사전에 bean등록되는 것이 아닙니다. 특정 조건을 만족해야 하는 것들이 있습니다. 예를들면 h2콘솔같은경우를 예로 듭니다. 우리는 h2디펜던시를 앞으로 추가할 것입니다. 이를 통해 프로젝트내에서 h2를 데이터 베이스로 사용하는 것이 가능합니다. 하지만 이전엔 한번도 고민해 본적 없던 h2콘솔은 어디에도 정의한 적이 없습니다. 그것이 어떻게 뜨는 건지 생각조차 한 적이 없습니다. 이 때 동작하는 것이 AutoConfiguration이며  특정조건(h2가 의존성 주입되었는지 등)을 만족하면 h2콘솔관련 bean이 JVM 에 뜨며 /h2-console URI로 접속하면 콘솔이 뜨는 것입니다.<br><img src="https://user-images.githubusercontent.com/50402288/103390761-6bf01200-4b59-11eb-9cc8-55c85605000e.png" alt="20201231111436"></p>
</li>
<li><p>Autowired<br>스프링 프레임워크가 관리하는 JVM메모리상의 bean들중에서 적합한 bean을 주입받습니다. 여기서 <strong>적합</strong>이란 해당 클래스 자체일 수도 있고 해당 클래스의 부모 클래스일 수 도 있으며 해당 클래스가 implement한 interface일 수도 있습니다.</p>
</li>
<li><p>MockMvc mvc<br>Mvc테스트의 중추입니다. MockMvc의 의미는 가짜 mvc(model, view, controller) 를 만든다는 것인데 이를 통해 모의 HTTP 요청을 컨트롤러에 보내고 컨트롤러를 서버 내에서 실행하지 않고도 컨트롤러가 어떻게 작동하는지 테스트 할 수 있습니다. 여기서 컨트롤러의 작동이란 HTTP GET, POST, PUT, DELETE 을 의미합니다.</p>
</li>
<li><p>mvc.perform(get(“/hello”))<br>가짜 mvc를 생성해서 이를 통해 서버를 구동시키지 않고도 자체적으로 /hello URI에 대한 테스트를 진행할 수 있습니다. HTTP GET요청을 하며 이 요청에 대한 응답을 통해 여러 검증을 체이닝을 통해 할 수 있습니다.</p>
</li>
<li><p>andExpect(status().Ok())<br>HTTP Header의 상태(status)를 검증합니다 이 때 상태란 200, 404, 500등 서버의 응답 상태를 의미합니다.<br>Ok상태는 200의 의미하기에 200인지 아닌지 검증합니다.</p>
</li>
<li><p>andExpect(contnet().string(hello))<br>본문의 내용이 hello가 맞는지 검증합니다.<br>(<em>여기서 본문의 내용이란 무엇인지 헷갈립니다. 현재는 RestController기 때문에 본문이란 Json의 본문이나, return되는 String이나 같기 때문에 오해의 소지가 없어도, 그냥 Controller라면, 본문이 의미하는 것은 return 되는 String입니까 아니면 prefix, suffix가 붙은 (~/WEB-INF/hello.jsp)입니까</em>)</p>
<h4 id="HelloController"><a href="#HelloController" class="headerlink" title="HelloController"></a>HelloController</h4><p>이제 테스트 코드가 아닌 실제 코드를 실행해보겠습니다.  앞선 테스트대로라면<br>mvc.perform(get(“/hello”).andExpect(status().Ok()).andExpect(content().string(hello));<br>HTTP GET요청에 따른 URI(“/hello”)의 서버 응답상태는 200번이어야 하며, 그 컨텐츠의 내용은 hello여야 할 것입니다. 실행결과는<br><img src="https://user-images.githubusercontent.com/50402288/103366146-299ce580-4b05-11eb-9a97-5b44832e132d.png" alt="20201231010922"></p>
</li>
</ul>
</li>
</ul>
<p>와 같이 정상적인 연결상태에 내용은 hello인 것을 알 수 있습니다.</p>
<h4 id="단위테스트"><a href="#단위테스트" class="headerlink" title="단위테스트"></a>단위테스트</h4><p>단위테스트는 테스트코드를 먼저작성하는지 아닌지는 상관이 없습니다. 그저 그 기능을 테스트할 수 있는 테스트 코드를 만드는 것입니다. 이것이 TDD와 비교되는 점인데 TDD는 명확한 절차가 있습니다. 실질적인 코드를 작성하기 전 미리 항상 실패하는 테스트를 먼저 작성하고 이 후 테스트를 통과하는 코드를 작성하고 이를 리팩토링하여 실질적인 코드를 만듭니다.</p>
<h3 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h3><p> 지금까지 eclipse에서 lombok을 쓸 때는 의존성 추가만 해주면 쓸 수 있었습니다. 하지만 intelliJ는 따로 프로젝트에 플러그인을 설치해주어야 한다는데 이것이 이해가 되질 않았습니다. 그 이유는 플러그인 설치를 안해주면 lombok을 쓰기위한 어노테이션을 intelliJ가 인식하지 못하여 오류처리하지 때문입니다. 그런데 최신버전 intelliJ는 괜찮나 봅니다. 자동으로 롬복이 설치되어 있었습니다.</p>
<h4 id="HelloResponseDto"><a href="#HelloResponseDto" class="headerlink" title="HelloResponseDto"></a>HelloResponseDto</h4><pre><code>@Getter  
@RequiredArgsConstructor  
public class HelloResponseDto &#123;  
    private final String name;  
 private final int amount;  
&#125;</code></pre>
<p>롬복을 통해 Dto(Data Transfer Object, VO(Value Object와 같은개념이나 VO는 read only이다.)를 작성하였다</p>
<ul>
<li>Getter<br>get 메소드를 자동으로 생성해준다.<ul>
<li>RequiredArgsConstructor<br>선언된 모든 final필드가 포함된 생성자를 생성해 줍니다.<br>final이 없는 필드는 생성자에 포함되지 않습니다. 즉 name과 amount를 초기화 해줄 파라미터가 포함된 생성자를 생성합니다.</li>
</ul>
</li>
</ul>
<h4 id="HelloResponseDtoTest"><a href="#HelloResponseDtoTest" class="headerlink" title="HelloResponseDtoTest"></a>HelloResponseDtoTest</h4><pre><code>public class HelloResponseDtoTest &#123;  
    @Test  
  public void lombok_test() &#123;  
        String name = &quot;hansol&quot;;  
 int amount = 25;  

  HelloResponseDto dto = new HelloResponseDto(name, amount);  
  assertThat(dto.getName()).isEqualTo(name);  
  assertThat(dto.getAmount()).isEqualTo(amount);  
  &#125;  
&#125;
##### 롬복 에러
그런데 문제는 해당 테스트가 지속적으로 통과되지가 않았습니다. 이유는 생각보다 간단했습니다. gradle 5 버전 이상부터 lombok의 디펜던시 설정방법이 세분화 되었기 때문입니다.</code></pre>
<p>implementation ‘org.projectlombok:lombok’<br>기존에는 이렇게 했었지만</p>
<pre><code>compileOnly(&quot;org.projectlombok:lombok&quot;)  
testCompileOnly(&quot;org.projectlombok:lombok&quot;)  
annotationProcessor(&quot;org.projectlombok:lombok&quot;)  
testAnnotationProcessor(&quot;org.projectlombok:lombok&quot;)</code></pre>
<p>이제는 설정 시 이렇게 설정해주어야 한다고 합니다. 바꾸니 테스트를 통과하였습니다.</p>
<ul>
<li>assertThat<br>.andExpect와 같은 기능을 하는 검증 메소드입니다. 마찬가지로 체이닝이 지원되어 메소드를 이어서 사용할 수 있습니다.</li>
<li>isEqualTo<br>비교하는 값이 같다면 참입니다.</li>
</ul>
<h4 id="HelloController-1"><a href="#HelloController-1" class="headerlink" title="HelloController+"></a>HelloController+</h4><p>HelloResponseDto가 정상으로 작동하는 것을 단위테스트에서 확인하였으니 HelloController에 추가해보겠습니다.</p>
<pre><code>@GetMapping(&quot;/hello/dto&quot;)  
public HelloResponseDto helloDto(@RequestParam(&quot;name&quot;) String name,  
  @RequestParam(&quot;amount&quot;) int amount) &#123;  
    return new HelloResponseDto(name, amount);  
&#125;</code></pre>
<ul>
<li>RequestParam<br>HTTP Request 파라미터를 받을 수 있습니다. 즉 Request에 있는 파라미터와 받고자 하는 변수명을 일치시키면 해당 값을 가져올 수 있습니다. 이를 통해 fastcampus프로젝트에서 jsp에서 request로 넘긴 값을 entity에서의 변수와 일치시켜 해당 entity에 변수 값을 1대1매핑시켜서 객체 형태로 controller에 받아 쓸 수 있었습니다. 쓸 땐 몰랐는데 이제야 이해가 되는 부분입니다.</li>
</ul>
<h4 id="HelloControllerTest"><a href="#HelloControllerTest" class="headerlink" title="HelloControllerTest+"></a>HelloControllerTest+</h4><p>위의 코드를 실행 하기 전 이에 대한 테스트 코드를 작성합니다</p>
<pre><code>@Test  
public void helloDto_Returning() throws Exception &#123;  
    String name = &quot;hansol&quot;;  
 int amount = 25;  

  mvc.perform(get(&quot;/hello/dto&quot;).param(&quot;name&quot;, name)  
    .param(&quot;amount&quot;, String.valueOf(amount)))  
            .andExpect(status().isOk())  
            .andExpect(jsonPath(&quot;$.name&quot;, is(name)))  
            .andExpect(jsonPath(&quot;$.amount&quot;, is(amount)));  
&#125;</code></pre>
<ul>
<li>param<br>요청 파라미터를 설정합니다. 컨트롤러 작성시 어노테이션 @RequestParam을 통해 request name 파라미터를 필드명 name에 매칭시켜주기로 했었습니다. 때문에 param을 통해서 request파라미터 name에  name(hansol)을 주입시킵니다. 이것은 외부에서 request형태로 name = “hansol” 파라미터를 전달해 준 것과 같습니다. 그러면 컨트롤러에서 request파라미터중 name을 찾아 메소드 파라미터로써 name을 받아옵니다. 이를 통해 return시 HelloResponseDto의 생성자 파라미터로 넘겨서 반환합니다.<ul>
<li>jsonPath<br>jsonPath는 response를 확인하는 용도입니다. 이 때 json의 필드명은 $.name과 같이 가져옵니다.</li>
</ul>
</li>
</ul>
<p>코드는 해당 URI로 들어간다면 request파라미터 “name”에 name을 매핑할 것이고 마찬가지로 “amount” 에 amount를 매핑할 것입니다. 이 때 기대가 됩니다. 무엇이? 상태가 200번일 것이 또한 기대가 됩니다. 무엇이? response해준 json에서 “name”파라미터의 값이 name일 것이, 또한 “amount”파라미터의 값이 amount일 것이 기대가 됩니다.<br>(<em>그렇다면 RestController가 아닌 기본 Controller를 사용 했을 때  Response에 대한  Test는 어떻게 합니까? 이 때는 json이 아니라 html, 또는 jsp형태로 반환되지 않습니까?</em>)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2021/01/01/Spring/springboot&AWS/testCode/" data-id="ckjd7diub0004e8v1fhk5a6u0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springBoot/" rel="tag">springBoot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/testCode/" rel="tag">testCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/springboot&amp;AWS/intelliJ&amp;springboot" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/31/Spring/springboot&AWS/intelliJ&springboot/" class="article-date">
  <time datetime="2020-12-31T03:44:55.000Z" itemprop="datePublished">2020-12-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringBoot-AWS/">SpringBoot&AWS</a>►<a class="article-category-link" href="/categories/SpringBoot-AWS/intelliJ-springboot/">intelliJ&springboot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/31/Spring/springboot&AWS/intelliJ&springboot/">intelliJ&amp;springboot</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="스프링-부트와-AWS로-혼자-구현하는-웹-서비스"><a href="#스프링-부트와-AWS로-혼자-구현하는-웹-서비스" class="headerlink" title="스프링 부트와 AWS로 혼자 구현하는 웹 서비스"></a>스프링 부트와 AWS로 혼자 구현하는 웹 서비스</h1><p> 요즘 fastcampus를 다니면서 미니프로젝트로 사이트구현 하나를 해 보았다. 하면서 느낀것은 아직 이만큼 배웠어도 어색하고, 한참 부족하고, 어설프다는 것이다. 모르는 것이 있으면 찾아보는데 하루를 보내기 일수였다. 때문에 마지막 프로젝트 때는 어설프게 하지 않기 위해서. 정말 제대로 프로젝트를 해보고 싶기에 따로 또 공부를 해야 한다고 느꼇다. 때문에 인텔리제이, JPA, JUnit테스트, 그레이들, 소셜 로그인, AWS까지 사용해서 딱 내가 원하는 내용을 포함하고 있는 이 책으로 혼자 공부를 먼저 해보아야 겠다고 느꼈다. 잘부탁해 책아</p>
<h2 id="인텔리제이로-스프링-부트-시작하기"><a href="#인텔리제이로-스프링-부트-시작하기" class="headerlink" title="인텔리제이로 스프링 부트 시작하기"></a>인텔리제이로 스프링 부트 시작하기</h2><h3 id="인텔리제이"><a href="#인텔리제이" class="headerlink" title="인텔리제이"></a>인텔리제이</h3><ul>
<li><p>강력한 추천기능</p>
</li>
<li><p>다양한 리팩토링과 디버깅 기능</p>
</li>
<li><p>이클립스의 깃에 비해 훨씬 높은 자유도</p>
</li>
<li><p>프로젝트 시작할 때 인덱싱을 하여 파일을 비롯한 자원들에 대한 빠른 검색속도</p>
</li>
<li><p>HTML과 CSS, JS, XML에 대한 강력한 기능 지원</p>
</li>
<li><p>자바, 스프링 부트 버전 업에 맞춘 빠른 업데이트<br>라고 설명하고 있지만 둘  다 써본 바로는 추천기능에 대해선 차이점을 느끼지 못했다. 다만 이클립스보다 깃의 활용도는 월등히 높았으며 검색속도는 정말 비교할 수도 없을만큼 인텔리제이가 빠르다. 이클립스는 좀 느리고 버벅인다. HTML, CSS, JS, XML에 대해선모르지만 자바, 스프링 부트버전업에 맞춘 빠른업데이트는 확실히 좋다. </p>
<h3 id="Plugin-VS-Dependency"><a href="#Plugin-VS-Dependency" class="headerlink" title="Plugin VS Dependency"></a>Plugin VS Dependency</h3><p>그동안 정말 궁금했었다. 메이븐이나 그레이들 설정 파일을 보면 Plugin 과 dependency 가 나뉘어져 있다. 언뜻 봐서는 둘이 하는 역할 차이를 전혀 모르겠었다. 아직 그레이들을 써본적이 없지만 메이븐에서는 필요한 외부 라이브러리를 가져올 때 dependency에 추가해서 사용하면 되었다. 그러면 plugin과 dependency 의 차이는 무엇일까? 기본 개념은 다음과 같다</p>
<p><strong>Plugin</strong> 은 Maven 빌드를 실행할 때 사용하는 도구입니다.</p>
</li>
</ul>
<p><strong>Dependency</strong> 는 코드에서 사용할 라이브러리의 종류를 의미합니다.</p>
<p> 즉 메이븐자체를 뭔가를 해석하는 번역가라고 한다면 플러그인은 그 번역을 실행할 때 필요한 펜, 지우게 이런 도구들을 의미할 것이고 디펜던시는 영어가 나왔을 때 참고할 영어사전, 프랑스어가 나왔을 때 참고할 프랑스어 사전을 의미할 것이다. 또한 도구 즉 펜과 지우게는 번역을 하는 모든 과정에서 쓰이지만, 영어사전은 영어가 나왔을 때만, 프랑스사전은 프랑스어가 나왔을 때만 적용된다. 다음 사진은 Stack Overflow에서 찾은 비교 테이블이다.<br> <img src="https://user-images.githubusercontent.com/50402288/103347472-73240b00-4ada-11eb-97fd-6e14101b977a.png" alt="image"></p>
<ul>
<li>플러그인은 작업 전반에 걸쳐 쓰임 / 디펜던시는 클래스 경로에 추가하여 작업 구현중에 사용</li>
<li>관리하기 어려움(한번 추가하면 수정하기 어려움) / 관리하기 쉬움</li>
<li>JAR파일, 유닛 테스트 코드, 컴파일 코드를 생성함 / 재사용 가능한 빌드가 정의되어 생성 및 유지가 가능해짐<h3 id="build-gradle이해하기"><a href="#build-gradle이해하기" class="headerlink" title="build.gradle이해하기"></a>build.gradle이해하기</h3></li>
</ul>
<pre><code>plugins &#123;  
  id &#39;java&#39;  
&#125;  

group &#39;org.example&#39;  
version &#39;1.0-SNAPSHOT&#39;  

repositories &#123;  
  mavenCentral()  
&#125;  

dependencies &#123;  
  testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;  
&#125;</code></pre>
<p>해당 코드는 그레이들 프로젝트를 생성 했을 때 처음 생기는 가장 기본적인 build.gradle코드 입니다. 현재 플러그인으로 java가 등록되어 있고, 그 아래 제 프로젝트에 대한 정보가 있습니다. dependency를 가져올 저장소로써 mavenCentral()을 선택하였고 가져올 dependency로써는 junit을 테스트 컴파일 할 때만 쓰도록 가져왔습니다.<br>이를 책에서와 같이 수정하면 컴파일이 안됩니다. 아마 문법이 바뀌었는지 되지 않아 인터넷을 보고 공부한 것을 설명하겠습니다.</p>
<pre><code>plugins &#123;  
  id &#39;java&#39;  
  id &#39;org.springframework.boot&#39; version &#39;2.1.7.RELEASE&#39;  
&#125;  

group &#39;org.example&#39;  
version &#39;1.0-SNAPSHOT&#39;  
sourceCompatibility = 1.8  

repositories &#123;  
  mavenCentral()  
    jcenter()  
&#125;  

apply plugin:&#39;io.spring.dependency-management&#39;  

dependencies &#123;  
  implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;  
  testImplementation &#39;org.springframework.boot:spring-boot-starter-test&#39;  
&#125;</code></pre>
<p> 기본적으로 java와 스프링부트 버전2.1.7버전을 플러그인으로써 사용할 것입니다. group과 version은 현재 제 프로젝트의 정보이고, sourceCompatibility는 현재 제가 컴파일 할 때 쓸 자바 jdk버전을 말합니다. 이와 비슷한 개념으로 targetCompatibility가 있습니다. 이는 컴파일 결과 생성된 클래스파일의 jdk버전을 결정합니다. 목적은 JVM과 호환될 때 버전을 결정해 주기 위함이며 대부분의 경우 sourceCompatibility = targetCompatibility입니다.<br> repositories는 dependency를 어느 저장소에서 가져올 지 결정하는 항목으로 현재 두개의 저장소를 지정하였습니다. apply plugin은 추가적으로 플러그인을 지정하는 것이며 스프링에서 의존성을 관리해주는 필수적인 dependency-manager를 추가하였습니다. 이제 repositories에서 가져올 dependencies로써 두가지를 가져왔는데 implementation이 붙은 dependency는 컴파일 시 사용할 디펜던시이며 test가 붙으면 테스트를 할 때 사용할 디펜던시입니다.<br> <img src="https://user-images.githubusercontent.com/50402288/103351782-a15c1780-4ae7-11eb-9508-fe2c844581d4.png" alt="20201230213943"><br>사진을 보면 dependency에 compileClasspath와 testClasspath에 각각 의존성들이 추가된 것을 볼 수 있습니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/12/31/Spring/springboot&AWS/intelliJ&springboot/" data-id="ckjd7ditz0001e8v1gl9s80qc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springBoot/" rel="tag">springBoot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/22/Spring/fastcampus/day_8/" class="article-date">
  <time datetime="2020-12-21T18:16:58.022Z" itemprop="datePublished">2020-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/12/22/Spring/fastcampus/day_8/" data-id="ckjd7dite0000e8v1gmdo3lze" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/25/Spring/fastcampus/day_7/" class="article-date">
  <time datetime="2020-11-25T06:11:25.000Z" itemprop="datePublished">2020-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-7/">day_7</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/25/Spring/fastcampus/day_7/">day_7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/102800280-fff20900-43f6-11eb-93ac-2fac7080233a.png" alt="image"><br>“The purpose of life is finding the largest burden that you can bear and bearing it.”<br>― Jordan B. Peterson</p>
<hr>
<p><img src="https://user-images.githubusercontent.com/50402288/102800592-6f67f880-43f7-11eb-9d93-d309389579db.png" alt="image"></p>
<h2 id="아키텍쳐는-어플리케이션의-뼈대입니다-그렇다면"><a href="#아키텍쳐는-어플리케이션의-뼈대입니다-그렇다면" class="headerlink" title="아키텍쳐는 어플리케이션의 뼈대입니다. 그렇다면"></a>아키텍쳐는 어플리케이션의 뼈대입니다. 그렇다면</h2><h3 id="아키텍쳐란-무엇입니까"><a href="#아키텍쳐란-무엇입니까" class="headerlink" title="아키텍쳐란 무엇입니까?"></a>아키텍쳐란 무엇입니까?</h3><ul>
<li>MODEL_1 Architecture<ul>
<li>아키텍쳐는 어플리케이션의 뼈대</li>
<li>MODEL: VO</li>
<li>VIEW: JSP</li>
<li>CONTROLLER: controller(servlet)</li>
</ul>
</li>
</ul>
<h2 id="session-이나-request에-결과가-저장이-되었다면el과-jstl을-통해서-jsp에-뿌려줄-수-있습니다"><a href="#session-이나-request에-결과가-저장이-되었다면el과-jstl을-통해서-jsp에-뿌려줄-수-있습니다" class="headerlink" title="session 이나 request에 결과가 저장이 되었다면el과 jstl을 통해서 jsp에 뿌려줄 수 있습니다."></a>session 이나 request에 결과가 저장이 되었다면el과 jstl을 통해서 jsp에 뿌려줄 수 있습니다.</h2><h3 id="model-addAttribute-“List”-List"><a href="#model-addAttribute-“List”-List" class="headerlink" title="model.addAttribute(“List”, List);"></a>model.addAttribute(“List”, List);</h3><p> List란 Key값으로 List 객체를 넣어줬다면 jsp에서<br> &lt;c:forEach var=”content” items=”${List}”&gt;</p>
<p></c:forEach><br>이런식으로 List의 원소값들을 뿌려 줄 수 있습니다. 그렇다면 그 원소값은 ${content}로 뿌려줄 수 있을 것입니다. </p>
<h3 id="session-setAttribute-“List”-List"><a href="#session-setAttribute-“List”-List" class="headerlink" title="session.setAttribute(“List”, List);"></a>session.setAttribute(“List”, List);</h3><p>session도 마찬가지 입니다. session.setAttribute(“List”, List); 으로 세션에 저장하였다면<br>${sessionScope.List}로 값을 뿌려줄 수 있습니다.</p>
<h2 id="IoC-Inversion-of-Control"><a href="#IoC-Inversion-of-Control" class="headerlink" title="IoC(Inversion of Control)"></a>IoC(Inversion of Control)</h2><ul>
<li>원래는 개발자가 객체의 생명주기를 관리합니다 하지만 이 제어권을 프레임워크(Spring)에게 넘겨주는 것이 IoC입니다. 때문에 제어의 역제어라고 합니다.</li>
<li>이제 개발자는 객체를 ‘생성’하는 것이 아닌 ‘호출’하여 씁니다.</li>
<li>역제어의 예)  서블릿은 개발자가 만드는 것이 아니다. xml을 로딩하여 서블릿 컨테이너가 서블릿을 만든다. 제어권은 서블릿 컨테이너에게 있다.<h3 id="순제어-V-S-역제어"><a href="#순제어-V-S-역제어" class="headerlink" title="순제어 V.S 역제어"></a>순제어 V.S 역제어</h3>순제어는 유지보수가 어렵습니다.  하지만 역제어는 유지보수가 용이합니다. (xml파일만 건드리면 됩니다)</li>
</ul>
<p>스프링 컨테이너도 마찬가지입니다. 서블릿 컨테이너와 마찬가지로 xml파일을 로딩합니다<br> 로딩하면 xml파일에 bean등록된 클래스들이 객체로서 JVM 메모리에 올라갑니다. 어떤 객체가 메모리에 뜰지는 xml만 수정하면 수정가능합니다. 이것이 역제어의 편리성입니다.</p>
<p>스프링컨테이너가 bean등록한 객체들을 무조건 메모리에 띄운다. (등록된 순서대로)<br>이 떄 bean등록되는 클래스들은 모두 디폴트 생성자가 필요합니다. 컨테이너에서 bean등록 시 디폴트 생성자가 없다면 메모리에 띄우지 않습니다. 그래서 의존성 주입이 필요합니다.</p>
<h3 id="의존성-주입"><a href="#의존성-주입" class="headerlink" title="의존성 주입"></a>의존성 주입</h3><ul>
<li><p>Constructor Injection</p>
</li>
<li><p>Setter Injection</p>
<h3 id="Constructor-Injection"><a href="#Constructor-Injection" class="headerlink" title="Constructor Injection"></a>Constructor Injection</h3><p>간단한 가정! 현재 TV라는 인터페이스가 있으며 TV를 상속받은 sonyTV, samsungTV 클래스가 있다고 가정합니다. 또한 Speaker 인터페이스가 있으며 역시 sonySpeaker, samsungSpeaker가 있습니다.</p>
<pre><code> &lt;bean id=&quot;tv&quot; class=&quot;polymorphism.SamsungTV&quot;&gt;</code></pre>
</li>
</ul>
<p>라고 명시되어 있다면 해석은 “tv”라는 id로 호출할 수 있는 bean객체를 등록할 것인데 그 bean객체의 클래스는 samsungTV입니다. 때문에 JVM메모리에 떠있는 TV라는 인터페이스를 가진 객체는 samsungTV하나이죠. 이를 @Component(“tv”)해서 객체를 가져온다면 samsungTV객체가 로딩될 것입니다.<br> 이 때 samsungTV는 speaker라는 필드를 가지고 있습니다. 이 speaker또한 인터페이스이니 해당 인터페이스를 상속받은 객체를 주입시켜주어야 합니다 이를 생성자 인젝션으로 한다면</p>
<pre><code>   &lt;constructor-arg  ref=&quot;sony&quot;&gt;&lt;/constructor-arg&gt;
   &lt;bean id=&quot;sony&quot; class=&quot;polymorphism.SonySpeaker&quot;&gt;&lt;/bean&gt;
   &lt;/bean&gt;</code></pre>
<p>와 같이 됩니다 이를 해석하면 tv bean을 띄울 때 constructor-arg: 생성자로서 “sony”라는 id를 가진 bean객체를 등록합니다. 이는 samsungTV객체가 생성될 때 samsungTV생성자의 파라미터로써 들어가게 된다는 의미입니다. 주의할 점은 bean에 등록되려면 스프링 컨테이너가 해당 bean을 인지할 수 있어야 하며 전제조건으로 bean으로 등록되려는 클래스는 꼭 디폴트 생성자를 가져야 한다고 했습니다. 때문에 생성자를 오버라이딩하여 Speaker클래스의 객체를 파라미터로 받는 생성자를 만들어 줘야 합니다.</p>
<pre><code>public SamsungTV(SonySpeaker speaker) &#123;

System.out.println(&quot;===&gt; SamsungTV  객체 생성&quot;);

this.speaker = speaker;

&#125;</code></pre>
<h3 id="Setter-Injection"><a href="#Setter-Injection" class="headerlink" title="Setter Injection"></a>Setter Injection</h3><p> Setter Injection이 이루어지기위한 간단한 전제조건은 samsungTV()에 setSpeaker()라는 세터메소드가 존재해야한다는 것입니다. </p>
<pre><code> public void setSpeaker(SonySpeaker speaker) &#123;

this.speaker  = speaker;

&#125;</code></pre>
<p>또한 xml단에서는 </p>
<pre><code>&lt;bean id=&quot;tv&quot; class=&quot;polymorphism.SamsungTV&quot;&gt;

&lt;property name=&quot;speaker&quot;  ref=&quot;sony&quot;&gt;&lt;/property&gt;

&lt;/bean&gt;

&lt;bean id=&quot;sony&quot; class=&quot;polymorphism.SonySpeaker&quot;&gt;&lt;/bean&gt;</code></pre>
<p>  “tv”라는 id를 가진 bean객체를 등록하는데 이 객체의 클래스는 samsungTV입니다. 이 때<br> property: speaker필드의 값을 “sony”라는 id를 가진 bean으로 설정합니다.<br> “sony”라는 id를 가진 bean은 sonySpeaker클래스를 가진 객체입니다.</p>
<ul>
<li><p>id를 지정해주지 않았을 시<br>Creating instance of bean ‘Polymorphism4.GoogleTV#0’  이 콘솔에 뜹니다 이것이 자동생성되는 고유아이디입니다.</p>
</li>
<li><p>컨테이너는 MAP이다. bean에서 Key=tv, value=samsungTV</p>
</li>
<li><p>컨테이너가 xml파일을 로딩합니다 : xml을 통해서 spring container을 제어할 수 있다.</p>
</li>
<li><p>아키텍쳐는 jar형태로서 라이브러리에 다 들어있다. 이것이 뼈대이며 이것이 프레임 워크입니다.</p>
</li>
<li><p>프레임워크가 뼈대이면 비지니스로직은 뼈대에 붙일 살이라고 할 수 있습니다.</p>
</li>
<li><p>이 뼈와 살을 연결하는 것이 xml환경설정 파일.(접착제, 살을 뼈에 넘겨줄 건데 어떤 설정으로 넘겨줄 것이냐)</p>
<h2 id="서블릿-컨테이너와-스프링-컨테이너의-비교"><a href="#서블릿-컨테이너와-스프링-컨테이너의-비교" class="headerlink" title="서블릿 컨테이너와 스프링 컨테이너의 비교"></a>서블릿 컨테이너와 스프링 컨테이너의 비교</h2><p>서블릿은 클라이언트가 불러야주고 스프링은 애초에 컨테이너 호출하면 메모리에 다 올리고시작하고 하지만 둘다 역제어는 똑같고 왜 똑같냐 스프링은 컨테이너가 bean을 불러와서 객체생성하고 서블릿은 서블릿 컨테이너가 url맞으면 그 때 서블릿 생성하고 그래서 역제어인건 똑같애</p>
<ul>
<li>서블릿 컨테이너는 클라이언트가 요청시에 서블릿 객체를 생성합니다(lazy-loading) 반면에 스프링 컨테이너는 호출됨과 동시에 객체를 메모리에 다 로딩 시키고 시작합니다.(pre-loading).</li>
</ul>
</li>
<li><p>둘다 역제어 입니다. 스프링은 컨테이너가 bean을 불러와서 객체생성하니까 역제어이고, 서플릿은 서블릿 컨테이너가 url이 맞으면 그 때 서블릿을 생성하므로 역제어인 것은 동일합니다.</p>
</li>
</ul>
<p>디폴트 생성자만 쓰면 그럼 초기화는 어떻게해? -&gt;  xml에 초기화 메소드, 파괴메소드 등록할 수 있어.<br>같은 객체 계속 불러와야돼? -&gt; 싱글톤 -&gt; 싱글톤도 하지마</p>
<h2 id="Ioc는-두가지-제어를-개발자에게서-가져갔다"><a href="#Ioc는-두가지-제어를-개발자에게서-가져갔다" class="headerlink" title="Ioc는 두가지 제어를 개발자에게서 가져갔다"></a>Ioc는 두가지 제어를 개발자에게서 가져갔다</h2><ol>
<li>객체 생성</li>
<li>객체와 객체간의 의존관계<br>객체생성은 xml파일에서 관리하고, 의존관계 역시 xml파일에서 관리합니다.</li>
</ol>
<h2 id="Annotation설정"><a href="#Annotation설정" class="headerlink" title="Annotation설정"></a>Annotation설정</h2><p>@Autowired: 매우매우 중요한 타입인젝션, 변수의 타입을 기준으로 의존성 주입을 처리한다.<br>따라서 해당 타입의 객체가 메모리에 있기만 하면 컨테이너가 그 객체를 변수에 할당한다.<br>만약 주입할 객체가 없으면 exception 발생 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/25/Spring/fastcampus/day_7/" data-id="ckiyvr0fa0002kwv1hixjgdzv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/24/Spring/fastcampus/day_6/" class="article-date">
  <time datetime="2020-11-24T04:01:53.000Z" itemprop="datePublished">2020-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-6/">day_6</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/24/Spring/fastcampus/day_6/">day_6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/100047678-674b8600-2e56-11eb-8773-cdbf9702f948.png" alt="image"><br>Success is not final, failure is not fatal: it is the courage to continue that counts. -Winston Churchill</p>
<ul>
<li>el, jstl</li>
<li>mvc 패턴</li>
<li>framework란 무엇인가</li>
</ul>
<h2 id="el-jstl"><a href="#el-jstl" class="headerlink" title="el, jstl"></a>el, jstl</h2><p>우리는 서블릿을 작성하던 중 브라우저에 나타날 HTML코드를 서블릿에서 일일히 out.println()으로 작성하는 것에 매우 불편함을 느꼈었 습니다. 그렇기에 JSP를 통해 HTML과 자바코드를 분리하고자 시도했죠. 개선은 되었지만 여전히 Java코드와 HTML코드는 완벽하게 분리되지 않았고, 불편했습니다. 때문에 적용하는 것이 el, jstl입니다.</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>el과 jstl이 적용되는 예를 보기전에 MVC패턴에 대해 알고 지나가야 합니다. MVC 란 model, view, controller를 각각 한자씩 딴것으로 아래와 같은 프로토콜을 가지고 있습니다.<br><img src="https://user-images.githubusercontent.com/50402288/100053303-1beba480-2e63-11eb-9333-5578c7d0cd08.png" alt="20201124144040"></p>
<p>HTML관련 코드는 모두 view, 즉 jsp파일로 만듭니다. jsp파일에서 request를 요청하면 jsp파일에서 분리된, 자바코드로 이루어진 controller가 요청을 처리합니다. 요청을 처리할 때 VO, DAO가 포함된 Model의 데이터를 활용해서 응답화면(view)를 클라이언트에 전송해줍니다. 이렇게 모델, 뷰, 컨트롤러로 역할이 분담된 형태를 MVC패턴이라 합니다.</p>
<p>쟈, MVC가 뭔지 찍먹해봤습니다. MVC란 각각의 역할을 분담하였다고 했는데 이 때 el, jstl이 사용됩니다. MVC로 코드를 나누기 전 우리의 JSP파일에는 여전히 JAVA코드가 남아있습니다 보시겠습니다.</p>
<h3 id="getBoardList-jsp"><a href="#getBoardList-jsp" class="headerlink" title="getBoardList.jsp"></a>getBoardList.jsp</h3><pre><code>&lt;%@page import=&quot;com.rubypaper.biz.user.UserVO&quot;%&gt;
&lt;%@page import=&quot;java.util.List&quot;%&gt;
&lt;%@page import=&quot;com.rubypaper.biz.board.BoardDAO&quot;%&gt;
&lt;%@page import=&quot;com.rubypaper.biz.board.BoardVO&quot;%&gt;
&lt;%@page contentType=&quot;text/html; charset=EUC-KR&quot;%&gt;

&lt;%
    // 0. 세션에 등록된 정보 꺼내기

    // 1. 사용자 입력정보 추출

    // Null Check

    // 2. DB 연동 처리

    // 3. 응답 화면 구성
    * 를 구성하는 자바코드 *
%&gt;
* 자바코드가 포함된 HTML *코드
&lt;!DOCTYPE html PUBLIC &#39;-//W3C//DTD HTML 4.01 Transitional//EN&#39; &#39;http://www.w3.org/TR/html4/loose.dtd&#39;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html; charset=EUC-KR&#39;&gt;
&lt;title&gt;글 목록&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;center&gt;
        &lt;h1&gt;게시글 목록&lt;/h1&gt;
        &lt;h3&gt;
            &lt;font color=&#39;red&#39;&gt;&lt;%= user.getName() %&gt;&lt;/font&gt;님 로그인 환영합니다...... &lt;a href=&#39;logout_proc.jsp&#39;&gt;Log-out&lt;/a&gt;
        &lt;/h3&gt;
        &lt;!-- 검색 시작 --&gt;
        &lt;form action=&#39;getBoardList.jsp&#39; method=&#39;post&#39;&gt;
            &lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;
                &lt;tr&gt;
                    &lt;td align=&#39;right&#39;&gt;&lt;select name=&#39;searchCondition&#39;&gt;
                            &lt;option value=&#39;TITLE&#39;&gt;제목
                            &lt;option value=&#39;CONTENT&#39;&gt;내용
                    &lt;/select&gt; 
                    &lt;input name=&#39;searchKeyword&#39; type=&#39;text&#39; /&gt; 
                    &lt;input type=&#39;submit&#39; value=&#39;검색&#39; /&gt;&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/form&gt;
        &lt;!-- 검색 종료 --&gt;
        &lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;
            &lt;tr&gt;
                &lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;번호&lt;/th&gt;
                &lt;th bgcolor=&#39;orange&#39; width=&#39;200&#39;&gt;제목&lt;/th&gt;
                &lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;작성자&lt;/th&gt;
                &lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;등록일&lt;/th&gt;
                &lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;조회수&lt;/th&gt;
            &lt;/tr&gt;

            &lt;% for(BoardVO board : boardList) &#123; %&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;%= board.getSeq() %&gt;&lt;/td&gt;
                &lt;td align=&#39;left&#39;&gt;&lt;a href=&#39;getBoard.jsp?seq=&lt;%= board.getSeq() %&gt;&#39;&gt;&lt;%= board.getTitle() %&gt;&lt;/a&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getWriter() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getRegDate() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getCnt() %&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;% &#125; %&gt;

        &lt;/table&gt;
        &lt;br&gt; &lt;a href=&#39;insertBoard.html&#39;&gt;새글 등록&lt;/a&gt;
    &lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>위의 코드는 크게 요청을 처리하는 자바코드와 요청에 대한 응답화면을 구성하는 아래쪽의 HTML코드로 이루어져 있습니다. 이를 MVC 패턴에 맞게 분리하면<br><img src="https://user-images.githubusercontent.com/50402288/100053891-4ee26800-2e64-11eb-9bf0-913f69d65b1a.png" alt="20201124144941"><br>이와같이 DispatcherServlet.java파일에 각각의 처리에 대한 분기처리로 Controller부분을 만들 수 있고 이부분에 getBoardList.jsp파일의 윗부분의 모든 자바코드가 들어갑니다. 그러면 남은건 getBoardList.java파일의 아래부분인데요 이부분이 HTML과 java코드가 섞여있는게 불만입니다. 그러면 그것을 처리해보겠습니다.</p>
<hr>
<pre><code>&lt;% for(BoardVO board : boardList) &#123; %&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;%= board.getSeq() %&gt;&lt;/td&gt;
                &lt;td align=&#39;left&#39;&gt;&lt;a href=&#39;getBoard.jsp?seq=&lt;%= board.getSeq() %&gt;&#39;&gt;&lt;%= board.getTitle() %&gt;&lt;/a&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getWriter() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getRegDate() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getCnt() %&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;% &#125; %&gt;</code></pre>
<p>   이부분이 대표적으로 위의 코드에서 HTML과 java코드가 섞인 부분입니다.<br>    el처리를 먼저 하면 session에 저장된 board정보를 자바코드를 쓰지 않고 처리할 수 있습니다<br>    &lt;%=board.getSeq() %&gt; -&gt; ${board.seq }와 같은식으로 처리할 수 있습니다.<br>    또한 jstl을 이용하면 if나 for문을 대체할 수 있습니다<br>    &lt;% for(BoardVO board : boardList) { %&gt; ~ &lt;% } %&gt; -&gt; &lt;c:forEach var=”board” items=’${boardList }’ &gt; ~ </c:forEach><br>    와 같이 표현될 수 있습니다. 이로써 MVC패턴과 jsp파일에 남아있던 java코드를 제거함으로써 깔끔하게 코드들을 분리시켜 낼 수 있습니다. 완성된 구조는 다음과 같습니다.<br>    <img src="https://user-images.githubusercontent.com/50402288/100054566-9e756380-2e65-11eb-8121-89c111f72db2.png" alt="20201124145902"><br>DAO, DO파일은 MVC패턴 중 M;Model에 해당하고 이는 데이터베이스와 연동됩니다. 이 때 클라이언트가 jsp파일(View)을 통해 request를 하면 request는 URI에 따라 DispatcherServlet(Controller)에서 if분기를 찾아 실행시킵니다. if분기에서 처리된 정보를 jsp파일에 건네주어 응답을 보냅니다. 아래는 DispatcherServlet의 분기 예시 입니다.</p>
<pre><code>// 2. 추출된 path에 따라 요청을 분기처리한다.
        if (path.equals(&quot;/login.do&quot;)) &#123;&#125;
        &#125; else if (path.equals(&quot;/logout.do&quot;)) &#123;&#125; 
        else if (path.equals(&quot;/insertBoard.do&quot;)) &#123;&#125;
         else if (path.equals(&quot;/deleteBoard.do&quot;)) &#123;&#125; 
         else if (path.equals(&quot;/getBoard.do&quot;)) &#123;&#125; 
         else if (path.equals(&quot;/getBoardList.do&quot;)) &#123;&#125;
         else if (path.equals(&quot;/updateBoard.do&quot;)) &#123;&#125; 
         else &#123;
            System.out.println(&quot;URL을 다시 확인해주시기 바랍니다.&quot;);
        &#125;</code></pre>
<hr>
<hr>
<ul>
<li>그외 알아둘 것들<ul>
<li>세션은 내장객체이다. 서블릿에서는 내장객체로서 작동하지 않아서 HttpSession객체를 쓸 때마다 정의해주어야 하지만(그렇다고 항상 새로생기는 것은 아니다. 세션정보가 있다면 있는 세션정보를 넘겨받아 사용한다.) jsp에선 바로 호출해서 쓸 수 있다. 내장객체이기 때문에!</li>
<li>model1 아키텍쳐: 자바로직을 html이랑 분리시킨다.</li>
<li>세션에 검색 목록 저장하면 안돼. 브라우저 끄기 전까지 살아있으니까. 그러니까 request에 저장해야돼. reqeust는 response 해주면 사라져 때문에 메모리를 많이 잡아먹지 않아. 그러면 세션엔? -&gt; 세션에는 id,권한 정도만 저장한다.</li>
<li>jsp에서 자바 코드를 분리해서 자바개발자는 controller만 관리하자가 목적이었어 -&gt; jsp가  el, jstl 을 사용하게 된 이유</li>
<li>request와 session에 동일한 정보가 저장되어있을 수 있어. 그 때 우선순위는 request에 저장된 정보야</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><h3 id="프레임웤이-도대체-뭐야"><a href="#프레임웤이-도대체-뭐야" class="headerlink" title="프레임웤이 도대체 뭐야?"></a>프레임웤이 도대체 뭐야?</h3><p><em>뼈대는 우리가 제공해줄게 니들은 살만붙여!</em></p>
<ul>
<li>Framework는 App을 개발할 때 아키텍쳐에 해당하는 골격 코드를 제공한다.</li>
<li>Solution이 완제품이라면 Framework는 반제품에 해당한다.</li>
<li>아무리 시간이 지나도 뼈대, 구조는 바뀌지 않는다.<h3 id="Framework의-장점"><a href="#Framework의-장점" class="headerlink" title="Framework의 장점"></a>Framework의 장점</h3></li>
<li>빠른 구현 시간</li>
<li>관리 용이성 증가</li>
<li>개발자의 역량 획일화</li>
<li>검증된 아키텍쳐의 재사용과 일관성 유지</li>
</ul>
<h3 id="Spring-Framework의-특징"><a href="#Spring-Framework의-특징" class="headerlink" title="Spring Framework의 특징"></a>Spring Framework의 특징</h3><ul>
<li>가볍다!(경량성): 스프링은 라이브러리 자체가 용량이 작아 왜?-&gt; POJO(Plain Old Java Object)로 이루어져 있거든<ul>
<li>POJO가 뭐야??:  예를들면 우리가 처음 작성해보는 helloworld.java같은 자바코드. 어떤것도 상속하지 않고 순수 자바코드로만 이루어져 있는 자바 클래스. 예를들면 우리전에만든 Servlet은 HttpServlet을 implement하잖아 그러면 규칙이 막 생겨, 서블릿클래스는 무조건 public형태여야 하고, override할 것도 생기고 서블릿 엔진이 막 나는 만들지도 않았는데 xml로딩해서 request만들고 response만들고 점점 무거워져 이렇게 작성 시에 규칙이 생기고 상속이 생기고 객체가 만들어지고 이런게 NOT POJO인 클래스들이고 POJO인 클래스는 아무런 제약, 규칙을 받지 않는 자바코드로서 상속받는게 없기 때문에 메모리사용량이 매우 적은 특징을 가져. 그리고 스프링은 POJO로 만들어 있기 때문에 가벼운거야!</li>
<li>커스터마이징 할 수 있다: 스프링은 오픈소스이고 오픈소스하면 가장 큰 장점은 무료인 것이라고 생각 하는 사람들이 많아. 맞는 말이지만 오픈소스의 가장 큰 장점은 무료인게 아니라 내가 임의로 커스터마이징 할 수 있다는 거야. 예를들면 Spring 3.0버전을 내입맛에 맞게 개량해서 나만의 MySpring 1.0으로 재탄생시켜도 문제가 없다는 거지!</li>
<li>그 외에도 AOP, IoC, 컨테이너라는 특징이 있는데 이건아직 안배웠어! 미안해!<br><img src="https://user-images.githubusercontent.com/50402288/100056147-7e936f00-2e68-11eb-8356-2c22ff02af6a.png" alt="image"></li>
</ul>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/50402288/100056199-97038980-2e68-11eb-9ad4-b4f0d3662b63.png" alt="20201124151917">  </p>
<p>이건 스프링을 배우기 전에 나한테 프레임워크의 개념을 잡는데 도움이 된 표야<br>Presentation: 즉 화면 개발을 담당하는 프레임워크인거야<br>Business: 비즈니스로직을 처리하는 프레임워크래<br>Persistence: DB연동을 처리하는 프레임워크고 크게 두 진영이 있어<br><img src="https://user-images.githubusercontent.com/50402288/100056324-d6ca7100-2e68-11eb-8051-661a56d4ef31.png" alt="image"></p>
<p>Hibernate&amp; JPA(청팀) vs. iBatis&amp;Mybatis(백팀)</p>
<p>청팀과 백팀은 가장 큰 차이점이 있어. 청팀은 ORM(Object Relation Mapping)프레임 워크인데 반해 백팀은 그렇지 않다는 거야. 무슨말이냐면 청팀은 프레임워크가 sql문을 자체적으로 생성해서 db연동까지 다해줘. 자동화라는 것이지. 하지만 백팀은 개발자가 직접 sql문을 써서 입력해줘야해. 유지보수측면에 봐도 자동화가 낫다고 생각해<br> 하지만 치명적인 청팀의 단점이 있대. 바로 어렵대. 그리고 백팀은 쉽대. 또 우리나라에선 백팀을 더 많이 쓴대…그렇대<br> 하지만 트랜드는 청팀!이래!</p>
<ul>
<li>그 외 알아둘 것들<ul>
<li>스프링은 컨테이너라는 것이 가장 중요한 개념이야! 컨테이너는 물건을 안전하게 저장하고 관리할 목적으로 사용해. 서블릿 엔진도 사실 컨테이너야. web.xml을 로딩해서 생성된 메소드를 보관하고 관리하는 역할을 하기 때문이지. 엔진=컨테이너라고 봐도 무방해!</li>
<li>서블릿 컨테이너 vs. 스프링 컨테이너<br>둘 사이에는 차이점이 한가지 있어. 전에 lazy-loading, pre-loading에 대해 배웠어. lazy-loading은 사용자가 요청하면 그 때 로딩해서 객체를 생성하지만 pre-loading은 무조건 xml에 등록된 클래스 객체들이 메모리에 할당되고 시작해. 다시말해서 서블릿컨테이너는 사용자가 요청을 하면 그 때 객체를 생성하기 때문에 lazy-loading이고 스프링 컨테이너는 무조건 객체들이 메모리에 올려지기 때문에 pre-loading이란 거야!</li>
<li>서블릿 컨테이너와 마찬가지로 스프링 컨테이너도 디폴트 생성자가 필요해. 우리 서블릿 배울 때 매개변수가 들어간 생성자를 만들고 디폴트 생성자를 정의 안해주면 서블릿 엔진이 해당 서블릿을 찾지 못하는 현상을 배운 적 있어. 스프링도 똑같애. 디폴트 생성자를 정의해 주지 않으면 안돼!</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/24/Spring/fastcampus/day_6/" data-id="ckhvlt7zx0008psv17si59dx0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVC/" rel="tag">MVC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/23/Spring/fastcampus/day_5/" class="article-date">
  <time datetime="2020-11-23T05:06:00.000Z" itemprop="datePublished">2020-11-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-5/">day_5</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/23/Spring/fastcampus/day_5/">day_5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/99928554-df4d7980-2d8c-11eb-8ad9-cd2bae5a96e3.png" alt="image"></p>
<p>one can never go back, that one should not ever try to go back – that the essence of life is going forward. Life is really a One Way Street. 되돌아가려 노력하지 않은 사람은 절대로 되돌아갈 수 없어요. 삶의 본질은 앞으로 나아가는 것이니까요. 삶은 정말 일방통행이에요. -Agatha Cristie</p>
<h1 id="JSPProject"><a href="#JSPProject" class="headerlink" title="JSPProject"></a>JSPProject</h1><ul>
<li>기존 서블릿의 단점을 보완한 기술입니다.</li>
<li><ul>
<li>기존 서블릿의 단점: 코드내에 HTML이 포함되어있어 작성시 매우 불편합니다. 때문에 코드가 길어지고 수정, 보완이 매우 어렵게됩니다. 이를 보완한 것이 JSP입니다.</li>
</ul>
</li>
<li>JSP: Java Server Page: 용어를 기억하는 것은 중요합니다.</li>
<li>정의: HTML 코드에 JAVA 코드를 넣어 동적웹페이지를 생성하는 웹어플리케이션 도구이다. -정의를 기억하는 것 또한 중ㅇ요합니다.</li>
</ul>
<hr>
<p>복습 요소:<br>필터에서 chain.doFilter를 만나면 다음 필터를 만나고 더이상 필터가 없으면 서블릿으로 갓다가 역순으로 다시 돌아온다 =&gt; 필터 체인</p>
<p>context=문맥=엔진</p>
<hr>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ul>
<li><p>세션; 웹 서버 쪽의 웹 컨테이너에 상태를 유지하기 위한 정보를 저장하는 장소.</p>
<ul>
<li>세션이 왜 중요한가?<br>우리는 앞서 로그인 페이지와 글 목록, 글 수정 삭제 등록 등 많은 기능을 구현해보았습니다. 하지만 한 가지 중요한 점을 놓쳤는데요, 바로 상태에 대한 저장이 없다는 것입니다. 가령 우리가 로그인 하지 않고 <code>http://localhost:7777/servletProject3/getBoardList.do</code><br>라는 URL을 치고 들어가면 우리는 로그인 절차 없이 글 목록을 볼 수 있습니다. 그렇기 때문에 로그인 되었는지, 누가 로그인을 하였는지에 대한 정보를 저장하고, 활용하기 위해 세션이 필요합니다.</li>
</ul>
</li>
<li><p>세션은 브라우저 하나당 하나씩만 유지됩니다. 재사용 할 때는 (만약 브라우저가 살아있다면) 우너래 세션의 주소만 리턴합니다. 즉 재사용 할 때마다 새로 생성하지 않습니다.</p>
<ul>
<li><p>세션의 메소드 중 중요한 것</p>
<ul>
<li><p>Object getAttribute(String name) : 이름에 해당하는 객체를 리턴한다.</p>
</li>
<li><p>void setAttribute(String name, Object value) : 객체를 Session에 저장한다.</p>
</li>
<li><p>void invalidate() : Session을 종료한다.</p>
</li>
<li><p>boolean  isNew() : Session이 처음 만들어진 것이면 true 를 리턴한다.</p>
</li>
<li><p>void removeAttribute(String name) : 주어진 이름에 해당하는 객체를 삭제한다.</p>
</li>
<li><p>void setMaxInactiveInterval(int seconds) : Session을 유지할 시간을 설정한다.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>jsp는 서비스메소드에 내가작성한 모든코드가 작성되기 때문에 get/post상관없이 작동한다.<br>톰켓 서버가 jsp를 서블릿으로 대신 작성해준다</p>
<h2 id="JSP-문법"><a href="#JSP-문법" class="headerlink" title="JSP 문법"></a>JSP 문법</h2><ul>
<li>Scriptlet: &lt;% %&gt;</li>
<li>Expression: &lt;%= %&gt;<br>두 가지의 차이점이 뭐냐, 첫번째는 정상적인 자바코드<br>두번째는 두가지가 온다. 변수, 메소드(void가 아닌, 뭔가를 리턴하는 메소드) 호출 두가지가 온다.</li>
<li>ctrl shit / :주석</li>
<li>&lt;!– –&gt;:html주석은 안쓴다(왜안쓰더라)</li>
<li>코드 끝에 ‘;’붙으면 정상적인 자바코드고 그러면 스크립틀릿을 써야해 익스프레션안돼</li>
</ul>
<hr>
<h2 id="JSPProject-구조-vs-ServletProject-구조"><a href="#JSPProject-구조-vs-ServletProject-구조" class="headerlink" title="JSPProject 구조 vs ServletProject 구조"></a>JSPProject 구조 vs ServletProject 구조</h2><p>아래는 JSP<br><img src="https://user-images.githubusercontent.com/50402288/99930089-2fc7d580-2d93-11eb-9984-e16a85a8a8ec.png" alt="20201123135231"><br>아래는 Servlet<br><img src="https://user-images.githubusercontent.com/50402288/99930155-656cbe80-2d93-11eb-90a8-11235fe7c067.png" alt="20201123135416"><br>둘 다 동일한 구조를 가지고 있으나 Servlet -&gt; JSP로 대체된 것을 볼 수 있습니다. 그러면 코드를 상세히 보면서 어느부분이 어떻게 대체가 되었는지 알아보겠습니다.</p>
<h2 id="주의-극단적인-비교를-위해-가장-긴-코드인-GetBoardListServlet-를-가져왔습니다"><a href="#주의-극단적인-비교를-위해-가장-긴-코드인-GetBoardListServlet-를-가져왔습니다" class="headerlink" title="*주의: 극단적인 비교를 위해 가장 긴 코드인 GetBoardListServlet 를 가져왔습니다."></a>*주의: 극단적인 비교를 위해 가장 긴 코드인 GetBoardListServlet 를 가져왔습니다.</h2><pre><code>public class GetBoardListServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;



    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //0. 세션 체크
        HttpSession session =request.getSession();
        UserVO user = (UserVO)session.getAttribute(&quot;user&quot;);
        if(user == null) &#123;
            response.sendRedirect(&quot;login.html&quot;);
        &#125; else &#123;
        //글 목록 화면을 요청한 브라우저와 매핑된 세션 객체를 얻어낸다.
//        HttpSession session = request.getSession();//request: 요청 프로토콜과 연결된 객체
//        if(session.isNew()) &#123;
//            System.out.println(&quot;===&gt; GetBoardListServlet 에서 처음 생성한 세션이다.&quot;);
//        &#125; else &#123;
//            System.out.println(&quot;---&gt; 이전에 생성된 세션 재사용하는 것이다.&quot;);
//        &#125;
        //1. 사용자 입력정보 추출(검색 기능은 숙제...)
//        request.setCharacterEncoding(&quot;EUC-KR&quot;);
        String searchCondition = request.getParameter(&quot;searchCondition&quot;);
        String searchKeyword = request.getParameter(&quot;searchKeyword&quot;);

        //null 체크를 해줘야해
        if(searchCondition == null) &#123;
            searchCondition = &quot;TITLE&quot;;
        &#125;
        if(searchKeyword == null)
            searchKeyword = &quot;&quot;;

        //2. DB연동 처리
        BoardVO vo = new BoardVO();
        vo.setSearchCondition(searchCondition);
        vo.setSearchKeyword(searchKeyword);

        BoardDAO boardDAO = new BoardDAO();
        List&lt;BoardVO&gt; boardList = boardDAO.getBoardList(vo);
        //3. 응답 화면 구성
        response.setContentType(&quot;text/html; charset=EUC-KR&quot;);
        PrintWriter out = response.getWriter();//출력 스트림
//        out.println(&quot;&lt;h1&gt;게시판 목록&lt;/h1&gt;&quot;);
//        for (BoardVO board : boardList) &#123;
//            out.println(&quot;---&gt;&quot; + board.toString() + &quot;&lt;br&gt;&quot;);
//        &#125; 아래와 같이 업그레이드 시킨다
        out.println(&quot;&lt;!DOCTYPE html PUBLIC &#39;-//W3C//DTD HTML 4.01 Transitional//EN&#39; &#39;http://www.w3.org/TR/html4/loose.dtd&#39;&gt;&quot;);
        out.println(&quot;&lt;html&gt;&quot;);
        out.println(&quot;&lt;head&gt;&quot;);
        out.println(&quot;&lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html; charset=EUC-KR&#39;&gt;&quot;);
        out.println(&quot;&lt;title&gt;글 목록&lt;/title&gt;&quot;);
        out.println(&quot;&lt;/head&gt;&quot;);
        out.println(&quot;&lt;body&gt;&quot;);
        out.println(&quot;&lt;center&gt;&quot;);
        out.println(&quot;&lt;h1&gt;게시글 목록&lt;/h1&gt;&quot;);
        out.println(&quot;&lt;h3&gt;&quot;+user.getName()+(&quot;userName&quot;)+&quot;님 로그인 환영합니다......&quot;);
        out.println(&quot;&lt;a href=&#39;logout.do&#39;&gt;Log-out&lt;/a&gt;&lt;/h3&gt;&quot;);

        out.println(&quot;&lt;!-- 검색 시작 --&gt;&quot;);
        out.println(&quot;&lt;form action=&#39;getBoardList.do&#39; method=&#39;post&#39;&gt;&quot;);//자기 자신을 한번더 호출
        out.println(&quot;&lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;&quot;);
        out.println(&quot;&lt;tr&gt;&quot;);
        out.println(&quot;&lt;td align=&#39;right&#39;&gt;&quot;);
        out.println(&quot;&lt;select name=&#39;searchCondition&#39;&gt;&quot;);
        out.println(&quot;&lt;option value=&#39;TITLE&#39;&gt;제목&quot;);
        out.println(&quot;&lt;option value=&#39;CONTENT&#39;&gt;내용&quot;);
        out.println(&quot;&lt;/select&gt;&quot;);
        out.println(&quot;&lt;input name=&#39;searchKeyword&#39; type=&#39;text&#39;/&gt;&quot;);
        out.println(&quot;&lt;input type=&#39;submit&#39; value=&#39;검색&#39;/&gt;&quot;);
        out.println(&quot;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;/tr&gt;&quot;);
        out.println(&quot;&lt;/table&gt;&quot;);
        out.println(&quot;&lt;/form&gt;&quot;);
        out.println(&quot;&lt;!-- 검색 종료 --&gt;&quot;);

        out.println(&quot;&lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;&quot;);
        out.println(&quot;&lt;tr&gt;&quot;);
        out.println(&quot;&lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;번호&lt;/th&gt;&quot;);
        out.println(&quot;&lt;th bgcolor=&#39;orange&#39; width=&#39;200&#39;&gt;제목&lt;/th&gt;&quot;);
        out.println(&quot;&lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;작성자&lt;/th&gt;&quot;);
        out.println(&quot;&lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;등록일&lt;/th&gt;&quot;);
        out.println(&quot;&lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;조회수&lt;/th&gt;&quot;);
        out.println(&quot;&lt;/tr&gt;&quot;);
for(BoardVO board : boardList) &#123;
        out.println(&quot;&lt;tr&gt;&quot;);
        out.println(&quot;&lt;td&gt;&quot;+board.getSeq()+&quot;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;td align=&#39;left&#39;&gt;&lt;a href=&#39;getBoard.do?seq=&quot;+board.getSeq()+&quot;&#39;&gt;&quot;+board.getTitle()+&quot;&lt;/a&gt;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;td&gt;&quot;+board.getWriter()+&quot;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;td&gt;&quot;+board.getRegDate()+&quot;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;td&gt;&quot;+board.getCnt()+&quot;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;/tr&gt;&quot;);
&#125;
        out.println(&quot;&lt;/table&gt;&quot;);
        out.println(&quot;&lt;br&gt;&quot;);
        out.println(&quot;&lt;a href=&#39;insertBoard.html&#39;&gt;새글 등록&lt;/a&gt;&quot;);
        out.println(&quot;&lt;/center&gt;&quot;);
        out.println(&quot;&lt;/body&gt;&quot;);
        out.println(&quot;&lt;/html&gt;&quot;);

        out.close();
    &#125;
    &#125;
&#125;</code></pre>
<p>보시다 시피 HTML코드가 매우 길어서 보기 좋지 않습니다. 또한 해당 코드는 차후 내용이 바뀌었을 때 수정이 매우 힙듭니다. 이를 JSP로 작성하면</p>
<pre><code> &lt;%
        String searchCondition = request.getParameter(&quot;searchCondition&quot;);
        String searchKeyword = request.getParameter(&quot;searchKeyword&quot;);

        if (searchCondition == null) &#123;
            searchCondition = &quot;TITLE&quot;;
        &#125;
        if (searchKeyword == null)
            searchKeyword = &quot;&quot;;

        BoardVO vo = new BoardVO();
        vo.setSearchCondition(searchCondition);
        vo.setSearchKeyword(searchKeyword);

        BoardDAO boardDAO = new BoardDAO();
        List&lt;BoardVO&gt; boardList = boardDAO.getBoardList(vo);
    %&gt;
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html; charset=EUC-KR&#39;&gt;
    &lt;title&gt;글 목록&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;center&gt;
            &lt;h1&gt;게시글 목록&lt;/h1&gt;
            &lt;h3&gt;
                관리자userName님 로그인 환영합니다...... &lt;a href=&#39;logout_proc.jsp&#39;&gt;Log-out&lt;/a&gt;
            &lt;/h3&gt;
            &lt;!-- 검색 시작 --&gt;
            &lt;form action=&#39;getBoardList.jsp&#39; method=&#39;post&#39;&gt;
                &lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;
                    &lt;tr&gt;
                        &lt;td align=&#39;right&#39;&gt;&lt;select name=&#39;searchCondition&#39;&gt;
                                &lt;option value=&#39;TITLE&#39;&gt;제목
                                &lt;option value=&#39;CONTENT&#39;&gt;내용
                        &lt;/select&gt; &lt;input name=&#39;searchKeyword&#39; type=&#39;text&#39; /&gt; &lt;input type=&#39;submit&#39;
                            value=&#39;검색&#39; /&gt;&lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/table&gt;
            &lt;/form&gt;
            &lt;!-- 검색 종료 --&gt;
            &lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;
                &lt;tr&gt;
                    &lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;번호&lt;/th&gt;
                    &lt;th bgcolor=&#39;orange&#39; width=&#39;200&#39;&gt;제목&lt;/th&gt;
                    &lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;작성자&lt;/th&gt;
                    &lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;등록일&lt;/th&gt;
                    &lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;조회수&lt;/th&gt;
                &lt;/tr&gt;
                &lt;% for(BoardVO board: boardList)  &#123;    %&gt;
                &lt;tr&gt;
                    &lt;td&gt;&lt;%=board.getSeq() %&gt;&lt;/td&gt;
                    &lt;td align=&#39;left&#39;&gt;&lt;%=board.getTitle() %&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;%=board.getWriter() %&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;%=board.getRegDate() %&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;%=board.getCnt() %&gt;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;%&#125; %&gt;
            &lt;/table&gt;
            &lt;br&gt; &lt;a href=&#39;insertBoard.html&#39;&gt;새글 등록&lt;/a&gt;
        &lt;/center&gt;
    &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<p>  와 같이 효율적으로 작성됨을 알 수 있습니다.<br>필터 왜 init, destory 오버라이딩 해야 한댓지?</p>
<ul>
<li></li>
</ul>
<p>상세, 수정, 삭제 마무리하기</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/23/Spring/fastcampus/day_5/" data-id="ckhvlt7zb0000psv15xa2ebwz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/20/Spring/fastcampus/day_4/" class="article-date">
  <time datetime="2020-11-20T05:06:16.000Z" itemprop="datePublished">2020-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-4/">day_4</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/20/Spring/fastcampus/day_4/">day_4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/99761730-2b54b000-2b3a-11eb-81e5-45220b5e1f9e.png" alt="image"><br>다른 사람의 코드와 비교하지말고 오직 어제의 나와 비교하라 - Jordan Peterson</p>
<h1 id="ServletProject"><a href="#ServletProject" class="headerlink" title="ServletProject"></a>ServletProject</h1><p>라 쓰고 토할것 같다고 읽습니다.</p>
<ul>
<li><h2 id="프로젝트-구조를-중심으로-리뷰합니다-당근-흔드는중"><a href="#프로젝트-구조를-중심으로-리뷰합니다-당근-흔드는중" class="headerlink" title="프로젝트 구조를 중심으로 리뷰합니다. (당근 흔드는중)"></a>프로젝트 구조를 중심으로 리뷰합니다. (당근 흔드는중)</h2><p><img src="https://user-images.githubusercontent.com/50402288/99777401-8f38a200-2b55-11eb-92ab-156a7ddfaefa.png" alt="20201120172622"></p>
<p>천천히 하나씩 한번 해보겠습니다.</p>
<ol>
<li>biz.board package:<br>BoardDAO와 BoardVO가 들어있습니다. 복습을 잠깐 해보자면 VO: Value Object로써 값들을 모아두고 getter/setter를 롬복으로 만들어 두어 수정, 삭제, 추가에 대비하여 유지보수하기 편하도록 만들어 놓은 값들의 모음입니다<br>DAO: data access object로써 insert, delete, update, get등의 메소드를 모아놓은 컨트롤러입니다.<br>즉 board테이블을 컨트롤하기위한 변수들과 그 변수들을 컨트롤 할 메소드를 모아놓은 패키지입니다.</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>biz.common package:<br>JDBCUtil 클래스가 들어있으며 h2데이터베이스와 커넥션을 연결/해제하는 메소드가 포함된 클래스입니다. board/users 테이블에서 자료를 추가, 수정, 삭제, 업데이트할 때 일일이 커넥션을 연결/해제하는 코드를 써 줄 수 없으니 해당 패키지에 미리 정의하여 두었습니다.</p>
</li>
<li><p>biz.user package:<br>앞서 1.에서 board테이블을 관리하는 용도와 같습니다.</p>
</li>
</ol>
<p>3.web.board:<br>board테이블과 관련된 서블릿들이 모여있는 패키지입니다.</p>
<p>4.web.common:<br>모든 서블릿에서 공통으로 쓰이는 Filter클래스를 가지고 있습니다.</p>
<p>5.web.user:<br>유저 테이블과 관련된 서블릿이 담겨있습니다.<br>이제 하나씩 보도록 합시다.</p>
<h2 id="주의-import와-패키지경로-자세한-코드내용은-저번-리뷰와-연관시-삭제했습니다-너무길거든요"><a href="#주의-import와-패키지경로-자세한-코드내용은-저번-리뷰와-연관시-삭제했습니다-너무길거든요" class="headerlink" title="주의:import와 패키지경로, 자세한 코드내용은 저번 리뷰와 연관시 삭제했습니다. 너무길거든요"></a>주의:import와 패키지경로, 자세한 코드내용은 저번 리뷰와 연관시 삭제했습니다. 너무길거든요</h2><h2 id="1-biz-board"><a href="#1-biz-board" class="headerlink" title="1. biz.board"></a>1. biz.board</h2><h3 id="boardVO-java"><a href="#boardVO-java" class="headerlink" title="boardVO.java"></a>boardVO.java</h3><pre><code>@Data
public class BoardVO &#123;
    private int seq;
    private String title;
    private String writer;
    private String content;
    private Date regDate;
    private int cnt;
    private String password;
&#125;</code></pre>
<h2 id="관련-변수들과-lombok으로-getter-setter가-모두-정의되어-있어-편리합니다"><a href="#관련-변수들과-lombok으로-getter-setter가-모두-정의되어-있어-편리합니다" class="headerlink" title="관련 변수들과 lombok으로 getter/setter가 모두 정의되어 있어 편리합니다."></a>관련 변수들과 lombok으로 getter/setter가 모두 정의되어 있어 편리합니다.</h2><h3 id="boardDAO-java"><a href="#boardDAO-java" class="headerlink" title="boardDAO.java"></a>boardDAO.java</h3><pre><code>    private static final String BOARD_INSERT = &quot;insert into board(seq, title, writer, content)&quot; + &quot;values((select nvl(max(seq), 0) +       &quot;
            + &quot;1 from board),?, ?, ?)&quot;;
    private static final String BOARD_UPDATE = &quot;UPDATE BOARD SET TITLE=?, CONTENT=? WHERE SEQ=?&quot;;
    private static final String BOARD_DELETE = &quot;DELETE BOARD WHERE SEQ=?&quot;;
    private static final String BOARD_GET = &quot;SELECT * FROM BOARD WHERE SEQ=?&quot;;
    private static final String BOARD_LIST = &quot;SELECT * FROM BOARD ORDER BY SEQ ASC&quot;;
    private static final String BOARD_UPDATE_CNT = &quot;UPDATE BOARD SET CNT=CNT+1 WHERE SEQ=?&quot;;

    //BOARD 테이블 관련 CRUD 기능의 메소드
    //글 등록
    public void insertBoard(BoardVO vo) &#123;
    &#125;
    //글 수정
    public void updateBoard(BoardVO vo) &#123;
    &#125;
    //글 삭제
    public void deleteBoard(BoardVO vo) &#123;
    &#125;
    //글 상세 조회
    public BoardVO getBoard(BoardVO vo) &#123;
    &#125;
    //글 목록 검색
    public List&lt;BoardVO&gt; getBoardList() &#123;
   &#125;</code></pre>
<p>board 테이블을 컨트롤 하는데 필요한 모든 메소드가 정의되어 있습니다.</p>
<hr>
<h2 id="2-biz-common"><a href="#2-biz-common" class="headerlink" title="2. biz.common"></a>2. biz.common</h2><h3 id="JDBCUtil-java"><a href="#JDBCUtil-java" class="headerlink" title="JDBCUtil.java"></a>JDBCUtil.java</h3><pre><code>    public class JDBCUtil &#123;
    public static Connection getConnection() &#123;
            // 1. 드라이버 객체를 메모리에 로딩한다.
            // 2. Connection 객체를 획득한다.
    // Select 기능의 자원 해제
    public static void close(ResultSet rs, PreparedStatement stmt, Connection conn) &#123;
    &#125;

    // not select 기능의 자원 해제
    public static void close(PreparedStatement stmt, Connection conn) &#123;
&#125;</code></pre>
<p>드라이버를 메모리에 로딩, 커넥션을 획득하고 rs이 있는 경우의 close, 없는 경우의 close메소드가 정의되어 있습니다.</p>
<hr>
<h2 id="3-biz-user"><a href="#3-biz-user" class="headerlink" title="3. biz.user"></a>3. biz.user</h2><h3 id="UserVO-java"><a href="#UserVO-java" class="headerlink" title="UserVO.java"></a>UserVO.java</h3><pre><code>@Data
public class UserVO &#123;
    private String id;
    private String password;
    private String name;
    private String role;
&#125;</code></pre>
<p>네 롬복이 캐리하구요</p>
<hr>
<h3 id="UserDAO-java"><a href="#UserDAO-java" class="headerlink" title="UserDAO.java"></a>UserDAO.java</h3><p>public class UserDAO {<br>    private Connection conn;<br>    private PreparedStatement stmt;<br>    private ResultSet rs;<br>    private static final String USER_INSERT = “insert into USERS values(?, ?, ?, ?)”;<br>    private static final String USER_GET = “SELECT * FROM USERS WHERE ID = ? and password = ?”;<br>    //회원 등록<br>    public void insertUsers(UserVO vo) {<br>    }<br>    //회원 상세조회<br>    public UserVO getUser(UserVO vo) {<br>    }<br>}<br>UserDAO는 insert, 상세조회 두가지의 메소드만 정의되어 있습니다.</p>
<hr>
<h2 id="4-web-Board"><a href="#4-web-Board" class="headerlink" title="4. web.Board"></a>4. web.Board</h2><h3 id="GetBoardListServer-java"><a href="#GetBoardListServer-java" class="headerlink" title="GetBoardListServer.java"></a>GetBoardListServer.java</h3><p>public class GetBoardListServlet extends HttpServlet {<br>    private static final long serialVersionUID = 1L;</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    BoardDAO boardDAO = new BoardDAO();
    List&lt;BoardVO&gt; list = boardDAO.getBoardList();

    response.setContentType(&quot;text/html; charset=EUC-KR&quot;);
    PrintWriter out = response.getWriter(); //출력 스트림

&lt;넘모 길어버리는 HTML코드는 이미지로 대체되는 마-법&gt;</code></pre>
<p><img src="https://user-images.githubusercontent.com/50402288/99780671-23a50380-2b5a-11eb-87bb-ad2e7a1e6ae7.png" alt="20201120175923"></p>
<pre><code>&#125;
&#125;</code></pre>
<h2 id="단순히-글-목록을-출력하는-코드입니다-딱히-볼-것은-없습니다"><a href="#단순히-글-목록을-출력하는-코드입니다-딱히-볼-것은-없습니다" class="headerlink" title="단순히 글 목록을 출력하는 코드입니다. 딱히 볼 것은 없습니다."></a>단순히 글 목록을 출력하는 코드입니다. 딱히 볼 것은 없습니다.</h2><h3 id="GetBoardServlet-java"><a href="#GetBoardServlet-java" class="headerlink" title="GetBoardServlet.java"></a>GetBoardServlet.java</h3><pre><code>public class GetBoardServlet extends HttpServlet &#123;
private static final long serialVersionUID = 1L;
private String encoding;

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    ServletContext context = getServletContext();
    encoding = context.getInitParameter(&quot;boardEncoding&quot;);

    //1.사용자 입력정보 추출
    response.setCharacterEncoding(encoding);
    //1. 사용자 입력정보 추출
    String seq = request.getParameter(&quot;seq&quot;);

    BoardVO vo = new BoardVO();
    vo.setSeq(Integer.parseInt(seq));

    BoardDAO dao = new BoardDAO();
    BoardVO board = dao.getBoard(vo);

    PrintWriter out = response.getWriter();</code></pre>
<p><img src="https://user-images.githubusercontent.com/50402288/99780015-3e2aad00-2b59-11eb-9293-ce943103ab9a.png" alt="20201120175256"></p>
<pre><code>&#125;
&#125;</code></pre>
<p>  seq의 정보를 넘겨받아서 해당 글의 상세정보를 출력하는 클래스입니다.</p>
<hr>
<h3 id="InsertBoardServlet-java"><a href="#InsertBoardServlet-java" class="headerlink" title="InsertBoardServlet.java"></a>InsertBoardServlet.java</h3><p>public class InsertBoardServlet extends HttpServlet {<br>    private static final long serialVersionUID = 1L;<br>    private String encoding;</p>
<pre><code>protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    //0. 글로벌 파라미터 정보 추출
    ServletContext context = getServletContext();
    encoding = context.getInitParameter(&quot;boardEncoding&quot;);

    //1.사용자 입력정보 추출
    request.setCharacterEncoding(encoding);
    BoardVO vo = new BoardVO();
    vo.setTitle(request.getParameter(&quot;title&quot;));
    vo.setWriter(request.getParameter(&quot;writer&quot;));
    vo.setContent(request.getParameter(&quot;content&quot;));

    BoardDAO dao = new BoardDAO();
    dao.insertBoard(vo);

    //3.화면 네비게이션
    response.sendRedirect(&quot;getBoardList.do&quot;);
&#125;</code></pre>
<p>}<br>String encoding은 인코딩 타입을 결정해 줄 것입니다. getServletContext() 메소드는 web.xml파일에접근하여 모든 서블릿에서 쓸 수 있는 파라미터 정보를 얻어와서 context변수에 저장합니다.<br>그래서 encoding 에 문자열 형태로 넣어주며 setCharacterEncoding함수에 파라미터로 넣어줌으로써 인코딩 형태를 결정합니다. 이것을 풀어쓰면 아래와 같습니다.</p>
<pre><code>response.setContentType(&quot;text/html; charset=EUC-KR&quot;);</code></pre>
<p>또한 이어지는 코드는  xml에 정의되어 있는 (서블릿에 대한)전역 파라미터의 형태입니다.</p>
<pre><code>&lt;context-param&gt;
    &lt;param-name&gt;boardEncoding&lt;/param-name&gt;
    &lt;param-value&gt;EUC-KR&lt;/param-value&gt;
  &lt;/context-param&gt;</code></pre>
<p>boardEncoding인 이름을 가지고 있으며 그 값은 EUC-KR입니다. 마치 key-value의 형태와 같습니다.<br><img src="https://user-images.githubusercontent.com/50402288/99780015-3e2aad00-2b59-11eb-9293-ce943103ab9a.png" alt="20201120175256"></p>
<p>이 화면에서 글 등록을 누르면 InsertBoardServlet이 호출되는데요 코드에서처럼, Title, Writer, Context정보를 받아서 DAO를 통해 값을 넣는 것을 알 수 있습니다. 마지막 화면 네이게이션에서는 insert를 마치고 나면 다시 글 목록으로 돌아가라는 명령을 내리고 있습니다.</p>
<hr>
<h3 id="DeleteBoardServlet-java"><a href="#DeleteBoardServlet-java" class="headerlink" title="DeleteBoardServlet.java"></a>DeleteBoardServlet.java</h3><pre><code>public class DeleteBoardServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //1.사용자 입력 정보 추출
        request.setCharacterEncoding(&quot;EUC-KR&quot;);
        String seq = request.getParameter(&quot;seq&quot;);
        //2.DB연동 처리
        BoardVO vo = new BoardVO();
        vo.setSeq(Integer.parseInt(seq));

        BoardDAO boardDAO = new BoardDAO();
        boardDAO.deleteBoard(vo);

        //3.화면 네비게이션
        response.sendRedirect(&quot;getBoardList.do&quot;);
    &#125;
&#125;</code></pre>
<p>seq정보를 넘겨받아 해당글을 삭제하고, 다시 글 목록으로 돌아가는 것을 알 수 있습니다.</p>
<h3 id="UpdateBoardServlet-java"><a href="#UpdateBoardServlet-java" class="headerlink" title="UpdateBoardServlet.java"></a>UpdateBoardServlet.java</h3><pre><code>public class UpdateBoardServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;
//    private String encoding;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //0. 글로벌 파라미터 정보 추출
//        ServletContext context = getServletContext();//부모로부터 상속된 메소드
//        encoding = context.getInitParameter(&quot;boardEncoding&quot;);//서블릿 컨텍스트는 글로벌 파라미터
//
//        //1.사용자 입력 정보 추출
//        request.setCharacterEncoding(encoding);
        String title = request.getParameter(&quot;title&quot;);
        String seq = request.getParameter(&quot;seq&quot;);
        String content = request.getParameter(&quot;content&quot;);
        //2.DB연동 처리
        BoardVO vo = new BoardVO();
        vo.setTitle(title);
        vo.setSeq(Integer.parseInt(seq));
        vo.setContent(content);

        BoardDAO boardDAO = new BoardDAO();
        boardDAO.updateBoard(vo);

        //3.화면 네비게이션
        response.sendRedirect(&quot;getBoardList.do&quot;);
    &#125;

&#125;</code></pre>
<p>앞의 방식의 반복인 것을 알 수있습니다. 글로벌 파라미터에서 인코딩 형태를 추출해서 적용하며, 사용자입력정보를 추출합니다. 추출된 정보를 vo에 넣어주고 vo를 dao를 통해 DB에 연동해서 updateBoard(); 메소드를 통해 업데이트 시켜준 뒤 다시 목록으로 돌아오는 것을 볼 수 있습니다.</p>
<h2 id="5-web-common"><a href="#5-web-common" class="headerlink" title="5. web.common"></a>5. web.common</h2><p> web.common 패키지에는 현재까지 배운 바로는 크게 두가지 형태의 파일이 옵니다. 첫 번째는 필터이고 두 번째는 서블릿 엔진 리스너입니다.</p>
<ul>
<li>필터: *.do 의 형태가 일반적이며 이 경우 모든 .do URI 를 가지고 있는 서블릿이 호출 되기 전에 먼저 호출되며 FilterChain으로 통해 다음 필터에게 주도권을(이거 뭐라고 대체할까) 넘긴다음 다음 필터가 없다면 서블릿을 실행시킨다.</li>
<li>서블릿 엔진 리스너: 서블릿 엔진을 다음으로 우선순위의 실행순서를 가지며, 서블릿 엔진이 실행된 이후 제일 먼저 실행되고 서블릿 엔진이 삭제 되기 전 제일 마지막으로 실행된다, <em>오늘 질문</em>: 그럼 위에 서블릿에서 따로 인코딩형식 왜지정해준거지? .do호출하기전에 필터에서 다 설정해주잖아?</li>
<li></li>
</ul>
<h3 id="CharacterEncodingFilter-java"><a href="#CharacterEncodingFilter-java" class="headerlink" title="CharacterEncodingFilter.java"></a>CharacterEncodingFilter.java</h3><p>브라우저 서버쪽에 get방식으로 요청할 것이 명확하다면 doGet()만 오버라이딩한다.<br>반대로 Post방식으로 요청할 것이 확신이 되면 doPost()만 오버라이딩한다.( service도 필요없다는 뜻)</p>
<p>do get판단 안되거나 상관없는 경우 service()만 오버라이딩한다<br>destroy는 서블릿 객체가 삭제되기 직전에 호출된다</p>
<p>서블릿 객체, 서블릿 메소드도 다 서블릿 엔진이 호출해준다.<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>        System.out.println(“===&gt; doPostd() 호출”);<br>    }<br>     req 객체와 rep객체가 있어야 제대로 작동하지 않는가? -&gt; 매게변수 또한 서블릿 엔진이 생성해서 준다.<br>     브라우저가 서버에 전달한 요청 프로토콜 온갖 정보들을 req객체에 담아서 넘겨준다. req.getParameter(“id”)하면 아이디나옴, 즉 요청 프로토콜을 받아서 req을 생성한다.<br>     response 중에서는<br>     setContentType, getWriter, sendRedirect만 알면 된다<br>     setContent : 한글이 있을 경우 인코딩 지정해줌<br>     getWriter : 는 응답 프로토콜 body와 연관된 출력 스트림이다.<br>     sendRedirect: 다시 페이지 요청<br>서블릿은 안에 html이 포함되고 html로 디자인까지 다바꾸려면 지옥이다 때문에 jsp가 나왔다.<br>이 게시판 만드는데 필요한 기술은 sql, jdbc, html, servlet<br>req.getSession()무지 중요</p>
<p>서블릿은 브라우저가 요청할때 생성 -&gt;lazy-loading<br>Filter는 pre-Loading 요청이 필요없어 서블릿 엔진이 web.xml을 읽자 마자 생성되는 거야.<br>실제 ~.do서블릿이 없어도 필터는 동작해(*.do)<br>init과 destroy  는 오버라이딩은 해놔야해 서블릿과 달라 서블릿은 부모가 클래스라서 오버라이딩 할지 안할지 자유지만<br>필터는 달라 강제야 왜 ? (doFilter까지 합쳐서) dofilter가 제일 중요해 모든 .do에서 doFilter가 주구장창 실행되니까 젤중요해</p>
<p>필터가 중간에 .do요청을 가로채 그래서 사전처리 하고 chain,doFilter(req, res)(이 req, res를 doget으로 줌)호출되면 그 순간 클라이언트가 호출한 서블릿의 메소드가 실행되고(doGet)그러고 나면 제어권을 다시 필터로 돌아오고 사후처리 로직이 동작한다. 그 응답이 필터에서 브라우저로 들어간다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/20/Spring/fastcampus/day_4/" data-id="ckhu1z0e70000n8v105hfcuto" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/19/Spring/fastcampus/day_3/" class="article-date">
  <time datetime="2020-11-19T03:08:11.000Z" itemprop="datePublished">2020-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-3/">day_3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/19/Spring/fastcampus/day_3/">day_3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/99616265-405d1080-2a60-11eb-9812-a4cf24f50e5b.png" alt="image"></p>
<p>코드를 쓰기 전 당신 자신에게 다음과 같은 질문을 해보라. 즉 나는 이 서버가  늙어서도 여전히 유지보수를 잘 할 수 있을까? - Nietzsche</p>
<hr>
<h2 id="톰켓과-서블릿엔진"><a href="#톰켓과-서블릿엔진" class="headerlink" title="톰켓과 서블릿엔진"></a>톰켓과 서블릿엔진</h2><p>톰켓 서버 실행하면 new Tomcat() 객체가 생성이 되는거다<br>new Tomcat()은 new ServletEngin(web.xml)객체를 생성하는 코드를 가지고 있다</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>HTTP: Hyper Text Transfer Protocol) = 웹 서버와 웹 클라이언트(Browser)간에 통신하기 위한 프로토콜(통신 규약)이다.</li>
<li>HTTP 구조: 1. Start-line, 2. Message-header, 3. Message-body</li>
</ul>
<h3 id="브라우저의-요청-프로토콜"><a href="#브라우저의-요청-프로토콜" class="headerlink" title="브라우저의 요청 프로토콜"></a>브라우저의 요청 프로토콜</h3><p><img src="https://user-images.githubusercontent.com/50402288/99617535-e01b9e00-2a62-11eb-88b4-07a14e242672.png" alt="20201119122912"></p>
<ul>
<li>브라우저는 링크, 버튼, URL을 통해 서버에 요청 프로토콜을 보낸다.</li>
</ul>
<p>1.스타트 라인은 세가지 데이터로 구성이 된다. 첫번째는 요청방식(Get/ Post), 두 번째는 URI(포트번호 기준으로 그 뒤, ?표 전까지), 마지막 세 번째는 http프로토콜 버전인데 이것은 중요하지 않다.<br>2.메시지 헤더는 브라우저마다 다르다. 때문에 이것 역시 중요하지 않다.<br>3.메시지 바디는 사용자가 입력한 값이 딸려온다.(요청방식이 post)일 때만</p>
<h3 id="서버의-응답-프로토콜"><a href="#서버의-응답-프로토콜" class="headerlink" title="서버의 응답 프로토콜"></a>서버의 응답 프로토콜</h3><p><img src="https://user-images.githubusercontent.com/50402288/99617682-28d35700-2a63-11eb-9934-6471e4dc7a1d.png" alt="20201119123122"></p>
<ul>
<li>서버는 응답 프로토콜을 만든다.</li>
</ul>
<ol>
<li><p>스타트 라인: http버전, 응답 상태코드(404, 405, 500), 응답 상태코드에 딸려가는 메시지(ex: ‘OK’)</p>
<ul>
<li><p>404: (톰캣 관할) 브라우저가 서버에 요청한 파일이 서버에 존재하지 않음(프로젝트안에 해당 파일이 없음), (서블릿 엔진 관할) 서블릿 엔진이 xml에 등록되지 않은 URI를 참조할 때. 아래 사진참고</p>
<pre><code>*  </code></pre>
<p><img src="https://user-images.githubusercontent.com/50402288/99617956-c29b0400-2a63-11eb-94bc-27c4c7b0cb58.png" alt="20201119123537"><br>URI패턴에 hello.do가 매핑되어 있다. 즉 웹페이지 주소에 해당 URI로 접속하면 hello.HelloServlet이 실행된다. 그런데 login.do나 연관없는 URI로 들어가면 서블릿엔진이 주소를 찾지 못하고 404를 출력한다.</p>
<ul>
<li>405: 요청방식을 서버가 지원하지 않을 때(ex: 아래 사진의 doPost가 정의되어 있지 않거나, doGet이 정의되어 있지 않거나)<ul>
<li><img src="https://user-images.githubusercontent.com/50402288/99618320-77cdbc00-2a64-11eb-935f-9b583868a477.png" alt="20201119124043"></li>
</ul>
</li>
</ul>
</li>
<li><p>500: internal server error 오류 (서버오류 like Arithmetic Exception)</p>
<ol start="2">
<li>메시지 헤더는 역시 여기서도 중요하지 않다.</li>
<li>메시지 바디: 브라우저가 요청한 문서가(html, img, etc…) 응답 프로토콜 바디쪽에 담겨서 전달된다.</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="서블릿의-특징"><a href="#서블릿의-특징" class="headerlink" title="서블릿의 특징"></a>서블릿의 특징</h2><ul>
<li>서블릿은 자바 클래스이다. 다만 서블릿 엔진에 의해서만 동작한다.(동작한다: 객체를 생성하고 실행한다.)</li>
<li>자바클래스 이기 때문에 플랫폼 독립성(Linux, Windows, Mac,,,), 서버 독립성(Zeus, Tomcat,,,)이다. 이 두가지를 이식성이라 하며 이식성이 매우 높을수록 좋은것이고 자바클래스이기 때문에 이식성이 매우 좋다.</li>
<li>확장성: 서블릿은 자바로 작성되기 때문에 다양한 벤더(회사)에서 제공하는 클래스 라이브러리를 이용할 수 있다.</li>
<li>멀티스레드: 서블릿은 멀티스레드로 동작하기 때문에 매우 효율적이다. 하지만 서블릿을 멀티스레드로 돌리는 것은 서블릿 엔진이기 때문에 개발자는 멀티스레드에 대해 관여하지 않아도 된다.</li>
<li>아무리 전세계에서 많은 요청프로토콜을 보내도 서블릿 엔진은 JVM 메모리(힙 영역) 에 서블릿객체를 하나만 생성한다. 서블릿 요청시 서블릿이 메모리에 없다면 서블릿을 메모리에 로딩한다. 아래 참고자료</li>
</ul>
<p>서블릿 특징: 서블릿은 자바 클래스다, 다만 서블릿 엔진에 의해서만 동작한다.(객체생성되고 실행된다)<br>자바클래스이기 때문에-플랫폼 독립성, 서버독립성이다. 이 두가지를 이식성이라 한다.<br>확장성- 서블릿은 자바로 작성되기 때문에 다양한 벤더(회사)에서 제공하는 클래스 라이브러리를 이용할 수 있다.<br>중요! 멀티스레드이다. 서블릿을 멀티쓰레드로 돌리는건 서블릿 엔진이기 때문에 개발자는 신경 안써도 된다.<br>서블릿 엔진은 web.xml을 로딩하면 thread pool을 생성한다(vector같은, ArrayList같은 쓰레드 객체 여러개가 저장되는 공간)<br>아무리 전세계에서 요청해도 서블릿 엔진은 메모리에 서블릿을 하나만 생성한다.<br>요청 서블릿이 메모리에 없다면 메모리에 서블릿을 로딩한다<br><img src="https://user-images.githubusercontent.com/50402288/99618908-a7c98f00-2a65-11eb-8b7f-156734f3d419.png" alt="20201119124916"></p>
<ul>
<li><p>처음에 클라이언트가 서블릿 엔진에 요청 프로토콜을 처리할 서블릿이 존재하는지 Servlet Request를 한다. 이 때 서블릿 엔진엔진이 가상메모리 위에 서블릿 객체가 로딩되어있는지 판단 후 로딩되어있지 않다면 서블릿 객체를 생성하고, 생성자를 생성하고, init()으로 생성자를 초기화 한후 쓰레드 풀에서 스레드를 할당해 service()를 호출 한다. 이때 서비스 메소드는 내부에 클라이언트의 요청방식이 Get 이었는지 Post였는지 분기를 통해 판단하고 그에 맞게 doGet()또는 doPost()를 실행한다.<br>이 때 두번째 클라이언트가 들어온다면 init()까지의 과정은 생략한다. 때문에 서버를 구동하기 전 한번 서블릿 객체를 로딩시켜 놔야 빠르다.</p>
<h2 id="서블릿-클래스-작성-규칙"><a href="#서블릿-클래스-작성-규칙" class="headerlink" title="서블릿 클래스 작성 규칙"></a>서블릿 클래스 작성 규칙</h2><h3 id="서블릿-클래스-작성-규칙-1"><a href="#서블릿-클래스-작성-규칙-1" class="headerlink" title="서블릿 클래스 작성 규칙"></a>서블릿 클래스 작성 규칙</h3><ol>
<li><p>HttpServlet 클래스를 상속해야 한다. 그래야 서블릿 클래스라고 인식할 수 있다(서블릿 엔진이 인식하고 이 클래스를 메모리에 생성한다)</p>
</li>
<li><p>public 클래스로 만들어야 한다. 서블릿 엔진이 접근할 수 있기 위해</p>
</li>
<li><p>default 생성자가 있어야 한다.</p>
</li>
<li><p>요청 방식(method) 에 따라 goGet이나 doPost를 재정의(Overriding)한다.</p>
</li>
<li><p>부모 HttpServlet 클래스의 메소드를 재정의 하지 않으면 상속된다.</p>
</li>
<li><p>중요한 것은 이클립스가 알아서 해준다.</p>
<ul>
<li><p>나는 서블릿클래스를 정의만 했지 HelloServleet bean = new HelloServlet 와 같이 객체 생성을 한 적이 없고 심지어</p>
</li>
<li><p>bean.doGet()메소드 호출한 적도 없지만 알아서 된다 -&gt; servlet엔진이 알아서 다해줘요@</p>
</li>
<li><p>서블릿 엔진은 실행될 때 web.xml을 파라미터로 받아온다.</p>
</li>
<li><p>톰캣은 자바로 구현이 되어있다. 톰캣을 실행하면 톰캣 클래스 객체가 생성이 되고 web.xml파일을 읽어서 서블릿 엔진이라는 객체가 생성이 되며 이 때 xml에 명시한 대로 서블릿 엔진이 서블릿 객체를 생성하고 실행까지 해준다.</p>
<p>public class HelloServlet extends HttpServlet {<br>private static final long serialVersionUID = 1L;</p>
<p>public HelloServlet() {</p>
<pre><code>System.out.println(&quot;===&gt; HelloServlet 객체 생성&quot;);</code></pre>
<p>}//hello.do페이지 들어오면(xml에 명시한 대로) HelloServlet을 실행한다.</p>
<p>public void init(ServletConfig config) throws ServletException {</p>
<pre><code>System.out.println(&quot;===&gt; init() 호출&quot;);</code></pre>
<p>}</p>
<p>protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {</p>
<pre><code>System.out.println(&quot;===&gt; service() 호출&quot;);</code></pre>
<p>}</p>
<p>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</p>
<pre><code>System.out.println(&quot;===&gt; doGet() 호출&quot;);</code></pre>
<p>}</p>
<p>protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</p>
<pre><code>System.out.println(&quot;===&gt; doPost() 호출&quot;);</code></pre>
<p>}</p>
<p>public void destroy() {</p>
<pre><code>System.out.println(&quot;===&gt; destroy() 호출&quot;);</code></pre>
<p>}<br>}</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li>서블릿 호출에는 두가지 방법이 있다. 링크, 버튼, URI 입력 시마다 서블릿을 새로 호출 또는 서블릿 객체를 계속 실행시켜놓고 작업이 변경될 때 마다 호출<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/50402288/99620049-07289e80-2a68-11eb-857a-2d87ab342982.png" alt="20201119130609"><br>위의 로그인 페이지에서 우리가 신경써야 할 부분은 </p>
<pre><code> &lt;form action=&quot;hello.do&quot; method=&quot;get&quot;&gt;</code></pre>
<p>기존의 <a target="_blank" rel="noopener" href="http://localhost:7777/httpProject/login.html">http://localhost:7777/httpProject/login.html</a> 에서<br>     로그인 버튼을 누르면 form 태그의 action에 명시한 대로<br>     <a target="_blank" rel="noopener" href="http://localhost:7777/httpProject/hello.do?id=&amp;password=">http://localhost:7777/httpProject/hello.do?id=&amp;password=</a><br>     즉 hello.do라는 URI가 추가 된 것을 볼 수 있고 ? 뒤에 내가 입력한 id와 passwor의 정보가 담겨있다는 것은 이것이 get방식이라는 것을 알려준다. 이 때 터미널에서는 무슨 일이 일어나는 지 보자.</p>
<p>public class HelloServlet extends HttpServlet {<br>    private static final long serialVersionUID = 1L;</p>
<pre><code>public HelloServlet() &#123;
    System.out.println(&quot;===&gt; HelloServlet 객체 생성&quot;);
&#125;

public void init(ServletConfig config) throws ServletException &#123;
    System.out.println(&quot;===&gt; init() 호출&quot;);
&#125;

protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    System.out.println(&quot;===&gt; service() 호출&quot;);
&#125;

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    System.out.println(&quot;===&gt; doGet() 호출&quot;);
&#125;


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    System.out.println(&quot;===&gt; doPost() 호출&quot;);
&#125;

public void destroy() &#123;
    System.out.println(&quot;===&gt; destroy() 호출&quot;);
&#125;
&#125;</code></pre>
<hr>
<pre><code>정보: 서비스 [Catalina]을(를) 시작합니다.
11월 19, 2020 1:00:36 오후 org.apache.catalina.core.StandardEngine startInternal
정보: 서버 엔진을 시작합니다: [Apache Tomcat/9.0.37]
11월 19, 2020 1:00:36 오후 org.apache.coyote.AbstractProtocol start
정보: 프로토콜 핸들러 [&quot;http-nio-7777&quot;]을(를) 시작합니다.
11월 19, 2020 1:00:36 오후 org.apache.catalina.startup.Catalina start
정보: 서버가 [244] 밀리초 내에 시작되었습니다.
===&gt; HelloServlet 객체 생성
===&gt; init() 호출
===&gt; service() 호출
===&gt; service() 호출
===&gt; service() 호출
===&gt; service() 호출</code></pre>
<ol>
<li>정보: 서비스 [Catalina]을(를) 시작합니다. : 톰캣이 구동되었다는 것을 알 수 있다.</li>
<li>정보: 서버 엔진을 시작합니다 : 톰캣은 서버엔진을 실행하는 코드를 갖고 있기에 톰캣이 서버엔진을 실행시켰다.</li>
<li>===&gt; HelloServlet 객체 생성: 서버엔진은 실행될 때 web.xml파일을 파라미터로 받는다. 이를 통해 해당 URI로 접속하면 서블릿 객체를 생성한다.</li>
<li>===&gt; init() 호출: 원칙적으로 서블릿 생성자는 파라미터를 받을 수 없다. 그래야만 서블릿 엔진이 서블릿 생성자를 인식할 수 있기 때문이다. 때문에 init()이라는 메소드를 통해 생성자를 초기화 시켜준다.</li>
<li>===&gt; service() 호출: 원래는 service()에서 doGet()을 호출할지 doPost()를 호출할지 분기한다. 하지만 위의 코드에서는 우리가 임의로 service()의 코드를 오버라이딩하였기 때문에 doGet()이나 doPost()가 호출되지 않는다.</li>
<li>이 때 HelloServlet.java의 파일을 수정해보자.</li>
</ol>
<pre><code>  .    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
            System.out.println(&quot;===&gt; service() 호출&quot;);
        &#125;</code></pre>
<p>해당 메소드를 지워보면 터미널에</p>
<pre><code>11월 19, 2020 1:26:28 오후 org.apache.catalina.core.StandardContext    reload
정보: 이름이 [/httpProject]인 컨텍스트를 다시 로드하는 작업이 시작되었습니다.
===&gt; destroy() 호출
이러한 메시지가 뜬다. 즉 코드가 수정되면 라이프사이클이 끝나 destory()를 호출하여 서블릿 객체를 메모리상에서 지우고 다시 새로운 서블릿 객체를 만든다는 것을 알 수 있다. 또는 서버가 종료되면 destroy()메소드를 호출한다.</code></pre>
<h3 id="헷갈리는-서블릿-개념-때려잡기"><a href="#헷갈리는-서블릿-개념-때려잡기" class="headerlink" title="헷갈리는 서블릿 개념 때려잡기"></a>헷갈리는 서블릿 개념 때려잡기</h3><p> 서블릿 객체는 서버가 실행되면 단 하나 실행되어 서버가 종료되거나 코드가 변경되어 업데이트 시키기 전까지(서블릿을 새로 생성하기 전까지) 생존한다. 이 서블릿객체 하나에서 멀티쓰레드로 쓰레드풀에서 쓰레드를 하나씩 가져와서 클라이언트의 요청을 처리한다. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/19/Spring/fastcampus/day_3/" data-id="ckhocdjsk0000psv1a4vm73uz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/18/Spring/fastcampus/day_2/" class="article-date">
  <time datetime="2020-11-18T06:35:24.000Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-2/">day_2</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/18/Spring/fastcampus/day_2/">day_2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/99493926-77c1b380-29b3-11eb-8355-7ee6b9e55252.png" alt="image"></p>
<p>나의 자바의 한계는 나의 세계의 한계를 뜻한다. -Wittgenstein</p>
<h1 id="이클립스-다이나믹-웹-프로젝트"><a href="#이클립스-다이나믹-웹-프로젝트" class="headerlink" title="이클립스 다이나믹 웹 프로젝트"></a>이클립스 다이나믹 웹 프로젝트</h1><ul>
<li>DAO: Data Access Object</li>
<li>VO: Value Object</li>
<li>H2: 데이터 베이스 </li>
<li>Lombok: Getter/Setter 자동  생성라이브러리</li>
</ul>
<hr>
<h2 id="BoardVO-java"><a href="#BoardVO-java" class="headerlink" title="BoardVO.java"></a>BoardVO.java</h2><pre><code>@Data
public class BoardVO &#123;//Value Object 의 값들로는 순서, 타이틀, 작성자, 내용, 날짜, 조회수, 패스워드
private int seq;
private String title;
private String writer;
private String content;
private Date regDate;
private int cnt;
private String password;
&#125;</code></pre>
<hr>
<ul>
<li>Lombok을 이용한 Value Object 관리 실제로 각 필드 변수의 Getter/Setter가 모두 형성되어 있고, 변수 이름이 바뀌거나 추가되어도 자동으로 세팅되어 매우 편하다.<br><img src="https://user-images.githubusercontent.com/50402288/99500401-aba1d680-29bd-11eb-93f3-851b4485589e.png" alt="20201118164646"></li>
</ul>
<hr>
<h2 id="BoardDAO-java"><a href="#BoardDAO-java" class="headerlink" title="BoardDAO.java"></a>BoardDAO.java</h2><pre><code>    public class BoardDAO &#123;// Data access object

    private Connection conn;
    private PreparedStatement stmt;
    private ResultSet rs;
    private PreparedStatement stmt2;

    private static final String BOARD_INSERT = &quot;INSERT INTO BOARD(seq, title, writer, content)&quot;
            + &quot;values((select nvl(max(seq),0) + 1 from board), ?, ?, ?)&quot;;
    private static final String BOARD_LIST = &quot;Select * from board order by seq DESC&quot;;
    private static final String BOARD_UPDATE = &quot;update board set title = ?, content = ? where seq = ?&quot;;
    private static final String BOARD_GET = &quot;select * from board where seq = ?&quot;;
    private static final String BOARD_DELETE = &quot;delete board where seq = ?&quot;;
    private static final String BOARD_INCREASE = &quot;UPDATE BOARD SET CNT=CNT+1 WHERE SEQ=?&quot;;

    public void insertBoard(BoardVO vo) &#123; //vo객체를 받아서 데이터베이스에 추가
        try &#123;
            conn = JDBCUtil.getConnection();
            stmt = conn.prepareStatement(BOARD_INSERT);

            stmt.setString(1, vo.getTitle());
            stmt.setString(2, vo.getWriter());
            stmt.setString(3, vo.getContent());

            stmt.executeUpdate();
        &#125; catch (SQLException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtil.close(stmt, conn);
        &#125;

    &#125;

    public void deleteBoard(BoardVO vo) &#123; //vo 객체를 받아서 데이터 베이스 삭제
        try &#123;
            conn = JDBCUtil.getConnection();
            stmt = conn.prepareStatement(BOARD_DELETE);
            // 물음표에 값을 넣어줘야지
            stmt.setInt(1, vo.getSeq());

            stmt.executeUpdate();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtil.close(stmt, conn);
        &#125;

    &#125;

    public void updateBoard(BoardVO vo) &#123; //업데이트
        try &#123;
            conn = JDBCUtil.getConnection();
            stmt = conn.prepareStatement(BOARD_UPDATE);
            // 물음표에 값을 넣어줘야지
            stmt.setString(1, vo.getTitle());
            stmt.setString(2, vo.getContent());
            stmt.setInt(3, vo.getSeq());

            stmt.executeUpdate();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtil.close(stmt, conn);
        &#125;

    &#125;

    public List&lt;BoardVO&gt; getBoardList() &#123; //전체조회
        List&lt;BoardVO&gt; boardList = new ArrayList&lt;BoardVO&gt;();
        try &#123;
            conn = JDBCUtil.getConnection();
            stmt = conn.prepareStatement(BOARD_LIST);
            rs = stmt.executeQuery();
            while (rs.next()) &#123;
                BoardVO board = new BoardVO();
                board.setSeq(rs.getInt(&quot;SEQ&quot;));
                board.setTitle(rs.getString(&quot;TITLE&quot;));
                board.setWriter(rs.getString(&quot;WRITER&quot;));
                board.setContent(rs.getString(&quot;CONTENT&quot;));
                board.setRegDate(rs.getDate(&quot;REGDATE&quot;));
                board.setCnt(rs.getInt(&quot;CNT&quot;));
                boardList.add(board);
                System.out.println(rs.getInt(&quot;SEQ&quot;) + &quot; : &quot; + rs.getString(&quot;CONTENT&quot;));
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtil.close(rs, stmt, conn);
        &#125;
        return boardList;

    &#125;

    public BoardVO getBoard(BoardVO vo) &#123; //특정 조회
        BoardVO board = null;
        try &#123;
            conn = JDBCUtil.getConnection();
            stmt = conn.prepareStatement(BOARD_GET);
            stmt2 = conn.prepareStatement(BOARD_INCREASE);

            stmt2.setInt(1, vo.getSeq());
            stmt.setInt(1, vo.getSeq());

            stmt2.executeUpdate();
            rs = stmt.executeQuery();
            if (rs.next()) &#123;
                board = new BoardVO();
                board.setSeq(rs.getInt(&quot;SEQ&quot;));
                board.setTitle(rs.getString(&quot;TITLE&quot;));
                board.setWriter(rs.getString(&quot;WRITER&quot;));
                board.setContent(rs.getString(&quot;CONTENT&quot;));
                board.setRegDate(rs.getDate(&quot;REGDATE&quot;));
                board.setCnt(rs.getInt(&quot;CNT&quot;));
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtil.close(rs, stmt, conn);
            JDBCUtil.close(stmt2, conn);
        &#125;
        return board;
    &#125;
&#125;</code></pre>
<hr>
<h2 id="InsertBoardTest-java"><a href="#InsertBoardTest-java" class="headerlink" title="InsertBoardTest.java"></a>InsertBoardTest.java</h2><pre><code>public class InsertBoardTest &#123;//insert 는 title, writer랑 content정보가 필요해
    public static void main(String[] args) &#123;
        //data access object 와 data value를 선언해준다
        BoardDAO boardDAO = new BoardDAO();
        BoardVO vo = new BoardVO();
        vo.setTitle(&quot;타이틀&quot;);
        vo.setWriter(&quot;테스텉&quot;);
        vo.setContent(&quot;VO 내용...&quot;);

        boardDAO.insertBoard(vo);; //boardDAO로 insertObject명령어를 실행시키고 뭘 담아가서 실행시켜? -&gt; vo를 담아가서 실행시켜
        boardDAO.getBoardList(); // 마지막에 출력해주면 되지.

    &#125;
&#125;</code></pre>
<hr>
<h2 id="DeleteBoardTest-java"><a href="#DeleteBoardTest-java" class="headerlink" title="DeleteBoardTest.java"></a>DeleteBoardTest.java</h2><pre><code>public class DeleteBoardTest &#123;
public static void main(String[] args) &#123;
    BoardDAO boardDAO = new BoardDAO();
    BoardVO vo = new BoardVO();

    vo.setSeq(3);
    boardDAO.deleteBoard(vo);
    boardDAO.getBoardList();
&#125;
&#125;</code></pre>
<hr>
<h2 id="UpdateBoardTest-java"><a href="#UpdateBoardTest-java" class="headerlink" title="UpdateBoardTest.java"></a>UpdateBoardTest.java</h2><pre><code>public class UpdateBoardTest &#123;//업데이트에는 seq, title, content가 필요해
//data access object, Value object
public static void main(String[] args) &#123;
    BoardDAO boardDAO = new BoardDAO();
    BoardVO vo = new BoardVO();
    vo.setSeq(4);
    vo.setTitle(&quot;새로운 타이틀&quot;);
    vo.setContent(&quot;새로운 컨텐트&quot;);

    boardDAO.updateBoard(vo);
    BoardVO board = boardDAO.getBoard(vo);
    System.out.println(board.getSeq() + &quot;번 게시 글의 상세 정보&quot;);
    System.out.println(&quot;제목 : &quot; + board.getTitle());
    System.out.println(&quot;작성자 : &quot; + board.getWriter());
    System.out.println(&quot;내용 : &quot; + board.getContent());
    System.out.println(&quot;등록일 : &quot; + board.getRegDate());
    System.out.println(&quot;조회수 : &quot; + board.getCnt());

&#125;
&#125;</code></pre>
<hr>
<h2 id="GetBoardList-java"><a href="#GetBoardList-java" class="headerlink" title="GetBoardList.java"></a>GetBoardList.java</h2><pre><code>public class GetBoardList &#123;
public static void main(String[] args) &#123;
    BoardDAO boardDAO = new BoardDAO();
    BoardVO vo = new BoardVO();

    List&lt;BoardVO&gt; list = new ArrayList&lt;BoardVO&gt;();
    list = boardDAO.getBoardList();
    for (BoardVO board : list) &#123;
        System.out.print(&quot;제목: &quot; + board.getTitle());
        System.out.println(&quot; 조회수: &quot; + board.getCnt());
    &#125;
    System.out.println(&quot;총 글 수 : &quot; + list.size());
&#125;
&#125;</code></pre>
<hr>
<h2 id="GetBoardTest-java"><a href="#GetBoardTest-java" class="headerlink" title="GetBoardTest.java"></a>GetBoardTest.java</h2><pre><code>public class GetBoardTest &#123;
public static void main(String[] args) &#123;
    BoardDAO boardDAO = new BoardDAO();
    BoardVO vo = new BoardVO();

    vo.setSeq(4);
    vo = boardDAO.getBoard(vo);
    System.out.println(vo.getSeq() + &quot;번 글의 상세정보&quot;);
    System.out.println(&quot;제목:  &quot;+vo.getTitle());
    System.out.println(&quot;작성자: &quot; + vo.getWriter());
    System.out.println(&quot;내용: &quot; + vo.getContent());
    System.out.println(&quot;등록일: &quot; + vo.getRegDate());
    System.out.println(&quot;조회수: &quot; + vo.getCnt());
&#125;
&#125;</code></pre>
<hr>
<h2 id="JDBCUtil-java"><a href="#JDBCUtil-java" class="headerlink" title="JDBCUtil.java"></a>JDBCUtil.java</h2><ul>
<li>일일히 커넥션 만들고 닫고 할 수 없으니 따로 분리 시켜 놓은 클래스</li>
</ul>
<pre><code>  public class JDBCUtil &#123;

    public static Connection getConnection() &#123;
        try &#123;
   //            DriverManager.registerDriver(new org.h2.Driver());
            Class.forName(&quot;org.h2.Driver&quot;);
            return DriverManager.getConnection(&quot;jdbc:h2:tcp://localhost/~/test&quot;, &quot;sa&quot;, &quot;&quot;);

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

    public static void close(PreparedStatement stmt, Connection conn) &#123;
        try &#123;
            if(stmt != null) &#123;
                stmt.close();
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            stmt = null;
        &#125;
        try &#123;
            if(!conn.isClosed() &amp;&amp; conn != null)
                conn.close();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            conn = null;
        &#125;
    &#125;

    public static void close(ResultSet rs, PreparedStatement stmt, Connection conn) &#123;

        try &#123;
            if(rs != null) &#123;
                rs.close();
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            rs = null;
        &#125;
        try &#123;
            if(stmt != null) &#123;
                stmt.close();
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            stmt = null;
        &#125;
        try &#123;
            if(!conn.isClosed() &amp;&amp; conn != null)
                conn.close();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            conn = null;
        &#125;

    &#125;
  &#125;</code></pre>
<p>느낀점: 롬복 쩐다</p>
<p>+과제: 조회 할 때 마다 CNT(조회수)를 늘려보세요.(CNT 디폴트값: 0)<br>처음에 BoardDAO에 BOARD_GET쿼리 문에 “아무튼 쿼리문1”+”아무튼 쿼리문2”이렇게 하고 각각의 ?에 stmt.setInt(1, vo.getSeq()); stmt.setInt(2, vo.getSeq());할라 햇는데 아무튼 안되더라 -&gt; PreparedStatement객체를 두개 만들었다.</p>
<pre><code> private static final String BOARD_GET = &quot;select * from board where seq = ?&quot;;</code></pre>
<p>-&gt;</p>
<pre><code>private PreparedStatement stmt;
private PreparedStatement stmt2;</code></pre>
<hr>
<pre><code>private static final String BOARD_INCREASE = &quot;UPDATE BOARD SET CNT=CNT+1 WHERE SEQ=?&quot;;
private static final String BOARD_GET = &quot;select * from board where seq = ?&quot;;</code></pre>
<hr>
<pre><code>stmt = conn.prepareStatement(BOARD_GET);
stmt2 = conn.prepareStatement(BOARD_INCREASE);</code></pre>
<p>결과:<br><img src="https://user-images.githubusercontent.com/50402288/99501821-a2b20480-29bf-11eb-8f4a-49253d21280c.png" alt="20201118170049"></p>
<p>잘됩니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/18/Spring/fastcampus/day_2/" data-id="ckhn4bosf0000rwv12rvl9ech" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DAO/" rel="tag">DAO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lombok/" rel="tag">Lombok</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VO/" rel="tag">VO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/h2/" rel="tag">h2</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/17/Spring/fastcampus/day_1/" class="article-date">
  <time datetime="2020-11-17T07:05:51.000Z" itemprop="datePublished">2020-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-1/">day_1</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/17/Spring/fastcampus/day_1/">day_1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/99357311-0caea900-28ef-11eb-9bcb-7e21b79d6a1d.png" alt="image"><br> 바보야, 문제는 다형성이야. - 빌 클린턴</p>
<h1 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h1><ul>
<li><p>유지보수  측면에서 다형성은 매우매우 중요합니다.</p>
<h2 id="ex1"><a href="#ex1" class="headerlink" title="ex1"></a>ex1</h2><ul>
<li>엘지티비와 삼성티비를 구현할겁니다 </li>
<li>다형성이 구현되어 있지 않을 경우</li>
</ul>
</li>
</ul>
<pre><code>public class LgTv &#123;  
        public LgTv() &#123;  
            System.out.println(&quot;===&gt; LgTv 생성&quot;);  
  &#125; //  
  public void turnOn() &#123;  
            System.out.println(&quot;LgTv---전원 켠다&quot;);  
  &#125;  
        public void turnOff() &#123;  
            System.out.println(&quot;LgTv---전원 끈다&quot;);  
  &#125;  
        public void soundUp() &#123;  
            System.out.println(&quot;LgTv---소리 올린다&quot;);  
  &#125;  
        public void soundDown() &#123;  
            System.out.println(&quot;LgTv---소리 내린다&quot;);  

  &#125;  
&#125;</code></pre>
<hr>
<pre><code>    public class SamsungTV &#123;  
    public SamsungTV() &#123;  
        System.out.println(&quot;===&gt; SamsungTV 생성&quot;);  
  &#125; //  
  public void powerOn() &#123;  
        System.out.println(&quot;SamsungTV---전원 켠다&quot;);  
  &#125;  
    public void powerOff() &#123;  
        System.out.println(&quot;SamsungTV---전원 끈다&quot;);  
  &#125;  
    public void volumeUp() &#123;  
        System.out.println(&quot;SamsungTV---소리 올린다&quot;);  
  &#125;  
    public void volumeDown() &#123;  
        System.out.println(&quot;SamsungTV---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<pre><code>SamsungTV tv = new SamsungTV();  
tv.powerOn();  
tv.powerOff();  
tv.volumeDown();  
tv.volumeUp();  
LgTv tv2 = new LgTv();  
tv2.soundDown();  
tv2.soundUp();  
tv2.turnOff();  
tv2.turnOn(); //뭐하러 이렇게 하냐 하나하나 다 뜯어고쳐야 되잖아</code></pre>
<p>써있는 것처럼 메소드 하나하나 다 뜯어 고쳐야 하니 힘들죠? 그죠?</p>
<h2 id="ex2"><a href="#ex2" class="headerlink" title="ex2"></a>ex2</h2><ul>
<li><h2 id="인터페이스를-구현한-경우"><a href="#인터페이스를-구현한-경우" class="headerlink" title="인터페이스를 구현한 경우"></a>인터페이스를 구현한 경우</h2><p>  public interface TV {  </p>
<pre><code>  void powerOn();  </code></pre>
<p>   void powerOff();  </p>
<p>   void volumeUp();  </p>
<p>   void volumeDown();<br>  }</p>
</li>
</ul>
<hr>
<pre><code>public class LgTv implements TV&#123;  
        public LgTv() &#123;  
            System.out.println(&quot;===&gt; LgTv 생성&quot;);  
  &#125; //  


  @Override  
  public void powerOn() &#123;  
        System.out.println(&quot;LgTv---전원 켠다&quot;);  
  &#125;  

    @Override  
  public void powerOff() &#123;  
        System.out.println(&quot;LgTv---전원 끈다&quot;);  
  &#125;  
    @Override  
  public void volumeUp() &#123;  
            System.out.println(&quot;LgTv---소리 올린다&quot;);  
  &#125;  

    @Override  
  public void volumeDown() &#123;  
            System.out.println(&quot;LgTv---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<pre><code>public class SamsungTV implements TV &#123;  
    public SamsungTV() &#123;  
        System.out.println(&quot;===&gt; SamsungTV 생성&quot;);  
  &#125; //  
  @Override  
  public void powerOn() &#123;  
        System.out.println(&quot;SamsungTV---전원 켠다&quot;);  
  &#125;  
    @Override  
  public void powerOff() &#123;  
        System.out.println(&quot;SamsungTV---전원 끈다&quot;);  
  &#125;  
    @Override  
  public void volumeUp() &#123;  
        System.out.println(&quot;SamsungTV---소리 올린다&quot;);  
  &#125;  
    @Override  
  public void volumeDown() &#123;  
        System.out.println(&quot;SamsungTV---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<pre><code>  public static void main(String[] args) &#123;  
  TV tv = new SamsungTV();  
  tv.powerOn();  
  tv.powerOff();  
  tv.volumeDown();  
  tv.volumeUp();  
  TV tv2 = new LgTv();  
  tv2.powerOn();  
  tv2.powerOff();  
  tv2.volumeDown();  
  tv2.volumeUp(); 
// Polymorhpism: one interface multiful implementation.  
 //어떻게 하면 클라이언트를 아예 안바꾸고 수정할 수 있을까 -&gt; 디자인 패턴  
  &#125;</code></pre>
<hr>
<h2 id="인터페이스를-사용해도-여전히-클라이언트-수정이-불가피합니다-그러면-gt-디자인패턴-Factory-Pattern-을-씁니다"><a href="#인터페이스를-사용해도-여전히-클라이언트-수정이-불가피합니다-그러면-gt-디자인패턴-Factory-Pattern-을-씁니다" class="headerlink" title="인터페이스를 사용해도 여전히 클라이언트 수정이 불가피합니다 그러면 -&gt; 디자인패턴(Factory Pattern)을 씁니다."></a>인터페이스를 사용해도 여전히 클라이언트 수정이 불가피합니다 그러면 -&gt; 디자인패턴(Factory Pattern)을 씁니다.</h2><h2 id="ex3"><a href="#ex3" class="headerlink" title="ex3"></a>ex3</h2><ul>
<li>팩토리 디자인 패턴을 구현한 경우</li>
</ul>
<hr>
<ul>
<li><h2 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h2><p>  public interface TV {<br>   void powerOn();  </p>
<p>   void powerOff();  </p>
<p>   void volumeUp();  </p>
<p>   void volumeDown();<br>  }</p>
</li>
</ul>
<hr>
<ul>
<li>엘지 티비</li>
</ul>
<hr>
<pre><code>public class LgTv implements TV &#123;  
        public LgTv() &#123;  
            System.out.println(&quot;===&gt; LgTv 생성&quot;);  
  &#125; //  


  @Override  
  public void powerOn() &#123;  
        System.out.println(&quot;LgTv---전원 켠다&quot;);  
  &#125;  

    @Override  
  public void powerOff() &#123;  
        System.out.println(&quot;LgTv---전원 끈다&quot;);  
  &#125;  
    @Override  
  public void volumeUp() &#123;  
            System.out.println(&quot;LgTv---소리 올린다&quot;);  
  &#125;  

    @Override  
  public void volumeDown() &#123;  
            System.out.println(&quot;LgTv---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<ul>
<li>삼성 티비</li>
</ul>
<hr>
<pre><code>  public class SamsungTV implements TV &#123;  
    public SamsungTV() &#123;  
        System.out.println(&quot;===&gt; SamsungTV 생성&quot;);  
  &#125; //  
  @Override  
  public void powerOn() &#123;  
        System.out.println(&quot;SamsungTV---전원 켠다&quot;);  
  &#125;  
    @Override  
  public void powerOff() &#123;  
        System.out.println(&quot;SamsungTV---전원 끈다&quot;);  
  &#125;  
    @Override  
  public void volumeUp() &#123;  
        System.out.println(&quot;SamsungTV---소리 올린다&quot;);  
  &#125;  
    @Override  
  public void volumeDown() &#123;  
        System.out.println(&quot;SamsungTV---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<ul>
<li>구글 티비</li>
</ul>
<hr>
<pre><code>public class GoogleTV implements TV &#123;  
    public GoogleTV() &#123;  
        System.out.println(&quot;===&gt; GoogleTV 생성&quot;);  
  &#125; //  
  @Override  
  public void powerOn() &#123;  
        System.out.println(&quot;GoogleTV---전원 켠다&quot;);  
  &#125;  
    @Override  
  public void powerOff() &#123;  
        System.out.println(&quot;GoogleTV---전원 끈다&quot;);  
  &#125;  
    @Override  
  public void volumeUp() &#123;  
        System.out.println(&quot;GoogleTV---소리 올린다&quot;);  
  &#125;  
    @Override  
  public void volumeDown() &#123;  
        System.out.println(&quot;GoogleTV---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<ul>
<li>팩토리 패턴</li>
</ul>
<hr>
<pre><code>public class BeanFactory &#123;//Factory디자인 패턴  
  //Bean -&gt; 객체, BeanFactory:객체 공장  
  public Object getBean(String id) &#123;  
        if(id.equals(&quot;lg&quot;)) &#123;  
            return new LgTv();  
  &#125; else if(id.equals(&quot;samsung&quot;)) &#123;  
            return new SamsungTV();  
  &#125;  
        else if(id.equals(&quot;Google&quot;)) &#123;  
            return new GoogleTV();  
  &#125;//분기 계속 만들어줘야해 -&gt; Spring frame work로 간다!(자바 소스 안건드리고 유지보수가 가능하다.)  
  return null;  
  &#125;  
&#125;</code></pre>
<p>   <img src="https://user-images.githubusercontent.com/50402288/99366591-2aced600-28fc-11eb-90ca-72bef96101ad.png" alt="20201117174111"></p>
<p>(빨간색은 무시하세요 왜저럴까요) arg에 Google을 넣으면</p>
<hr>
<ul>
<li>TVUser</li>
</ul>
<hr>
<pre><code>public class TVUser3 &#123;  
    public static void main(String[] args) &#123;  
        BeanFactory factory = new BeanFactory();  

  TV tv = (TV) factory.getBean(args[0]);  
  tv.powerOff();  
  tv.powerOn();  
  tv.volumeDown();  
  tv.volumeUp();  
  &#125;  
&#125;</code></pre>
<p>  보이는 것처럼 args[0]에 Google이 들어가서 팩토리 패턴에 id에 Google을 넘겨주는 것을 알 수 있습니다. 그러면 우리는 클라이언트를 수정 할 필요 없이 서로다른 클래스를 args에 다른 문자열을 넣는것으로 생성 가능 합니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/17/Spring/fastcampus/day_1/" data-id="ckhlqimcn0008dov17lt9bkwd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Polymorphism/" rel="tag">Polymorphism</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/Level1/">Level1</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/Level1/Crain/">Crain</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/Level1/One-Plus-One/">One_Plus_One</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/">MySQL</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/Quiz-1/">Quiz_1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/Quiz-2/">Quiz_2</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/day-1/">day_1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/day-2/">day_2</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/day-3/">day_3</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Front-End/">Front-End</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Front-End/day-1/">day_1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Front-End/day-2/">day_2</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Front-End/day-3/">day_3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Front-End/day-4/">day_4</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-1/">day_1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-2/">day_2</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-3/">day_3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-4/">day_4</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-5/">day_5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-6/">day_6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-7/">day_7</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/til/">til</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/til/day-1/">day_1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/til/day-2/">day_2</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot-AWS/">SpringBoot&AWS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot-AWS/TestCode/">TestCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot-AWS/intelliJ-springboot/">intelliJ&springboot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/">til</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Abstract-Class/">Abstract_Class</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Annotations/">Annotations</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Arrays/">Arrays</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Class/">Class</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Conditional-Statements/">Conditional_Statements</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/DataType/">DataType</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Enum/">Enum</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Generic/">Generic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Handling-Exception/">Handling_Exception</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Inheritance/">Inheritance</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/InnerClasses/">InnerClasses</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Input-and-Output/">Input and Output</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Interface/">Interface</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/JCF/">JCF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Lambda/">Lambda</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Loops/">Loops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Modifier/">Modifier</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/MultiThread/">MultiThread</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/N-D-Arrays/">N-D_Arrays</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/OOP/">OOP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Package/">Package</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Polymorphism/">Polymorphism</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Polymorphism1/">Polymorphism1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Regular-Expression/">Regular_Expression</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/StringTokenizer/">StringTokenizer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Strings/">Strings</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Variable/">Variable</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Wrapper-Class/">Wrapper Class</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/java-lang/">java_lang</a></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Abstract-Class/" rel="tag">Abstract_Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Annotations/" rel="tag">Annotations</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arrays/" rel="tag">Arrays</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Class/" rel="tag">Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Conditional-Statements/" rel="tag">Conditional_Statements</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DAO/" rel="tag">DAO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataType/" rel="tag">DataType</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/" rel="tag">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Enum/" rel="tag">Enum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Front-End/" rel="tag">Front-End</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Generic/" rel="tag">Generic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handling-Exception/" rel="tag">Handling_Exception</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Inheritance/" rel="tag">Inheritance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/InnerClasses/" rel="tag">InnerClasses</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Input-and-Output/" rel="tag">Input and Output</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interface/" rel="tag">Interface</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JCF/" rel="tag">JCF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda/" rel="tag">Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Level1/" rel="tag">Level1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lombok/" rel="tag">Lombok</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Loops/" rel="tag">Loops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/" rel="tag">MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Modifier/" rel="tag">Modifier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MultiThread/" rel="tag">MultiThread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/N-D-Arrays/" rel="tag">N-D_Arrays</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOP/" rel="tag">OOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Package/" rel="tag">Package</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Polymorphism/" rel="tag">Polymorphism</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Programmers/" rel="tag">Programmers</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quiz-1/" rel="tag">Quiz_1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quiz-2/" rel="tag">Quiz_2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Regular-Expression/" rel="tag">Regular_Expression</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/StringTokenizer/" rel="tag">StringTokenizer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Strings/" rel="tag">Strings</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VO/" rel="tag">VO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Variable/" rel="tag">Variable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wrapper-Class/" rel="tag">Wrapper Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/day-1/" rel="tag">day_1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/day-2/" rel="tag">day_2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/day-3/" rel="tag">day_3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/day-4/" rel="tag">day_4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h2/" rel="tag">h2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-lang/" rel="tag">java_lang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springBoot/" rel="tag">springBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testCode/" rel="tag">testCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Abstract-Class/" style="font-size: 10px;">Abstract_Class</a> <a href="/tags/Algorithm/" style="font-size: 11.25px;">Algorithm</a> <a href="/tags/Annotations/" style="font-size: 10px;">Annotations</a> <a href="/tags/Arrays/" style="font-size: 10px;">Arrays</a> <a href="/tags/CSS/" style="font-size: 13.75px;">CSS</a> <a href="/tags/Class/" style="font-size: 10px;">Class</a> <a href="/tags/Conditional-Statements/" style="font-size: 10px;">Conditional_Statements</a> <a href="/tags/DAO/" style="font-size: 10px;">DAO</a> <a href="/tags/DataType/" style="font-size: 10px;">DataType</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/Enum/" style="font-size: 10px;">Enum</a> <a href="/tags/Front-End/" style="font-size: 13.75px;">Front-End</a> <a href="/tags/Generic/" style="font-size: 10px;">Generic</a> <a href="/tags/HTML/" style="font-size: 13.75px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 12.5px;">HTTP</a> <a href="/tags/Handling-Exception/" style="font-size: 10px;">Handling_Exception</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Inheritance/" style="font-size: 10px;">Inheritance</a> <a href="/tags/InnerClasses/" style="font-size: 10px;">InnerClasses</a> <a href="/tags/Input-and-Output/" style="font-size: 10px;">Input and Output</a> <a href="/tags/Interface/" style="font-size: 10px;">Interface</a> <a href="/tags/JCF/" style="font-size: 13.75px;">JCF</a> <a href="/tags/JSP/" style="font-size: 11.25px;">JSP</a> <a href="/tags/Lambda/" style="font-size: 10px;">Lambda</a> <a href="/tags/Level1/" style="font-size: 11.25px;">Level1</a> <a href="/tags/Lombok/" style="font-size: 10px;">Lombok</a> <a href="/tags/Loops/" style="font-size: 10px;">Loops</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/Modifier/" style="font-size: 10px;">Modifier</a> <a href="/tags/MultiThread/" style="font-size: 16.25px;">MultiThread</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/N-D-Arrays/" style="font-size: 10px;">N-D_Arrays</a> <a href="/tags/OOP/" style="font-size: 10px;">OOP</a> <a href="/tags/Package/" style="font-size: 10px;">Package</a> <a href="/tags/Polymorphism/" style="font-size: 12.5px;">Polymorphism</a> <a href="/tags/Programmers/" style="font-size: 11.25px;">Programmers</a> <a href="/tags/Quiz-1/" style="font-size: 10px;">Quiz_1</a> <a href="/tags/Quiz-2/" style="font-size: 10px;">Quiz_2</a> <a href="/tags/Regular-Expression/" style="font-size: 10px;">Regular_Expression</a> <a href="/tags/Servlet/" style="font-size: 12.5px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 17.5px;">Spring</a> <a href="/tags/StringTokenizer/" style="font-size: 10px;">StringTokenizer</a> <a href="/tags/Strings/" style="font-size: 10px;">Strings</a> <a href="/tags/VO/" style="font-size: 10px;">VO</a> <a href="/tags/Variable/" style="font-size: 10px;">Variable</a> <a href="/tags/Wrapper-Class/" style="font-size: 10px;">Wrapper Class</a> <a href="/tags/day-1/" style="font-size: 12.5px;">day_1</a> <a href="/tags/day-2/" style="font-size: 12.5px;">day_2</a> <a href="/tags/day-3/" style="font-size: 11.25px;">day_3</a> <a href="/tags/day-4/" style="font-size: 10px;">day_4</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/h2/" style="font-size: 10px;">h2</a> <a href="/tags/java/" style="font-size: 18.75px;">java</a> <a href="/tags/java-lang/" style="font-size: 10px;">java_lang</a> <a href="/tags/springBoot/" style="font-size: 11.25px;">springBoot</a> <a href="/tags/testCode/" style="font-size: 10px;">testCode</a> <a href="/tags/til/" style="font-size: 20px;">til</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/01/Spring/springboot&AWS/testCode/">TestCode</a>
          </li>
        
          <li>
            <a href="/2020/12/31/Spring/springboot&AWS/intelliJ&springboot/">intelliJ&amp;springboot</a>
          </li>
        
          <li>
            <a href="/2020/12/22/Spring/fastcampus/day_8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/25/Spring/fastcampus/day_7/">day_7</a>
          </li>
        
          <li>
            <a href="/2020/11/24/Spring/fastcampus/day_6/">day_6</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Hansol<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>