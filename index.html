<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hansol</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="한솔이블로그">
<meta property="og:type" content="website">
<meta property="og:title" content="Hansol">
<meta property="og:url" content="https://hansol-jeong.github.io/index.html">
<meta property="og:site_name" content="Hansol">
<meta property="og:description" content="한솔이블로그">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hansol">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hansol" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hansol</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hansol-jeong.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Spring/fastcampus/day_7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/25/Spring/fastcampus/day_7/" class="article-date">
  <time datetime="2020-11-25T06:11:25.000Z" itemprop="datePublished">2020-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-7/">day_7</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/25/Spring/fastcampus/day_7/">day_6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/102800280-fff20900-43f6-11eb-93ac-2fac7080233a.png" alt="image"><br>“The purpose of life is finding the largest burden that you can bear and bearing it.”<br>― Jordan B. Peterson</p>
<hr>
<p><img src="https://user-images.githubusercontent.com/50402288/102800592-6f67f880-43f7-11eb-9d93-d309389579db.png" alt="image"></p>
<h2 id="아키텍쳐는-어플리케이션의-뼈대입니다-그렇다면"><a href="#아키텍쳐는-어플리케이션의-뼈대입니다-그렇다면" class="headerlink" title="아키텍쳐는 어플리케이션의 뼈대입니다. 그렇다면"></a>아키텍쳐는 어플리케이션의 뼈대입니다. 그렇다면</h2><h3 id="아키텍쳐란-무엇입니까"><a href="#아키텍쳐란-무엇입니까" class="headerlink" title="아키텍쳐란 무엇입니까?"></a>아키텍쳐란 무엇입니까?</h3><ul>
<li>MODEL_1 Architecture<ul>
<li>아키텍쳐는 어플리케이션의 뼈대</li>
<li>MODEL: VO</li>
<li>VIEW: JSP</li>
<li>CONTROLLER: controller(servlet)</li>
</ul>
</li>
</ul>
<h2 id="session-이나-request에-결과가-저장이-되었다면el과-jstl을-통해서-jsp에-뿌려줄-수-있습니다"><a href="#session-이나-request에-결과가-저장이-되었다면el과-jstl을-통해서-jsp에-뿌려줄-수-있습니다" class="headerlink" title="session 이나 request에 결과가 저장이 되었다면el과 jstl을 통해서 jsp에 뿌려줄 수 있습니다."></a>session 이나 request에 결과가 저장이 되었다면el과 jstl을 통해서 jsp에 뿌려줄 수 있습니다.</h2><h3 id="model-addAttribute-“List”-List"><a href="#model-addAttribute-“List”-List" class="headerlink" title="model.addAttribute(“List”, List);"></a>model.addAttribute(“List”, List);</h3><p> List란 Key값으로 List 객체를 넣어줬다면 jsp에서<br> &lt;c:forEach var=”content” items=”${List}”&gt;</p>
<p></c:forEach><br>이런식으로 List의 원소값들을 뿌려 줄 수 있습니다. 그렇다면 그 원소값은 ${content}로 뿌려줄 수 있을 것입니다. </p>
<h3 id="session-setAttribute-“List”-List"><a href="#session-setAttribute-“List”-List" class="headerlink" title="session.setAttribute(“List”, List);"></a>session.setAttribute(“List”, List);</h3><p>session도 마찬가지 입니다. session.setAttribute(“List”, List); 으로 세션에 저장하였다면<br>${sessionScope.List}로 값을 뿌려줄 수 있습니다.</p>
<h2 id="IoC-Inversion-of-Control"><a href="#IoC-Inversion-of-Control" class="headerlink" title="IoC(Inversion of Control)"></a>IoC(Inversion of Control)</h2><ul>
<li>원래는 개발자가 객체의 생명주기를 관리합니다 하지만 이 제어권을 프레임워크(Spring)에게 넘겨주는 것이 IoC입니다. 때문에 제어의 역제어라고 합니다.</li>
<li>이제 개발자는 객체를 ‘생성’하는 것이 아닌 ‘호출’하여 씁니다.</li>
<li>역제어의 예)  서블릿은 개발자가 만드는 것이 아니다. xml을 로딩하여 서블릿 컨테이너가 서블릿을 만든다. 제어권은 서블릿 컨테이너에게 있다.<h3 id="순제어-V-S-역제어"><a href="#순제어-V-S-역제어" class="headerlink" title="순제어 V.S 역제어"></a>순제어 V.S 역제어</h3>순제어는 유지보수가 어렵습니다.  하지만 역제어는 유지보수가 용이합니다. (xml파일만 건드리면 됩니다)</li>
</ul>
<p>스프링 컨테이너도 마찬가지입니다. 서블릿 컨테이너와 마찬가지로 xml파일을 로딩합니다<br> 로딩하면 xml파일에 bean등록된 클래스들이 객체로서 JVM 메모리에 올라갑니다. 어떤 객체가 메모리에 뜰지는 xml만 수정하면 수정가능합니다. 이것이 역제어의 편리성입니다.</p>
<p>스프링컨테이너가 bean등록한 객체들을 무조건 메모리에 띄운다. (등록된 순서대로)<br>이 떄 bean등록되는 클래스들은 모두 디폴트 생성자가 필요합니다. 컨테이너에서 bean등록 시 디폴트 생성자가 없다면 메모리에 띄우지 않습니다. 그래서 의존성 주입이 필요합니다.</p>
<h3 id="의존성-주입"><a href="#의존성-주입" class="headerlink" title="의존성 주입"></a>의존성 주입</h3><ul>
<li><p>Constructor Injection</p>
</li>
<li><p>Setter Injection</p>
<h3 id="Constructor-Injection"><a href="#Constructor-Injection" class="headerlink" title="Constructor Injection"></a>Constructor Injection</h3><p>간단한 가정! 현재 TV라는 인터페이스가 있으며 TV를 상속받은 sonyTV, samsungTV 클래스가 있다고 가정합니다. 또한 Speaker 인터페이스가 있으며 역시 sonySpeaker, samsungSpeaker가 있습니다.</p>
<pre><code> &lt;bean id=&quot;tv&quot; class=&quot;polymorphism.SamsungTV&quot;&gt;</code></pre>
</li>
</ul>
<p>라고 명시되어 있다면 해석은 “tv”라는 id로 호출할 수 있는 bean객체를 등록할 것인데 그 bean객체의 클래스는 samsungTV입니다. 때문에 JVM메모리에 떠있는 TV라는 인터페이스를 가진 객체는 samsungTV하나이죠. 이를 @Component(“tv”)해서 객체를 가져온다면 samsungTV객체가 로딩될 것입니다.<br> 이 때 samsungTV는 speaker라는 필드를 가지고 있습니다. 이 speaker또한 인터페이스이니 해당 인터페이스를 상속받은 객체를 주입시켜주어야 합니다 이를 생성자 인젝션으로 한다면</p>
<pre><code>   &lt;constructor-arg  ref=&quot;sony&quot;&gt;&lt;/constructor-arg&gt;
   &lt;bean id=&quot;sony&quot; class=&quot;polymorphism.SonySpeaker&quot;&gt;&lt;/bean&gt;
   &lt;/bean&gt;</code></pre>
<p>와 같이 됩니다 이를 해석하면 tv bean을 띄울 때 constructor-arg: 생성자로서 “sony”라는 id를 가진 bean객체를 등록합니다. 이는 samsungTV객체가 생성될 때 samsungTV생성자의 파라미터로써 들어가게 된다는 의미입니다. 주의할 점은 bean에 등록되려면 스프링 컨테이너가 해당 bean을 인지할 수 있어야 하며 전제조건으로 bean으로 등록되려는 클래스는 꼭 디폴트 생성자를 가져야 한다고 했습니다. 때문에 생성자를 오버라이딩하여 Speaker클래스의 객체를 파라미터로 받는 생성자를 만들어 줘야 합니다.</p>
<pre><code>public SamsungTV(SonySpeaker speaker) &#123;

System.out.println(&quot;===&gt; SamsungTV  객체 생성&quot;);

this.speaker = speaker;

&#125;</code></pre>
<h3 id="Setter-Injection"><a href="#Setter-Injection" class="headerlink" title="Setter Injection"></a>Setter Injection</h3><p> Setter Injection이 이루어지기위한 간단한 전제조건은 samsungTV()에 setSpeaker()라는 세터메소드가 존재해야한다는 것입니다. </p>
<pre><code> public void setSpeaker(SonySpeaker speaker) &#123;

this.speaker  = speaker;

&#125;</code></pre>
<p>또한 xml단에서는 </p>
<pre><code>&lt;bean id=&quot;tv&quot; class=&quot;polymorphism.SamsungTV&quot;&gt;

&lt;property name=&quot;speaker&quot;  ref=&quot;sony&quot;&gt;&lt;/property&gt;

&lt;/bean&gt;

&lt;bean id=&quot;sony&quot; class=&quot;polymorphism.SonySpeaker&quot;&gt;&lt;/bean&gt;</code></pre>
<p>  “tv”라는 id를 가진 bean객체를 등록하는데 이 객체의 클래스는 samsungTV입니다. 이 때<br> property: speaker필드의 값을 “sony”라는 id를 가진 bean으로 설정합니다.<br> “sony”라는 id를 가진 bean은 sonySpeaker클래스를 가진 객체입니다.</p>
<ul>
<li><p>id를 지정해주지 않았을 시<br>Creating instance of bean ‘Polymorphism4.GoogleTV#0’  이 콘솔에 뜹니다 이것이 자동생성되는 고유아이디입니다.</p>
</li>
<li><p>컨테이너는 MAP이다. bean에서 Key=tv, value=samsungTV</p>
</li>
<li><p>컨테이너가 xml파일을 로딩합니다 : xml을 통해서 spring container을 제어할 수 있다.</p>
</li>
<li><p>아키텍쳐는 jar형태로서 라이브러리에 다 들어있다. 이것이 뼈대이며 이것이 프레임 워크입니다.</p>
</li>
<li><p>프레임워크가 뼈대이면 비지니스로직은 뼈대에 붙일 살이라고 할 수 있습니다.</p>
</li>
<li><p>이 뼈와 살을 연결하는 것이 xml환경설정 파일.(접착제, 살을 뼈에 넘겨줄 건데 어떤 설정으로 넘겨줄 것이냐)</p>
<h2 id="서블릿-컨테이너와-스프링-컨테이너의-비교"><a href="#서블릿-컨테이너와-스프링-컨테이너의-비교" class="headerlink" title="서블릿 컨테이너와 스프링 컨테이너의 비교"></a>서블릿 컨테이너와 스프링 컨테이너의 비교</h2><p>서블릿은 클라이언트가 불러야주고 스프링은 애초에 컨테이너 호출하면 메모리에 다 올리고시작하고 하지만 둘다 역제어는 똑같고 왜 똑같냐 스프링은 컨테이너가 bean을 불러와서 객체생성하고 서블릿은 서블릿 컨테이너가 url맞으면 그 때 서블릿 생성하고 그래서 역제어인건 똑같애</p>
<ul>
<li>서블릿 컨테이너는 클라이언트가 요청시에 서블릿 객체를 생성합니다(lazy-loading) 반면에 스프링 컨테이너는 호출됨과 동시에 객체를 메모리에 다 로딩 시키고 시작합니다.(pre-loading).</li>
</ul>
</li>
<li><p>둘다 역제어 입니다. 스프링은 컨테이너가 bean을 불러와서 객체생성하니까 역제어이고, 서플릿은 서블릿 컨테이너가 url이 맞으면 그 때 서블릿을 생성하므로 역제어인 것은 동일합니다.</p>
</li>
</ul>
<p>디폴트 생성자만 쓰면 그럼 초기화는 어떻게해? -&gt;  xml에 초기화 메소드, 파괴메소드 등록할 수 있어.<br>같은 객체 계속 불러와야돼? -&gt; 싱글톤 -&gt; 싱글톤도 하지마</p>
<h2 id="Ioc는-두가지-제어를-개발자에게서-가져갔다"><a href="#Ioc는-두가지-제어를-개발자에게서-가져갔다" class="headerlink" title="Ioc는 두가지 제어를 개발자에게서 가져갔다"></a>Ioc는 두가지 제어를 개발자에게서 가져갔다</h2><ol>
<li>객체 생성</li>
<li>객체와 객체간의 의존관계<br>객체생성은 xml파일에서 관리하고, 의존관계 역시 xml파일에서 관리합니다.</li>
</ol>
<h2 id="Annotation설정"><a href="#Annotation설정" class="headerlink" title="Annotation설정"></a>Annotation설정</h2><p>@Autowired: 매우매우 중요한 타입인젝션, 변수의 타입을 기준으로 의존성 주입을 처리한다.<br>따라서 해당 타입의 객체가 메모리에 있기만 하면 컨테이너가 그 객체를 변수에 할당한다.<br>만약 주입할 객체가 없으면 exception 발생 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/25/Spring/fastcampus/day_7/" data-id="ckiyvr0fa0002kwv1hixjgdzv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/24/Spring/fastcampus/day_6/" class="article-date">
  <time datetime="2020-11-24T04:01:53.000Z" itemprop="datePublished">2020-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-6/">day_6</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/24/Spring/fastcampus/day_6/">day_6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/100047678-674b8600-2e56-11eb-8773-cdbf9702f948.png" alt="image"><br>Success is not final, failure is not fatal: it is the courage to continue that counts. -Winston Churchill</p>
<ul>
<li>el, jstl</li>
<li>mvc 패턴</li>
<li>framework란 무엇인가</li>
</ul>
<h2 id="el-jstl"><a href="#el-jstl" class="headerlink" title="el, jstl"></a>el, jstl</h2><p>우리는 서블릿을 작성하던 중 브라우저에 나타날 HTML코드를 서블릿에서 일일히 out.println()으로 작성하는 것에 매우 불편함을 느꼈었 습니다. 그렇기에 JSP를 통해 HTML과 자바코드를 분리하고자 시도했죠. 개선은 되었지만 여전히 Java코드와 HTML코드는 완벽하게 분리되지 않았고, 불편했습니다. 때문에 적용하는 것이 el, jstl입니다.</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>el과 jstl이 적용되는 예를 보기전에 MVC패턴에 대해 알고 지나가야 합니다. MVC 란 model, view, controller를 각각 한자씩 딴것으로 아래와 같은 프로토콜을 가지고 있습니다.<br><img src="https://user-images.githubusercontent.com/50402288/100053303-1beba480-2e63-11eb-9333-5578c7d0cd08.png" alt="20201124144040"></p>
<p>HTML관련 코드는 모두 view, 즉 jsp파일로 만듭니다. jsp파일에서 request를 요청하면 jsp파일에서 분리된, 자바코드로 이루어진 controller가 요청을 처리합니다. 요청을 처리할 때 VO, DAO가 포함된 Model의 데이터를 활용해서 응답화면(view)를 클라이언트에 전송해줍니다. 이렇게 모델, 뷰, 컨트롤러로 역할이 분담된 형태를 MVC패턴이라 합니다.</p>
<p>쟈, MVC가 뭔지 찍먹해봤습니다. MVC란 각각의 역할을 분담하였다고 했는데 이 때 el, jstl이 사용됩니다. MVC로 코드를 나누기 전 우리의 JSP파일에는 여전히 JAVA코드가 남아있습니다 보시겠습니다.</p>
<h3 id="getBoardList-jsp"><a href="#getBoardList-jsp" class="headerlink" title="getBoardList.jsp"></a>getBoardList.jsp</h3><pre><code>&lt;%@page import=&quot;com.rubypaper.biz.user.UserVO&quot;%&gt;
&lt;%@page import=&quot;java.util.List&quot;%&gt;
&lt;%@page import=&quot;com.rubypaper.biz.board.BoardDAO&quot;%&gt;
&lt;%@page import=&quot;com.rubypaper.biz.board.BoardVO&quot;%&gt;
&lt;%@page contentType=&quot;text/html; charset=EUC-KR&quot;%&gt;

&lt;%
    // 0. 세션에 등록된 정보 꺼내기

    // 1. 사용자 입력정보 추출

    // Null Check

    // 2. DB 연동 처리

    // 3. 응답 화면 구성
    * 를 구성하는 자바코드 *
%&gt;
* 자바코드가 포함된 HTML *코드
&lt;!DOCTYPE html PUBLIC &#39;-//W3C//DTD HTML 4.01 Transitional//EN&#39; &#39;http://www.w3.org/TR/html4/loose.dtd&#39;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html; charset=EUC-KR&#39;&gt;
&lt;title&gt;글 목록&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;center&gt;
        &lt;h1&gt;게시글 목록&lt;/h1&gt;
        &lt;h3&gt;
            &lt;font color=&#39;red&#39;&gt;&lt;%= user.getName() %&gt;&lt;/font&gt;님 로그인 환영합니다...... &lt;a href=&#39;logout_proc.jsp&#39;&gt;Log-out&lt;/a&gt;
        &lt;/h3&gt;
        &lt;!-- 검색 시작 --&gt;
        &lt;form action=&#39;getBoardList.jsp&#39; method=&#39;post&#39;&gt;
            &lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;
                &lt;tr&gt;
                    &lt;td align=&#39;right&#39;&gt;&lt;select name=&#39;searchCondition&#39;&gt;
                            &lt;option value=&#39;TITLE&#39;&gt;제목
                            &lt;option value=&#39;CONTENT&#39;&gt;내용
                    &lt;/select&gt; 
                    &lt;input name=&#39;searchKeyword&#39; type=&#39;text&#39; /&gt; 
                    &lt;input type=&#39;submit&#39; value=&#39;검색&#39; /&gt;&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/form&gt;
        &lt;!-- 검색 종료 --&gt;
        &lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;
            &lt;tr&gt;
                &lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;번호&lt;/th&gt;
                &lt;th bgcolor=&#39;orange&#39; width=&#39;200&#39;&gt;제목&lt;/th&gt;
                &lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;작성자&lt;/th&gt;
                &lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;등록일&lt;/th&gt;
                &lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;조회수&lt;/th&gt;
            &lt;/tr&gt;

            &lt;% for(BoardVO board : boardList) &#123; %&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;%= board.getSeq() %&gt;&lt;/td&gt;
                &lt;td align=&#39;left&#39;&gt;&lt;a href=&#39;getBoard.jsp?seq=&lt;%= board.getSeq() %&gt;&#39;&gt;&lt;%= board.getTitle() %&gt;&lt;/a&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getWriter() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getRegDate() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getCnt() %&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;% &#125; %&gt;

        &lt;/table&gt;
        &lt;br&gt; &lt;a href=&#39;insertBoard.html&#39;&gt;새글 등록&lt;/a&gt;
    &lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>위의 코드는 크게 요청을 처리하는 자바코드와 요청에 대한 응답화면을 구성하는 아래쪽의 HTML코드로 이루어져 있습니다. 이를 MVC 패턴에 맞게 분리하면<br><img src="https://user-images.githubusercontent.com/50402288/100053891-4ee26800-2e64-11eb-9bf0-913f69d65b1a.png" alt="20201124144941"><br>이와같이 DispatcherServlet.java파일에 각각의 처리에 대한 분기처리로 Controller부분을 만들 수 있고 이부분에 getBoardList.jsp파일의 윗부분의 모든 자바코드가 들어갑니다. 그러면 남은건 getBoardList.java파일의 아래부분인데요 이부분이 HTML과 java코드가 섞여있는게 불만입니다. 그러면 그것을 처리해보겠습니다.</p>
<hr>
<pre><code>&lt;% for(BoardVO board : boardList) &#123; %&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;%= board.getSeq() %&gt;&lt;/td&gt;
                &lt;td align=&#39;left&#39;&gt;&lt;a href=&#39;getBoard.jsp?seq=&lt;%= board.getSeq() %&gt;&#39;&gt;&lt;%= board.getTitle() %&gt;&lt;/a&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getWriter() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getRegDate() %&gt;&lt;/td&gt;
                &lt;td&gt;&lt;%= board.getCnt() %&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;% &#125; %&gt;</code></pre>
<p>   이부분이 대표적으로 위의 코드에서 HTML과 java코드가 섞인 부분입니다.<br>    el처리를 먼저 하면 session에 저장된 board정보를 자바코드를 쓰지 않고 처리할 수 있습니다<br>    &lt;%=board.getSeq() %&gt; -&gt; ${board.seq }와 같은식으로 처리할 수 있습니다.<br>    또한 jstl을 이용하면 if나 for문을 대체할 수 있습니다<br>    &lt;% for(BoardVO board : boardList) { %&gt; ~ &lt;% } %&gt; -&gt; &lt;c:forEach var=”board” items=’${boardList }’ &gt; ~ </c:forEach><br>    와 같이 표현될 수 있습니다. 이로써 MVC패턴과 jsp파일에 남아있던 java코드를 제거함으로써 깔끔하게 코드들을 분리시켜 낼 수 있습니다. 완성된 구조는 다음과 같습니다.<br>    <img src="https://user-images.githubusercontent.com/50402288/100054566-9e756380-2e65-11eb-8121-89c111f72db2.png" alt="20201124145902"><br>DAO, DO파일은 MVC패턴 중 M;Model에 해당하고 이는 데이터베이스와 연동됩니다. 이 때 클라이언트가 jsp파일(View)을 통해 request를 하면 request는 URI에 따라 DispatcherServlet(Controller)에서 if분기를 찾아 실행시킵니다. if분기에서 처리된 정보를 jsp파일에 건네주어 응답을 보냅니다. 아래는 DispatcherServlet의 분기 예시 입니다.</p>
<pre><code>// 2. 추출된 path에 따라 요청을 분기처리한다.
        if (path.equals(&quot;/login.do&quot;)) &#123;&#125;
        &#125; else if (path.equals(&quot;/logout.do&quot;)) &#123;&#125; 
        else if (path.equals(&quot;/insertBoard.do&quot;)) &#123;&#125;
         else if (path.equals(&quot;/deleteBoard.do&quot;)) &#123;&#125; 
         else if (path.equals(&quot;/getBoard.do&quot;)) &#123;&#125; 
         else if (path.equals(&quot;/getBoardList.do&quot;)) &#123;&#125;
         else if (path.equals(&quot;/updateBoard.do&quot;)) &#123;&#125; 
         else &#123;
            System.out.println(&quot;URL을 다시 확인해주시기 바랍니다.&quot;);
        &#125;</code></pre>
<hr>
<hr>
<ul>
<li>그외 알아둘 것들<ul>
<li>세션은 내장객체이다. 서블릿에서는 내장객체로서 작동하지 않아서 HttpSession객체를 쓸 때마다 정의해주어야 하지만(그렇다고 항상 새로생기는 것은 아니다. 세션정보가 있다면 있는 세션정보를 넘겨받아 사용한다.) jsp에선 바로 호출해서 쓸 수 있다. 내장객체이기 때문에!</li>
<li>model1 아키텍쳐: 자바로직을 html이랑 분리시킨다.</li>
<li>세션에 검색 목록 저장하면 안돼. 브라우저 끄기 전까지 살아있으니까. 그러니까 request에 저장해야돼. reqeust는 response 해주면 사라져 때문에 메모리를 많이 잡아먹지 않아. 그러면 세션엔? -&gt; 세션에는 id,권한 정도만 저장한다.</li>
<li>jsp에서 자바 코드를 분리해서 자바개발자는 controller만 관리하자가 목적이었어 -&gt; jsp가  el, jstl 을 사용하게 된 이유</li>
<li>request와 session에 동일한 정보가 저장되어있을 수 있어. 그 때 우선순위는 request에 저장된 정보야</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><h3 id="프레임웤이-도대체-뭐야"><a href="#프레임웤이-도대체-뭐야" class="headerlink" title="프레임웤이 도대체 뭐야?"></a>프레임웤이 도대체 뭐야?</h3><p><em>뼈대는 우리가 제공해줄게 니들은 살만붙여!</em></p>
<ul>
<li>Framework는 App을 개발할 때 아키텍쳐에 해당하는 골격 코드를 제공한다.</li>
<li>Solution이 완제품이라면 Framework는 반제품에 해당한다.</li>
<li>아무리 시간이 지나도 뼈대, 구조는 바뀌지 않는다.<h3 id="Framework의-장점"><a href="#Framework의-장점" class="headerlink" title="Framework의 장점"></a>Framework의 장점</h3></li>
<li>빠른 구현 시간</li>
<li>관리 용이성 증가</li>
<li>개발자의 역량 획일화</li>
<li>검증된 아키텍쳐의 재사용과 일관성 유지</li>
</ul>
<h3 id="Spring-Framework의-특징"><a href="#Spring-Framework의-특징" class="headerlink" title="Spring Framework의 특징"></a>Spring Framework의 특징</h3><ul>
<li>가볍다!(경량성): 스프링은 라이브러리 자체가 용량이 작아 왜?-&gt; POJO(Plain Old Java Object)로 이루어져 있거든<ul>
<li>POJO가 뭐야??:  예를들면 우리가 처음 작성해보는 helloworld.java같은 자바코드. 어떤것도 상속하지 않고 순수 자바코드로만 이루어져 있는 자바 클래스. 예를들면 우리전에만든 Servlet은 HttpServlet을 implement하잖아 그러면 규칙이 막 생겨, 서블릿클래스는 무조건 public형태여야 하고, override할 것도 생기고 서블릿 엔진이 막 나는 만들지도 않았는데 xml로딩해서 request만들고 response만들고 점점 무거워져 이렇게 작성 시에 규칙이 생기고 상속이 생기고 객체가 만들어지고 이런게 NOT POJO인 클래스들이고 POJO인 클래스는 아무런 제약, 규칙을 받지 않는 자바코드로서 상속받는게 없기 때문에 메모리사용량이 매우 적은 특징을 가져. 그리고 스프링은 POJO로 만들어 있기 때문에 가벼운거야!</li>
<li>커스터마이징 할 수 있다: 스프링은 오픈소스이고 오픈소스하면 가장 큰 장점은 무료인 것이라고 생각 하는 사람들이 많아. 맞는 말이지만 오픈소스의 가장 큰 장점은 무료인게 아니라 내가 임의로 커스터마이징 할 수 있다는 거야. 예를들면 Spring 3.0버전을 내입맛에 맞게 개량해서 나만의 MySpring 1.0으로 재탄생시켜도 문제가 없다는 거지!</li>
<li>그 외에도 AOP, IoC, 컨테이너라는 특징이 있는데 이건아직 안배웠어! 미안해!<br><img src="https://user-images.githubusercontent.com/50402288/100056147-7e936f00-2e68-11eb-8356-2c22ff02af6a.png" alt="image"></li>
</ul>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/50402288/100056199-97038980-2e68-11eb-9ad4-b4f0d3662b63.png" alt="20201124151917">  </p>
<p>이건 스프링을 배우기 전에 나한테 프레임워크의 개념을 잡는데 도움이 된 표야<br>Presentation: 즉 화면 개발을 담당하는 프레임워크인거야<br>Business: 비즈니스로직을 처리하는 프레임워크래<br>Persistence: DB연동을 처리하는 프레임워크고 크게 두 진영이 있어<br><img src="https://user-images.githubusercontent.com/50402288/100056324-d6ca7100-2e68-11eb-8051-661a56d4ef31.png" alt="image"></p>
<p>Hibernate&amp; JPA(청팀) vs. iBatis&amp;Mybatis(백팀)</p>
<p>청팀과 백팀은 가장 큰 차이점이 있어. 청팀은 ORM(Object Relation Mapping)프레임 워크인데 반해 백팀은 그렇지 않다는 거야. 무슨말이냐면 청팀은 프레임워크가 sql문을 자체적으로 생성해서 db연동까지 다해줘. 자동화라는 것이지. 하지만 백팀은 개발자가 직접 sql문을 써서 입력해줘야해. 유지보수측면에 봐도 자동화가 낫다고 생각해<br> 하지만 치명적인 청팀의 단점이 있대. 바로 어렵대. 그리고 백팀은 쉽대. 또 우리나라에선 백팀을 더 많이 쓴대…그렇대<br> 하지만 트랜드는 청팀!이래!</p>
<ul>
<li>그 외 알아둘 것들<ul>
<li>스프링은 컨테이너라는 것이 가장 중요한 개념이야! 컨테이너는 물건을 안전하게 저장하고 관리할 목적으로 사용해. 서블릿 엔진도 사실 컨테이너야. web.xml을 로딩해서 생성된 메소드를 보관하고 관리하는 역할을 하기 때문이지. 엔진=컨테이너라고 봐도 무방해!</li>
<li>서블릿 컨테이너 vs. 스프링 컨테이너<br>둘 사이에는 차이점이 한가지 있어. 전에 lazy-loading, pre-loading에 대해 배웠어. lazy-loading은 사용자가 요청하면 그 때 로딩해서 객체를 생성하지만 pre-loading은 무조건 xml에 등록된 클래스 객체들이 메모리에 할당되고 시작해. 다시말해서 서블릿컨테이너는 사용자가 요청을 하면 그 때 객체를 생성하기 때문에 lazy-loading이고 스프링 컨테이너는 무조건 객체들이 메모리에 올려지기 때문에 pre-loading이란 거야!</li>
<li>서블릿 컨테이너와 마찬가지로 스프링 컨테이너도 디폴트 생성자가 필요해. 우리 서블릿 배울 때 매개변수가 들어간 생성자를 만들고 디폴트 생성자를 정의 안해주면 서블릿 엔진이 해당 서블릿을 찾지 못하는 현상을 배운 적 있어. 스프링도 똑같애. 디폴트 생성자를 정의해 주지 않으면 안돼!</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/24/Spring/fastcampus/day_6/" data-id="ckhvlt7zx0008psv17si59dx0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVC/" rel="tag">MVC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/23/Spring/fastcampus/day_5/" class="article-date">
  <time datetime="2020-11-23T05:06:00.000Z" itemprop="datePublished">2020-11-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-5/">day_5</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/23/Spring/fastcampus/day_5/">day_5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/99928554-df4d7980-2d8c-11eb-8ad9-cd2bae5a96e3.png" alt="image"></p>
<p>one can never go back, that one should not ever try to go back – that the essence of life is going forward. Life is really a One Way Street. 되돌아가려 노력하지 않은 사람은 절대로 되돌아갈 수 없어요. 삶의 본질은 앞으로 나아가는 것이니까요. 삶은 정말 일방통행이에요. -Agatha Cristie</p>
<h1 id="JSPProject"><a href="#JSPProject" class="headerlink" title="JSPProject"></a>JSPProject</h1><ul>
<li>기존 서블릿의 단점을 보완한 기술입니다.</li>
<li><ul>
<li>기존 서블릿의 단점: 코드내에 HTML이 포함되어있어 작성시 매우 불편합니다. 때문에 코드가 길어지고 수정, 보완이 매우 어렵게됩니다. 이를 보완한 것이 JSP입니다.</li>
</ul>
</li>
<li>JSP: Java Server Page: 용어를 기억하는 것은 중요합니다.</li>
<li>정의: HTML 코드에 JAVA 코드를 넣어 동적웹페이지를 생성하는 웹어플리케이션 도구이다. -정의를 기억하는 것 또한 중ㅇ요합니다.</li>
</ul>
<hr>
<p>복습 요소:<br>필터에서 chain.doFilter를 만나면 다음 필터를 만나고 더이상 필터가 없으면 서블릿으로 갓다가 역순으로 다시 돌아온다 =&gt; 필터 체인</p>
<p>context=문맥=엔진</p>
<hr>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ul>
<li><p>세션; 웹 서버 쪽의 웹 컨테이너에 상태를 유지하기 위한 정보를 저장하는 장소.</p>
<ul>
<li>세션이 왜 중요한가?<br>우리는 앞서 로그인 페이지와 글 목록, 글 수정 삭제 등록 등 많은 기능을 구현해보았습니다. 하지만 한 가지 중요한 점을 놓쳤는데요, 바로 상태에 대한 저장이 없다는 것입니다. 가령 우리가 로그인 하지 않고 <code>http://localhost:7777/servletProject3/getBoardList.do</code><br>라는 URL을 치고 들어가면 우리는 로그인 절차 없이 글 목록을 볼 수 있습니다. 그렇기 때문에 로그인 되었는지, 누가 로그인을 하였는지에 대한 정보를 저장하고, 활용하기 위해 세션이 필요합니다.</li>
</ul>
</li>
<li><p>세션은 브라우저 하나당 하나씩만 유지됩니다. 재사용 할 때는 (만약 브라우저가 살아있다면) 우너래 세션의 주소만 리턴합니다. 즉 재사용 할 때마다 새로 생성하지 않습니다.</p>
<ul>
<li><p>세션의 메소드 중 중요한 것</p>
<ul>
<li><p>Object getAttribute(String name) : 이름에 해당하는 객체를 리턴한다.</p>
</li>
<li><p>void setAttribute(String name, Object value) : 객체를 Session에 저장한다.</p>
</li>
<li><p>void invalidate() : Session을 종료한다.</p>
</li>
<li><p>boolean  isNew() : Session이 처음 만들어진 것이면 true 를 리턴한다.</p>
</li>
<li><p>void removeAttribute(String name) : 주어진 이름에 해당하는 객체를 삭제한다.</p>
</li>
<li><p>void setMaxInactiveInterval(int seconds) : Session을 유지할 시간을 설정한다.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>jsp는 서비스메소드에 내가작성한 모든코드가 작성되기 때문에 get/post상관없이 작동한다.<br>톰켓 서버가 jsp를 서블릿으로 대신 작성해준다</p>
<h2 id="JSP-문법"><a href="#JSP-문법" class="headerlink" title="JSP 문법"></a>JSP 문법</h2><ul>
<li>Scriptlet: &lt;% %&gt;</li>
<li>Expression: &lt;%= %&gt;<br>두 가지의 차이점이 뭐냐, 첫번째는 정상적인 자바코드<br>두번째는 두가지가 온다. 변수, 메소드(void가 아닌, 뭔가를 리턴하는 메소드) 호출 두가지가 온다.</li>
<li>ctrl shit / :주석</li>
<li>&lt;!– –&gt;:html주석은 안쓴다(왜안쓰더라)</li>
<li>코드 끝에 ‘;’붙으면 정상적인 자바코드고 그러면 스크립틀릿을 써야해 익스프레션안돼</li>
</ul>
<hr>
<h2 id="JSPProject-구조-vs-ServletProject-구조"><a href="#JSPProject-구조-vs-ServletProject-구조" class="headerlink" title="JSPProject 구조 vs ServletProject 구조"></a>JSPProject 구조 vs ServletProject 구조</h2><p>아래는 JSP<br><img src="https://user-images.githubusercontent.com/50402288/99930089-2fc7d580-2d93-11eb-9984-e16a85a8a8ec.png" alt="20201123135231"><br>아래는 Servlet<br><img src="https://user-images.githubusercontent.com/50402288/99930155-656cbe80-2d93-11eb-90a8-11235fe7c067.png" alt="20201123135416"><br>둘 다 동일한 구조를 가지고 있으나 Servlet -&gt; JSP로 대체된 것을 볼 수 있습니다. 그러면 코드를 상세히 보면서 어느부분이 어떻게 대체가 되었는지 알아보겠습니다.</p>
<h2 id="주의-극단적인-비교를-위해-가장-긴-코드인-GetBoardListServlet-를-가져왔습니다"><a href="#주의-극단적인-비교를-위해-가장-긴-코드인-GetBoardListServlet-를-가져왔습니다" class="headerlink" title="*주의: 극단적인 비교를 위해 가장 긴 코드인 GetBoardListServlet 를 가져왔습니다."></a>*주의: 극단적인 비교를 위해 가장 긴 코드인 GetBoardListServlet 를 가져왔습니다.</h2><pre><code>public class GetBoardListServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;



    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //0. 세션 체크
        HttpSession session =request.getSession();
        UserVO user = (UserVO)session.getAttribute(&quot;user&quot;);
        if(user == null) &#123;
            response.sendRedirect(&quot;login.html&quot;);
        &#125; else &#123;
        //글 목록 화면을 요청한 브라우저와 매핑된 세션 객체를 얻어낸다.
//        HttpSession session = request.getSession();//request: 요청 프로토콜과 연결된 객체
//        if(session.isNew()) &#123;
//            System.out.println(&quot;===&gt; GetBoardListServlet 에서 처음 생성한 세션이다.&quot;);
//        &#125; else &#123;
//            System.out.println(&quot;---&gt; 이전에 생성된 세션 재사용하는 것이다.&quot;);
//        &#125;
        //1. 사용자 입력정보 추출(검색 기능은 숙제...)
//        request.setCharacterEncoding(&quot;EUC-KR&quot;);
        String searchCondition = request.getParameter(&quot;searchCondition&quot;);
        String searchKeyword = request.getParameter(&quot;searchKeyword&quot;);

        //null 체크를 해줘야해
        if(searchCondition == null) &#123;
            searchCondition = &quot;TITLE&quot;;
        &#125;
        if(searchKeyword == null)
            searchKeyword = &quot;&quot;;

        //2. DB연동 처리
        BoardVO vo = new BoardVO();
        vo.setSearchCondition(searchCondition);
        vo.setSearchKeyword(searchKeyword);

        BoardDAO boardDAO = new BoardDAO();
        List&lt;BoardVO&gt; boardList = boardDAO.getBoardList(vo);
        //3. 응답 화면 구성
        response.setContentType(&quot;text/html; charset=EUC-KR&quot;);
        PrintWriter out = response.getWriter();//출력 스트림
//        out.println(&quot;&lt;h1&gt;게시판 목록&lt;/h1&gt;&quot;);
//        for (BoardVO board : boardList) &#123;
//            out.println(&quot;---&gt;&quot; + board.toString() + &quot;&lt;br&gt;&quot;);
//        &#125; 아래와 같이 업그레이드 시킨다
        out.println(&quot;&lt;!DOCTYPE html PUBLIC &#39;-//W3C//DTD HTML 4.01 Transitional//EN&#39; &#39;http://www.w3.org/TR/html4/loose.dtd&#39;&gt;&quot;);
        out.println(&quot;&lt;html&gt;&quot;);
        out.println(&quot;&lt;head&gt;&quot;);
        out.println(&quot;&lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html; charset=EUC-KR&#39;&gt;&quot;);
        out.println(&quot;&lt;title&gt;글 목록&lt;/title&gt;&quot;);
        out.println(&quot;&lt;/head&gt;&quot;);
        out.println(&quot;&lt;body&gt;&quot;);
        out.println(&quot;&lt;center&gt;&quot;);
        out.println(&quot;&lt;h1&gt;게시글 목록&lt;/h1&gt;&quot;);
        out.println(&quot;&lt;h3&gt;&quot;+user.getName()+(&quot;userName&quot;)+&quot;님 로그인 환영합니다......&quot;);
        out.println(&quot;&lt;a href=&#39;logout.do&#39;&gt;Log-out&lt;/a&gt;&lt;/h3&gt;&quot;);

        out.println(&quot;&lt;!-- 검색 시작 --&gt;&quot;);
        out.println(&quot;&lt;form action=&#39;getBoardList.do&#39; method=&#39;post&#39;&gt;&quot;);//자기 자신을 한번더 호출
        out.println(&quot;&lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;&quot;);
        out.println(&quot;&lt;tr&gt;&quot;);
        out.println(&quot;&lt;td align=&#39;right&#39;&gt;&quot;);
        out.println(&quot;&lt;select name=&#39;searchCondition&#39;&gt;&quot;);
        out.println(&quot;&lt;option value=&#39;TITLE&#39;&gt;제목&quot;);
        out.println(&quot;&lt;option value=&#39;CONTENT&#39;&gt;내용&quot;);
        out.println(&quot;&lt;/select&gt;&quot;);
        out.println(&quot;&lt;input name=&#39;searchKeyword&#39; type=&#39;text&#39;/&gt;&quot;);
        out.println(&quot;&lt;input type=&#39;submit&#39; value=&#39;검색&#39;/&gt;&quot;);
        out.println(&quot;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;/tr&gt;&quot;);
        out.println(&quot;&lt;/table&gt;&quot;);
        out.println(&quot;&lt;/form&gt;&quot;);
        out.println(&quot;&lt;!-- 검색 종료 --&gt;&quot;);

        out.println(&quot;&lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;&quot;);
        out.println(&quot;&lt;tr&gt;&quot;);
        out.println(&quot;&lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;번호&lt;/th&gt;&quot;);
        out.println(&quot;&lt;th bgcolor=&#39;orange&#39; width=&#39;200&#39;&gt;제목&lt;/th&gt;&quot;);
        out.println(&quot;&lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;작성자&lt;/th&gt;&quot;);
        out.println(&quot;&lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;등록일&lt;/th&gt;&quot;);
        out.println(&quot;&lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;조회수&lt;/th&gt;&quot;);
        out.println(&quot;&lt;/tr&gt;&quot;);
for(BoardVO board : boardList) &#123;
        out.println(&quot;&lt;tr&gt;&quot;);
        out.println(&quot;&lt;td&gt;&quot;+board.getSeq()+&quot;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;td align=&#39;left&#39;&gt;&lt;a href=&#39;getBoard.do?seq=&quot;+board.getSeq()+&quot;&#39;&gt;&quot;+board.getTitle()+&quot;&lt;/a&gt;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;td&gt;&quot;+board.getWriter()+&quot;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;td&gt;&quot;+board.getRegDate()+&quot;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;td&gt;&quot;+board.getCnt()+&quot;&lt;/td&gt;&quot;);
        out.println(&quot;&lt;/tr&gt;&quot;);
&#125;
        out.println(&quot;&lt;/table&gt;&quot;);
        out.println(&quot;&lt;br&gt;&quot;);
        out.println(&quot;&lt;a href=&#39;insertBoard.html&#39;&gt;새글 등록&lt;/a&gt;&quot;);
        out.println(&quot;&lt;/center&gt;&quot;);
        out.println(&quot;&lt;/body&gt;&quot;);
        out.println(&quot;&lt;/html&gt;&quot;);

        out.close();
    &#125;
    &#125;
&#125;</code></pre>
<p>보시다 시피 HTML코드가 매우 길어서 보기 좋지 않습니다. 또한 해당 코드는 차후 내용이 바뀌었을 때 수정이 매우 힙듭니다. 이를 JSP로 작성하면</p>
<pre><code> &lt;%
        String searchCondition = request.getParameter(&quot;searchCondition&quot;);
        String searchKeyword = request.getParameter(&quot;searchKeyword&quot;);

        if (searchCondition == null) &#123;
            searchCondition = &quot;TITLE&quot;;
        &#125;
        if (searchKeyword == null)
            searchKeyword = &quot;&quot;;

        BoardVO vo = new BoardVO();
        vo.setSearchCondition(searchCondition);
        vo.setSearchKeyword(searchKeyword);

        BoardDAO boardDAO = new BoardDAO();
        List&lt;BoardVO&gt; boardList = boardDAO.getBoardList(vo);
    %&gt;
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html; charset=EUC-KR&#39;&gt;
    &lt;title&gt;글 목록&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;center&gt;
            &lt;h1&gt;게시글 목록&lt;/h1&gt;
            &lt;h3&gt;
                관리자userName님 로그인 환영합니다...... &lt;a href=&#39;logout_proc.jsp&#39;&gt;Log-out&lt;/a&gt;
            &lt;/h3&gt;
            &lt;!-- 검색 시작 --&gt;
            &lt;form action=&#39;getBoardList.jsp&#39; method=&#39;post&#39;&gt;
                &lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;
                    &lt;tr&gt;
                        &lt;td align=&#39;right&#39;&gt;&lt;select name=&#39;searchCondition&#39;&gt;
                                &lt;option value=&#39;TITLE&#39;&gt;제목
                                &lt;option value=&#39;CONTENT&#39;&gt;내용
                        &lt;/select&gt; &lt;input name=&#39;searchKeyword&#39; type=&#39;text&#39; /&gt; &lt;input type=&#39;submit&#39;
                            value=&#39;검색&#39; /&gt;&lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/table&gt;
            &lt;/form&gt;
            &lt;!-- 검색 종료 --&gt;
            &lt;table border=&#39;1&#39; cellpadding=&#39;0&#39; cellspacing=&#39;0&#39; width=&#39;700&#39;&gt;
                &lt;tr&gt;
                    &lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;번호&lt;/th&gt;
                    &lt;th bgcolor=&#39;orange&#39; width=&#39;200&#39;&gt;제목&lt;/th&gt;
                    &lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;작성자&lt;/th&gt;
                    &lt;th bgcolor=&#39;orange&#39; width=&#39;150&#39;&gt;등록일&lt;/th&gt;
                    &lt;th bgcolor=&#39;orange&#39; width=&#39;100&#39;&gt;조회수&lt;/th&gt;
                &lt;/tr&gt;
                &lt;% for(BoardVO board: boardList)  &#123;    %&gt;
                &lt;tr&gt;
                    &lt;td&gt;&lt;%=board.getSeq() %&gt;&lt;/td&gt;
                    &lt;td align=&#39;left&#39;&gt;&lt;%=board.getTitle() %&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;%=board.getWriter() %&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;%=board.getRegDate() %&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;%=board.getCnt() %&gt;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;%&#125; %&gt;
            &lt;/table&gt;
            &lt;br&gt; &lt;a href=&#39;insertBoard.html&#39;&gt;새글 등록&lt;/a&gt;
        &lt;/center&gt;
    &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<p>  와 같이 효율적으로 작성됨을 알 수 있습니다.<br>필터 왜 init, destory 오버라이딩 해야 한댓지?</p>
<ul>
<li></li>
</ul>
<p>상세, 수정, 삭제 마무리하기</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/23/Spring/fastcampus/day_5/" data-id="ckhvlt7zb0000psv15xa2ebwz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/20/Spring/fastcampus/day_4/" class="article-date">
  <time datetime="2020-11-20T05:06:16.000Z" itemprop="datePublished">2020-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-4/">day_4</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/20/Spring/fastcampus/day_4/">day_4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/99761730-2b54b000-2b3a-11eb-81e5-45220b5e1f9e.png" alt="image"><br>다른 사람의 코드와 비교하지말고 오직 어제의 나와 비교하라 - Jordan Peterson</p>
<h1 id="ServletProject"><a href="#ServletProject" class="headerlink" title="ServletProject"></a>ServletProject</h1><p>라 쓰고 토할것 같다고 읽습니다.</p>
<ul>
<li><h2 id="프로젝트-구조를-중심으로-리뷰합니다-당근-흔드는중"><a href="#프로젝트-구조를-중심으로-리뷰합니다-당근-흔드는중" class="headerlink" title="프로젝트 구조를 중심으로 리뷰합니다. (당근 흔드는중)"></a>프로젝트 구조를 중심으로 리뷰합니다. (당근 흔드는중)</h2><p><img src="https://user-images.githubusercontent.com/50402288/99777401-8f38a200-2b55-11eb-92ab-156a7ddfaefa.png" alt="20201120172622"></p>
<p>천천히 하나씩 한번 해보겠습니다.</p>
<ol>
<li>biz.board package:<br>BoardDAO와 BoardVO가 들어있습니다. 복습을 잠깐 해보자면 VO: Value Object로써 값들을 모아두고 getter/setter를 롬복으로 만들어 두어 수정, 삭제, 추가에 대비하여 유지보수하기 편하도록 만들어 놓은 값들의 모음입니다<br>DAO: data access object로써 insert, delete, update, get등의 메소드를 모아놓은 컨트롤러입니다.<br>즉 board테이블을 컨트롤하기위한 변수들과 그 변수들을 컨트롤 할 메소드를 모아놓은 패키지입니다.</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>biz.common package:<br>JDBCUtil 클래스가 들어있으며 h2데이터베이스와 커넥션을 연결/해제하는 메소드가 포함된 클래스입니다. board/users 테이블에서 자료를 추가, 수정, 삭제, 업데이트할 때 일일이 커넥션을 연결/해제하는 코드를 써 줄 수 없으니 해당 패키지에 미리 정의하여 두었습니다.</p>
</li>
<li><p>biz.user package:<br>앞서 1.에서 board테이블을 관리하는 용도와 같습니다.</p>
</li>
</ol>
<p>3.web.board:<br>board테이블과 관련된 서블릿들이 모여있는 패키지입니다.</p>
<p>4.web.common:<br>모든 서블릿에서 공통으로 쓰이는 Filter클래스를 가지고 있습니다.</p>
<p>5.web.user:<br>유저 테이블과 관련된 서블릿이 담겨있습니다.<br>이제 하나씩 보도록 합시다.</p>
<h2 id="주의-import와-패키지경로-자세한-코드내용은-저번-리뷰와-연관시-삭제했습니다-너무길거든요"><a href="#주의-import와-패키지경로-자세한-코드내용은-저번-리뷰와-연관시-삭제했습니다-너무길거든요" class="headerlink" title="주의:import와 패키지경로, 자세한 코드내용은 저번 리뷰와 연관시 삭제했습니다. 너무길거든요"></a>주의:import와 패키지경로, 자세한 코드내용은 저번 리뷰와 연관시 삭제했습니다. 너무길거든요</h2><h2 id="1-biz-board"><a href="#1-biz-board" class="headerlink" title="1. biz.board"></a>1. biz.board</h2><h3 id="boardVO-java"><a href="#boardVO-java" class="headerlink" title="boardVO.java"></a>boardVO.java</h3><pre><code>@Data
public class BoardVO &#123;
    private int seq;
    private String title;
    private String writer;
    private String content;
    private Date regDate;
    private int cnt;
    private String password;
&#125;</code></pre>
<h2 id="관련-변수들과-lombok으로-getter-setter가-모두-정의되어-있어-편리합니다"><a href="#관련-변수들과-lombok으로-getter-setter가-모두-정의되어-있어-편리합니다" class="headerlink" title="관련 변수들과 lombok으로 getter/setter가 모두 정의되어 있어 편리합니다."></a>관련 변수들과 lombok으로 getter/setter가 모두 정의되어 있어 편리합니다.</h2><h3 id="boardDAO-java"><a href="#boardDAO-java" class="headerlink" title="boardDAO.java"></a>boardDAO.java</h3><pre><code>    private static final String BOARD_INSERT = &quot;insert into board(seq, title, writer, content)&quot; + &quot;values((select nvl(max(seq), 0) +       &quot;
            + &quot;1 from board),?, ?, ?)&quot;;
    private static final String BOARD_UPDATE = &quot;UPDATE BOARD SET TITLE=?, CONTENT=? WHERE SEQ=?&quot;;
    private static final String BOARD_DELETE = &quot;DELETE BOARD WHERE SEQ=?&quot;;
    private static final String BOARD_GET = &quot;SELECT * FROM BOARD WHERE SEQ=?&quot;;
    private static final String BOARD_LIST = &quot;SELECT * FROM BOARD ORDER BY SEQ ASC&quot;;
    private static final String BOARD_UPDATE_CNT = &quot;UPDATE BOARD SET CNT=CNT+1 WHERE SEQ=?&quot;;

    //BOARD 테이블 관련 CRUD 기능의 메소드
    //글 등록
    public void insertBoard(BoardVO vo) &#123;
    &#125;
    //글 수정
    public void updateBoard(BoardVO vo) &#123;
    &#125;
    //글 삭제
    public void deleteBoard(BoardVO vo) &#123;
    &#125;
    //글 상세 조회
    public BoardVO getBoard(BoardVO vo) &#123;
    &#125;
    //글 목록 검색
    public List&lt;BoardVO&gt; getBoardList() &#123;
   &#125;</code></pre>
<p>board 테이블을 컨트롤 하는데 필요한 모든 메소드가 정의되어 있습니다.</p>
<hr>
<h2 id="2-biz-common"><a href="#2-biz-common" class="headerlink" title="2. biz.common"></a>2. biz.common</h2><h3 id="JDBCUtil-java"><a href="#JDBCUtil-java" class="headerlink" title="JDBCUtil.java"></a>JDBCUtil.java</h3><pre><code>    public class JDBCUtil &#123;
    public static Connection getConnection() &#123;
            // 1. 드라이버 객체를 메모리에 로딩한다.
            // 2. Connection 객체를 획득한다.
    // Select 기능의 자원 해제
    public static void close(ResultSet rs, PreparedStatement stmt, Connection conn) &#123;
    &#125;

    // not select 기능의 자원 해제
    public static void close(PreparedStatement stmt, Connection conn) &#123;
&#125;</code></pre>
<p>드라이버를 메모리에 로딩, 커넥션을 획득하고 rs이 있는 경우의 close, 없는 경우의 close메소드가 정의되어 있습니다.</p>
<hr>
<h2 id="3-biz-user"><a href="#3-biz-user" class="headerlink" title="3. biz.user"></a>3. biz.user</h2><h3 id="UserVO-java"><a href="#UserVO-java" class="headerlink" title="UserVO.java"></a>UserVO.java</h3><pre><code>@Data
public class UserVO &#123;
    private String id;
    private String password;
    private String name;
    private String role;
&#125;</code></pre>
<p>네 롬복이 캐리하구요</p>
<hr>
<h3 id="UserDAO-java"><a href="#UserDAO-java" class="headerlink" title="UserDAO.java"></a>UserDAO.java</h3><p>public class UserDAO {<br>    private Connection conn;<br>    private PreparedStatement stmt;<br>    private ResultSet rs;<br>    private static final String USER_INSERT = “insert into USERS values(?, ?, ?, ?)”;<br>    private static final String USER_GET = “SELECT * FROM USERS WHERE ID = ? and password = ?”;<br>    //회원 등록<br>    public void insertUsers(UserVO vo) {<br>    }<br>    //회원 상세조회<br>    public UserVO getUser(UserVO vo) {<br>    }<br>}<br>UserDAO는 insert, 상세조회 두가지의 메소드만 정의되어 있습니다.</p>
<hr>
<h2 id="4-web-Board"><a href="#4-web-Board" class="headerlink" title="4. web.Board"></a>4. web.Board</h2><h3 id="GetBoardListServer-java"><a href="#GetBoardListServer-java" class="headerlink" title="GetBoardListServer.java"></a>GetBoardListServer.java</h3><p>public class GetBoardListServlet extends HttpServlet {<br>    private static final long serialVersionUID = 1L;</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    BoardDAO boardDAO = new BoardDAO();
    List&lt;BoardVO&gt; list = boardDAO.getBoardList();

    response.setContentType(&quot;text/html; charset=EUC-KR&quot;);
    PrintWriter out = response.getWriter(); //출력 스트림

&lt;넘모 길어버리는 HTML코드는 이미지로 대체되는 마-법&gt;</code></pre>
<p><img src="https://user-images.githubusercontent.com/50402288/99780671-23a50380-2b5a-11eb-87bb-ad2e7a1e6ae7.png" alt="20201120175923"></p>
<pre><code>&#125;
&#125;</code></pre>
<h2 id="단순히-글-목록을-출력하는-코드입니다-딱히-볼-것은-없습니다"><a href="#단순히-글-목록을-출력하는-코드입니다-딱히-볼-것은-없습니다" class="headerlink" title="단순히 글 목록을 출력하는 코드입니다. 딱히 볼 것은 없습니다."></a>단순히 글 목록을 출력하는 코드입니다. 딱히 볼 것은 없습니다.</h2><h3 id="GetBoardServlet-java"><a href="#GetBoardServlet-java" class="headerlink" title="GetBoardServlet.java"></a>GetBoardServlet.java</h3><pre><code>public class GetBoardServlet extends HttpServlet &#123;
private static final long serialVersionUID = 1L;
private String encoding;

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    ServletContext context = getServletContext();
    encoding = context.getInitParameter(&quot;boardEncoding&quot;);

    //1.사용자 입력정보 추출
    response.setCharacterEncoding(encoding);
    //1. 사용자 입력정보 추출
    String seq = request.getParameter(&quot;seq&quot;);

    BoardVO vo = new BoardVO();
    vo.setSeq(Integer.parseInt(seq));

    BoardDAO dao = new BoardDAO();
    BoardVO board = dao.getBoard(vo);

    PrintWriter out = response.getWriter();</code></pre>
<p><img src="https://user-images.githubusercontent.com/50402288/99780015-3e2aad00-2b59-11eb-9293-ce943103ab9a.png" alt="20201120175256"></p>
<pre><code>&#125;
&#125;</code></pre>
<p>  seq의 정보를 넘겨받아서 해당 글의 상세정보를 출력하는 클래스입니다.</p>
<hr>
<h3 id="InsertBoardServlet-java"><a href="#InsertBoardServlet-java" class="headerlink" title="InsertBoardServlet.java"></a>InsertBoardServlet.java</h3><p>public class InsertBoardServlet extends HttpServlet {<br>    private static final long serialVersionUID = 1L;<br>    private String encoding;</p>
<pre><code>protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    //0. 글로벌 파라미터 정보 추출
    ServletContext context = getServletContext();
    encoding = context.getInitParameter(&quot;boardEncoding&quot;);

    //1.사용자 입력정보 추출
    request.setCharacterEncoding(encoding);
    BoardVO vo = new BoardVO();
    vo.setTitle(request.getParameter(&quot;title&quot;));
    vo.setWriter(request.getParameter(&quot;writer&quot;));
    vo.setContent(request.getParameter(&quot;content&quot;));

    BoardDAO dao = new BoardDAO();
    dao.insertBoard(vo);

    //3.화면 네비게이션
    response.sendRedirect(&quot;getBoardList.do&quot;);
&#125;</code></pre>
<p>}<br>String encoding은 인코딩 타입을 결정해 줄 것입니다. getServletContext() 메소드는 web.xml파일에접근하여 모든 서블릿에서 쓸 수 있는 파라미터 정보를 얻어와서 context변수에 저장합니다.<br>그래서 encoding 에 문자열 형태로 넣어주며 setCharacterEncoding함수에 파라미터로 넣어줌으로써 인코딩 형태를 결정합니다. 이것을 풀어쓰면 아래와 같습니다.</p>
<pre><code>response.setContentType(&quot;text/html; charset=EUC-KR&quot;);</code></pre>
<p>또한 이어지는 코드는  xml에 정의되어 있는 (서블릿에 대한)전역 파라미터의 형태입니다.</p>
<pre><code>&lt;context-param&gt;
    &lt;param-name&gt;boardEncoding&lt;/param-name&gt;
    &lt;param-value&gt;EUC-KR&lt;/param-value&gt;
  &lt;/context-param&gt;</code></pre>
<p>boardEncoding인 이름을 가지고 있으며 그 값은 EUC-KR입니다. 마치 key-value의 형태와 같습니다.<br><img src="https://user-images.githubusercontent.com/50402288/99780015-3e2aad00-2b59-11eb-9293-ce943103ab9a.png" alt="20201120175256"></p>
<p>이 화면에서 글 등록을 누르면 InsertBoardServlet이 호출되는데요 코드에서처럼, Title, Writer, Context정보를 받아서 DAO를 통해 값을 넣는 것을 알 수 있습니다. 마지막 화면 네이게이션에서는 insert를 마치고 나면 다시 글 목록으로 돌아가라는 명령을 내리고 있습니다.</p>
<hr>
<h3 id="DeleteBoardServlet-java"><a href="#DeleteBoardServlet-java" class="headerlink" title="DeleteBoardServlet.java"></a>DeleteBoardServlet.java</h3><pre><code>public class DeleteBoardServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //1.사용자 입력 정보 추출
        request.setCharacterEncoding(&quot;EUC-KR&quot;);
        String seq = request.getParameter(&quot;seq&quot;);
        //2.DB연동 처리
        BoardVO vo = new BoardVO();
        vo.setSeq(Integer.parseInt(seq));

        BoardDAO boardDAO = new BoardDAO();
        boardDAO.deleteBoard(vo);

        //3.화면 네비게이션
        response.sendRedirect(&quot;getBoardList.do&quot;);
    &#125;
&#125;</code></pre>
<p>seq정보를 넘겨받아 해당글을 삭제하고, 다시 글 목록으로 돌아가는 것을 알 수 있습니다.</p>
<h3 id="UpdateBoardServlet-java"><a href="#UpdateBoardServlet-java" class="headerlink" title="UpdateBoardServlet.java"></a>UpdateBoardServlet.java</h3><pre><code>public class UpdateBoardServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;
//    private String encoding;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        //0. 글로벌 파라미터 정보 추출
//        ServletContext context = getServletContext();//부모로부터 상속된 메소드
//        encoding = context.getInitParameter(&quot;boardEncoding&quot;);//서블릿 컨텍스트는 글로벌 파라미터
//
//        //1.사용자 입력 정보 추출
//        request.setCharacterEncoding(encoding);
        String title = request.getParameter(&quot;title&quot;);
        String seq = request.getParameter(&quot;seq&quot;);
        String content = request.getParameter(&quot;content&quot;);
        //2.DB연동 처리
        BoardVO vo = new BoardVO();
        vo.setTitle(title);
        vo.setSeq(Integer.parseInt(seq));
        vo.setContent(content);

        BoardDAO boardDAO = new BoardDAO();
        boardDAO.updateBoard(vo);

        //3.화면 네비게이션
        response.sendRedirect(&quot;getBoardList.do&quot;);
    &#125;

&#125;</code></pre>
<p>앞의 방식의 반복인 것을 알 수있습니다. 글로벌 파라미터에서 인코딩 형태를 추출해서 적용하며, 사용자입력정보를 추출합니다. 추출된 정보를 vo에 넣어주고 vo를 dao를 통해 DB에 연동해서 updateBoard(); 메소드를 통해 업데이트 시켜준 뒤 다시 목록으로 돌아오는 것을 볼 수 있습니다.</p>
<h2 id="5-web-common"><a href="#5-web-common" class="headerlink" title="5. web.common"></a>5. web.common</h2><p> web.common 패키지에는 현재까지 배운 바로는 크게 두가지 형태의 파일이 옵니다. 첫 번째는 필터이고 두 번째는 서블릿 엔진 리스너입니다.</p>
<ul>
<li>필터: *.do 의 형태가 일반적이며 이 경우 모든 .do URI 를 가지고 있는 서블릿이 호출 되기 전에 먼저 호출되며 FilterChain으로 통해 다음 필터에게 주도권을(이거 뭐라고 대체할까) 넘긴다음 다음 필터가 없다면 서블릿을 실행시킨다.</li>
<li>서블릿 엔진 리스너: 서블릿 엔진을 다음으로 우선순위의 실행순서를 가지며, 서블릿 엔진이 실행된 이후 제일 먼저 실행되고 서블릿 엔진이 삭제 되기 전 제일 마지막으로 실행된다, <em>오늘 질문</em>: 그럼 위에 서블릿에서 따로 인코딩형식 왜지정해준거지? .do호출하기전에 필터에서 다 설정해주잖아?</li>
<li></li>
</ul>
<h3 id="CharacterEncodingFilter-java"><a href="#CharacterEncodingFilter-java" class="headerlink" title="CharacterEncodingFilter.java"></a>CharacterEncodingFilter.java</h3><p>브라우저 서버쪽에 get방식으로 요청할 것이 명확하다면 doGet()만 오버라이딩한다.<br>반대로 Post방식으로 요청할 것이 확신이 되면 doPost()만 오버라이딩한다.( service도 필요없다는 뜻)</p>
<p>do get판단 안되거나 상관없는 경우 service()만 오버라이딩한다<br>destroy는 서블릿 객체가 삭제되기 직전에 호출된다</p>
<p>서블릿 객체, 서블릿 메소드도 다 서블릿 엔진이 호출해준다.<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>        System.out.println(“===&gt; doPostd() 호출”);<br>    }<br>     req 객체와 rep객체가 있어야 제대로 작동하지 않는가? -&gt; 매게변수 또한 서블릿 엔진이 생성해서 준다.<br>     브라우저가 서버에 전달한 요청 프로토콜 온갖 정보들을 req객체에 담아서 넘겨준다. req.getParameter(“id”)하면 아이디나옴, 즉 요청 프로토콜을 받아서 req을 생성한다.<br>     response 중에서는<br>     setContentType, getWriter, sendRedirect만 알면 된다<br>     setContent : 한글이 있을 경우 인코딩 지정해줌<br>     getWriter : 는 응답 프로토콜 body와 연관된 출력 스트림이다.<br>     sendRedirect: 다시 페이지 요청<br>서블릿은 안에 html이 포함되고 html로 디자인까지 다바꾸려면 지옥이다 때문에 jsp가 나왔다.<br>이 게시판 만드는데 필요한 기술은 sql, jdbc, html, servlet<br>req.getSession()무지 중요</p>
<p>서블릿은 브라우저가 요청할때 생성 -&gt;lazy-loading<br>Filter는 pre-Loading 요청이 필요없어 서블릿 엔진이 web.xml을 읽자 마자 생성되는 거야.<br>실제 ~.do서블릿이 없어도 필터는 동작해(*.do)<br>init과 destroy  는 오버라이딩은 해놔야해 서블릿과 달라 서블릿은 부모가 클래스라서 오버라이딩 할지 안할지 자유지만<br>필터는 달라 강제야 왜 ? (doFilter까지 합쳐서) dofilter가 제일 중요해 모든 .do에서 doFilter가 주구장창 실행되니까 젤중요해</p>
<p>필터가 중간에 .do요청을 가로채 그래서 사전처리 하고 chain,doFilter(req, res)(이 req, res를 doget으로 줌)호출되면 그 순간 클라이언트가 호출한 서블릿의 메소드가 실행되고(doGet)그러고 나면 제어권을 다시 필터로 돌아오고 사후처리 로직이 동작한다. 그 응답이 필터에서 브라우저로 들어간다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/20/Spring/fastcampus/day_4/" data-id="ckhu1z0e70000n8v105hfcuto" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/19/Spring/fastcampus/day_3/" class="article-date">
  <time datetime="2020-11-19T03:08:11.000Z" itemprop="datePublished">2020-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-3/">day_3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/19/Spring/fastcampus/day_3/">day_3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/99616265-405d1080-2a60-11eb-9812-a4cf24f50e5b.png" alt="image"></p>
<p>코드를 쓰기 전 당신 자신에게 다음과 같은 질문을 해보라. 즉 나는 이 서버가  늙어서도 여전히 유지보수를 잘 할 수 있을까? - Nietzsche</p>
<hr>
<h2 id="톰켓과-서블릿엔진"><a href="#톰켓과-서블릿엔진" class="headerlink" title="톰켓과 서블릿엔진"></a>톰켓과 서블릿엔진</h2><p>톰켓 서버 실행하면 new Tomcat() 객체가 생성이 되는거다<br>new Tomcat()은 new ServletEngin(web.xml)객체를 생성하는 코드를 가지고 있다</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>HTTP: Hyper Text Transfer Protocol) = 웹 서버와 웹 클라이언트(Browser)간에 통신하기 위한 프로토콜(통신 규약)이다.</li>
<li>HTTP 구조: 1. Start-line, 2. Message-header, 3. Message-body</li>
</ul>
<h3 id="브라우저의-요청-프로토콜"><a href="#브라우저의-요청-프로토콜" class="headerlink" title="브라우저의 요청 프로토콜"></a>브라우저의 요청 프로토콜</h3><p><img src="https://user-images.githubusercontent.com/50402288/99617535-e01b9e00-2a62-11eb-88b4-07a14e242672.png" alt="20201119122912"></p>
<ul>
<li>브라우저는 링크, 버튼, URL을 통해 서버에 요청 프로토콜을 보낸다.</li>
</ul>
<p>1.스타트 라인은 세가지 데이터로 구성이 된다. 첫번째는 요청방식(Get/ Post), 두 번째는 URI(포트번호 기준으로 그 뒤, ?표 전까지), 마지막 세 번째는 http프로토콜 버전인데 이것은 중요하지 않다.<br>2.메시지 헤더는 브라우저마다 다르다. 때문에 이것 역시 중요하지 않다.<br>3.메시지 바디는 사용자가 입력한 값이 딸려온다.(요청방식이 post)일 때만</p>
<h3 id="서버의-응답-프로토콜"><a href="#서버의-응답-프로토콜" class="headerlink" title="서버의 응답 프로토콜"></a>서버의 응답 프로토콜</h3><p><img src="https://user-images.githubusercontent.com/50402288/99617682-28d35700-2a63-11eb-9934-6471e4dc7a1d.png" alt="20201119123122"></p>
<ul>
<li>서버는 응답 프로토콜을 만든다.</li>
</ul>
<ol>
<li><p>스타트 라인: http버전, 응답 상태코드(404, 405, 500), 응답 상태코드에 딸려가는 메시지(ex: ‘OK’)</p>
<ul>
<li><p>404: (톰캣 관할) 브라우저가 서버에 요청한 파일이 서버에 존재하지 않음(프로젝트안에 해당 파일이 없음), (서블릿 엔진 관할) 서블릿 엔진이 xml에 등록되지 않은 URI를 참조할 때. 아래 사진참고</p>
<pre><code>*  </code></pre>
<p><img src="https://user-images.githubusercontent.com/50402288/99617956-c29b0400-2a63-11eb-94bc-27c4c7b0cb58.png" alt="20201119123537"><br>URI패턴에 hello.do가 매핑되어 있다. 즉 웹페이지 주소에 해당 URI로 접속하면 hello.HelloServlet이 실행된다. 그런데 login.do나 연관없는 URI로 들어가면 서블릿엔진이 주소를 찾지 못하고 404를 출력한다.</p>
<ul>
<li>405: 요청방식을 서버가 지원하지 않을 때(ex: 아래 사진의 doPost가 정의되어 있지 않거나, doGet이 정의되어 있지 않거나)<ul>
<li><img src="https://user-images.githubusercontent.com/50402288/99618320-77cdbc00-2a64-11eb-935f-9b583868a477.png" alt="20201119124043"></li>
</ul>
</li>
</ul>
</li>
<li><p>500: internal server error 오류 (서버오류 like Arithmetic Exception)</p>
<ol start="2">
<li>메시지 헤더는 역시 여기서도 중요하지 않다.</li>
<li>메시지 바디: 브라우저가 요청한 문서가(html, img, etc…) 응답 프로토콜 바디쪽에 담겨서 전달된다.</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="서블릿의-특징"><a href="#서블릿의-특징" class="headerlink" title="서블릿의 특징"></a>서블릿의 특징</h2><ul>
<li>서블릿은 자바 클래스이다. 다만 서블릿 엔진에 의해서만 동작한다.(동작한다: 객체를 생성하고 실행한다.)</li>
<li>자바클래스 이기 때문에 플랫폼 독립성(Linux, Windows, Mac,,,), 서버 독립성(Zeus, Tomcat,,,)이다. 이 두가지를 이식성이라 하며 이식성이 매우 높을수록 좋은것이고 자바클래스이기 때문에 이식성이 매우 좋다.</li>
<li>확장성: 서블릿은 자바로 작성되기 때문에 다양한 벤더(회사)에서 제공하는 클래스 라이브러리를 이용할 수 있다.</li>
<li>멀티스레드: 서블릿은 멀티스레드로 동작하기 때문에 매우 효율적이다. 하지만 서블릿을 멀티스레드로 돌리는 것은 서블릿 엔진이기 때문에 개발자는 멀티스레드에 대해 관여하지 않아도 된다.</li>
<li>아무리 전세계에서 많은 요청프로토콜을 보내도 서블릿 엔진은 JVM 메모리(힙 영역) 에 서블릿객체를 하나만 생성한다. 서블릿 요청시 서블릿이 메모리에 없다면 서블릿을 메모리에 로딩한다. 아래 참고자료</li>
</ul>
<p>서블릿 특징: 서블릿은 자바 클래스다, 다만 서블릿 엔진에 의해서만 동작한다.(객체생성되고 실행된다)<br>자바클래스이기 때문에-플랫폼 독립성, 서버독립성이다. 이 두가지를 이식성이라 한다.<br>확장성- 서블릿은 자바로 작성되기 때문에 다양한 벤더(회사)에서 제공하는 클래스 라이브러리를 이용할 수 있다.<br>중요! 멀티스레드이다. 서블릿을 멀티쓰레드로 돌리는건 서블릿 엔진이기 때문에 개발자는 신경 안써도 된다.<br>서블릿 엔진은 web.xml을 로딩하면 thread pool을 생성한다(vector같은, ArrayList같은 쓰레드 객체 여러개가 저장되는 공간)<br>아무리 전세계에서 요청해도 서블릿 엔진은 메모리에 서블릿을 하나만 생성한다.<br>요청 서블릿이 메모리에 없다면 메모리에 서블릿을 로딩한다<br><img src="https://user-images.githubusercontent.com/50402288/99618908-a7c98f00-2a65-11eb-8b7f-156734f3d419.png" alt="20201119124916"></p>
<ul>
<li><p>처음에 클라이언트가 서블릿 엔진에 요청 프로토콜을 처리할 서블릿이 존재하는지 Servlet Request를 한다. 이 때 서블릿 엔진엔진이 가상메모리 위에 서블릿 객체가 로딩되어있는지 판단 후 로딩되어있지 않다면 서블릿 객체를 생성하고, 생성자를 생성하고, init()으로 생성자를 초기화 한후 쓰레드 풀에서 스레드를 할당해 service()를 호출 한다. 이때 서비스 메소드는 내부에 클라이언트의 요청방식이 Get 이었는지 Post였는지 분기를 통해 판단하고 그에 맞게 doGet()또는 doPost()를 실행한다.<br>이 때 두번째 클라이언트가 들어온다면 init()까지의 과정은 생략한다. 때문에 서버를 구동하기 전 한번 서블릿 객체를 로딩시켜 놔야 빠르다.</p>
<h2 id="서블릿-클래스-작성-규칙"><a href="#서블릿-클래스-작성-규칙" class="headerlink" title="서블릿 클래스 작성 규칙"></a>서블릿 클래스 작성 규칙</h2><h3 id="서블릿-클래스-작성-규칙-1"><a href="#서블릿-클래스-작성-규칙-1" class="headerlink" title="서블릿 클래스 작성 규칙"></a>서블릿 클래스 작성 규칙</h3><ol>
<li><p>HttpServlet 클래스를 상속해야 한다. 그래야 서블릿 클래스라고 인식할 수 있다(서블릿 엔진이 인식하고 이 클래스를 메모리에 생성한다)</p>
</li>
<li><p>public 클래스로 만들어야 한다. 서블릿 엔진이 접근할 수 있기 위해</p>
</li>
<li><p>default 생성자가 있어야 한다.</p>
</li>
<li><p>요청 방식(method) 에 따라 goGet이나 doPost를 재정의(Overriding)한다.</p>
</li>
<li><p>부모 HttpServlet 클래스의 메소드를 재정의 하지 않으면 상속된다.</p>
</li>
<li><p>중요한 것은 이클립스가 알아서 해준다.</p>
<ul>
<li><p>나는 서블릿클래스를 정의만 했지 HelloServleet bean = new HelloServlet 와 같이 객체 생성을 한 적이 없고 심지어</p>
</li>
<li><p>bean.doGet()메소드 호출한 적도 없지만 알아서 된다 -&gt; servlet엔진이 알아서 다해줘요@</p>
</li>
<li><p>서블릿 엔진은 실행될 때 web.xml을 파라미터로 받아온다.</p>
</li>
<li><p>톰캣은 자바로 구현이 되어있다. 톰캣을 실행하면 톰캣 클래스 객체가 생성이 되고 web.xml파일을 읽어서 서블릿 엔진이라는 객체가 생성이 되며 이 때 xml에 명시한 대로 서블릿 엔진이 서블릿 객체를 생성하고 실행까지 해준다.</p>
<p>public class HelloServlet extends HttpServlet {<br>private static final long serialVersionUID = 1L;</p>
<p>public HelloServlet() {</p>
<pre><code>System.out.println(&quot;===&gt; HelloServlet 객체 생성&quot;);</code></pre>
<p>}//hello.do페이지 들어오면(xml에 명시한 대로) HelloServlet을 실행한다.</p>
<p>public void init(ServletConfig config) throws ServletException {</p>
<pre><code>System.out.println(&quot;===&gt; init() 호출&quot;);</code></pre>
<p>}</p>
<p>protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {</p>
<pre><code>System.out.println(&quot;===&gt; service() 호출&quot;);</code></pre>
<p>}</p>
<p>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</p>
<pre><code>System.out.println(&quot;===&gt; doGet() 호출&quot;);</code></pre>
<p>}</p>
<p>protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</p>
<pre><code>System.out.println(&quot;===&gt; doPost() 호출&quot;);</code></pre>
<p>}</p>
<p>public void destroy() {</p>
<pre><code>System.out.println(&quot;===&gt; destroy() 호출&quot;);</code></pre>
<p>}<br>}</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li>서블릿 호출에는 두가지 방법이 있다. 링크, 버튼, URI 입력 시마다 서블릿을 새로 호출 또는 서블릿 객체를 계속 실행시켜놓고 작업이 변경될 때 마다 호출<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/50402288/99620049-07289e80-2a68-11eb-857a-2d87ab342982.png" alt="20201119130609"><br>위의 로그인 페이지에서 우리가 신경써야 할 부분은 </p>
<pre><code> &lt;form action=&quot;hello.do&quot; method=&quot;get&quot;&gt;</code></pre>
<p>기존의 <a target="_blank" rel="noopener" href="http://localhost:7777/httpProject/login.html">http://localhost:7777/httpProject/login.html</a> 에서<br>     로그인 버튼을 누르면 form 태그의 action에 명시한 대로<br>     <a target="_blank" rel="noopener" href="http://localhost:7777/httpProject/hello.do?id=&amp;password=">http://localhost:7777/httpProject/hello.do?id=&amp;password=</a><br>     즉 hello.do라는 URI가 추가 된 것을 볼 수 있고 ? 뒤에 내가 입력한 id와 passwor의 정보가 담겨있다는 것은 이것이 get방식이라는 것을 알려준다. 이 때 터미널에서는 무슨 일이 일어나는 지 보자.</p>
<p>public class HelloServlet extends HttpServlet {<br>    private static final long serialVersionUID = 1L;</p>
<pre><code>public HelloServlet() &#123;
    System.out.println(&quot;===&gt; HelloServlet 객체 생성&quot;);
&#125;

public void init(ServletConfig config) throws ServletException &#123;
    System.out.println(&quot;===&gt; init() 호출&quot;);
&#125;

protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    System.out.println(&quot;===&gt; service() 호출&quot;);
&#125;

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    System.out.println(&quot;===&gt; doGet() 호출&quot;);
&#125;


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    System.out.println(&quot;===&gt; doPost() 호출&quot;);
&#125;

public void destroy() &#123;
    System.out.println(&quot;===&gt; destroy() 호출&quot;);
&#125;
&#125;</code></pre>
<hr>
<pre><code>정보: 서비스 [Catalina]을(를) 시작합니다.
11월 19, 2020 1:00:36 오후 org.apache.catalina.core.StandardEngine startInternal
정보: 서버 엔진을 시작합니다: [Apache Tomcat/9.0.37]
11월 19, 2020 1:00:36 오후 org.apache.coyote.AbstractProtocol start
정보: 프로토콜 핸들러 [&quot;http-nio-7777&quot;]을(를) 시작합니다.
11월 19, 2020 1:00:36 오후 org.apache.catalina.startup.Catalina start
정보: 서버가 [244] 밀리초 내에 시작되었습니다.
===&gt; HelloServlet 객체 생성
===&gt; init() 호출
===&gt; service() 호출
===&gt; service() 호출
===&gt; service() 호출
===&gt; service() 호출</code></pre>
<ol>
<li>정보: 서비스 [Catalina]을(를) 시작합니다. : 톰캣이 구동되었다는 것을 알 수 있다.</li>
<li>정보: 서버 엔진을 시작합니다 : 톰캣은 서버엔진을 실행하는 코드를 갖고 있기에 톰캣이 서버엔진을 실행시켰다.</li>
<li>===&gt; HelloServlet 객체 생성: 서버엔진은 실행될 때 web.xml파일을 파라미터로 받는다. 이를 통해 해당 URI로 접속하면 서블릿 객체를 생성한다.</li>
<li>===&gt; init() 호출: 원칙적으로 서블릿 생성자는 파라미터를 받을 수 없다. 그래야만 서블릿 엔진이 서블릿 생성자를 인식할 수 있기 때문이다. 때문에 init()이라는 메소드를 통해 생성자를 초기화 시켜준다.</li>
<li>===&gt; service() 호출: 원래는 service()에서 doGet()을 호출할지 doPost()를 호출할지 분기한다. 하지만 위의 코드에서는 우리가 임의로 service()의 코드를 오버라이딩하였기 때문에 doGet()이나 doPost()가 호출되지 않는다.</li>
<li>이 때 HelloServlet.java의 파일을 수정해보자.</li>
</ol>
<pre><code>  .    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
            System.out.println(&quot;===&gt; service() 호출&quot;);
        &#125;</code></pre>
<p>해당 메소드를 지워보면 터미널에</p>
<pre><code>11월 19, 2020 1:26:28 오후 org.apache.catalina.core.StandardContext    reload
정보: 이름이 [/httpProject]인 컨텍스트를 다시 로드하는 작업이 시작되었습니다.
===&gt; destroy() 호출
이러한 메시지가 뜬다. 즉 코드가 수정되면 라이프사이클이 끝나 destory()를 호출하여 서블릿 객체를 메모리상에서 지우고 다시 새로운 서블릿 객체를 만든다는 것을 알 수 있다. 또는 서버가 종료되면 destroy()메소드를 호출한다.</code></pre>
<h3 id="헷갈리는-서블릿-개념-때려잡기"><a href="#헷갈리는-서블릿-개념-때려잡기" class="headerlink" title="헷갈리는 서블릿 개념 때려잡기"></a>헷갈리는 서블릿 개념 때려잡기</h3><p> 서블릿 객체는 서버가 실행되면 단 하나 실행되어 서버가 종료되거나 코드가 변경되어 업데이트 시키기 전까지(서블릿을 새로 생성하기 전까지) 생존한다. 이 서블릿객체 하나에서 멀티쓰레드로 쓰레드풀에서 쓰레드를 하나씩 가져와서 클라이언트의 요청을 처리한다. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/19/Spring/fastcampus/day_3/" data-id="ckhocdjsk0000psv1a4vm73uz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/18/Spring/fastcampus/day_2/" class="article-date">
  <time datetime="2020-11-18T06:35:24.000Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-2/">day_2</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/18/Spring/fastcampus/day_2/">day_2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/99493926-77c1b380-29b3-11eb-8355-7ee6b9e55252.png" alt="image"></p>
<p>나의 자바의 한계는 나의 세계의 한계를 뜻한다. -Wittgenstein</p>
<h1 id="이클립스-다이나믹-웹-프로젝트"><a href="#이클립스-다이나믹-웹-프로젝트" class="headerlink" title="이클립스 다이나믹 웹 프로젝트"></a>이클립스 다이나믹 웹 프로젝트</h1><ul>
<li>DAO: Data Access Object</li>
<li>VO: Value Object</li>
<li>H2: 데이터 베이스 </li>
<li>Lombok: Getter/Setter 자동  생성라이브러리</li>
</ul>
<hr>
<h2 id="BoardVO-java"><a href="#BoardVO-java" class="headerlink" title="BoardVO.java"></a>BoardVO.java</h2><pre><code>@Data
public class BoardVO &#123;//Value Object 의 값들로는 순서, 타이틀, 작성자, 내용, 날짜, 조회수, 패스워드
private int seq;
private String title;
private String writer;
private String content;
private Date regDate;
private int cnt;
private String password;
&#125;</code></pre>
<hr>
<ul>
<li>Lombok을 이용한 Value Object 관리 실제로 각 필드 변수의 Getter/Setter가 모두 형성되어 있고, 변수 이름이 바뀌거나 추가되어도 자동으로 세팅되어 매우 편하다.<br><img src="https://user-images.githubusercontent.com/50402288/99500401-aba1d680-29bd-11eb-93f3-851b4485589e.png" alt="20201118164646"></li>
</ul>
<hr>
<h2 id="BoardDAO-java"><a href="#BoardDAO-java" class="headerlink" title="BoardDAO.java"></a>BoardDAO.java</h2><pre><code>    public class BoardDAO &#123;// Data access object

    private Connection conn;
    private PreparedStatement stmt;
    private ResultSet rs;
    private PreparedStatement stmt2;

    private static final String BOARD_INSERT = &quot;INSERT INTO BOARD(seq, title, writer, content)&quot;
            + &quot;values((select nvl(max(seq),0) + 1 from board), ?, ?, ?)&quot;;
    private static final String BOARD_LIST = &quot;Select * from board order by seq DESC&quot;;
    private static final String BOARD_UPDATE = &quot;update board set title = ?, content = ? where seq = ?&quot;;
    private static final String BOARD_GET = &quot;select * from board where seq = ?&quot;;
    private static final String BOARD_DELETE = &quot;delete board where seq = ?&quot;;
    private static final String BOARD_INCREASE = &quot;UPDATE BOARD SET CNT=CNT+1 WHERE SEQ=?&quot;;

    public void insertBoard(BoardVO vo) &#123; //vo객체를 받아서 데이터베이스에 추가
        try &#123;
            conn = JDBCUtil.getConnection();
            stmt = conn.prepareStatement(BOARD_INSERT);

            stmt.setString(1, vo.getTitle());
            stmt.setString(2, vo.getWriter());
            stmt.setString(3, vo.getContent());

            stmt.executeUpdate();
        &#125; catch (SQLException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtil.close(stmt, conn);
        &#125;

    &#125;

    public void deleteBoard(BoardVO vo) &#123; //vo 객체를 받아서 데이터 베이스 삭제
        try &#123;
            conn = JDBCUtil.getConnection();
            stmt = conn.prepareStatement(BOARD_DELETE);
            // 물음표에 값을 넣어줘야지
            stmt.setInt(1, vo.getSeq());

            stmt.executeUpdate();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtil.close(stmt, conn);
        &#125;

    &#125;

    public void updateBoard(BoardVO vo) &#123; //업데이트
        try &#123;
            conn = JDBCUtil.getConnection();
            stmt = conn.prepareStatement(BOARD_UPDATE);
            // 물음표에 값을 넣어줘야지
            stmt.setString(1, vo.getTitle());
            stmt.setString(2, vo.getContent());
            stmt.setInt(3, vo.getSeq());

            stmt.executeUpdate();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtil.close(stmt, conn);
        &#125;

    &#125;

    public List&lt;BoardVO&gt; getBoardList() &#123; //전체조회
        List&lt;BoardVO&gt; boardList = new ArrayList&lt;BoardVO&gt;();
        try &#123;
            conn = JDBCUtil.getConnection();
            stmt = conn.prepareStatement(BOARD_LIST);
            rs = stmt.executeQuery();
            while (rs.next()) &#123;
                BoardVO board = new BoardVO();
                board.setSeq(rs.getInt(&quot;SEQ&quot;));
                board.setTitle(rs.getString(&quot;TITLE&quot;));
                board.setWriter(rs.getString(&quot;WRITER&quot;));
                board.setContent(rs.getString(&quot;CONTENT&quot;));
                board.setRegDate(rs.getDate(&quot;REGDATE&quot;));
                board.setCnt(rs.getInt(&quot;CNT&quot;));
                boardList.add(board);
                System.out.println(rs.getInt(&quot;SEQ&quot;) + &quot; : &quot; + rs.getString(&quot;CONTENT&quot;));
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtil.close(rs, stmt, conn);
        &#125;
        return boardList;

    &#125;

    public BoardVO getBoard(BoardVO vo) &#123; //특정 조회
        BoardVO board = null;
        try &#123;
            conn = JDBCUtil.getConnection();
            stmt = conn.prepareStatement(BOARD_GET);
            stmt2 = conn.prepareStatement(BOARD_INCREASE);

            stmt2.setInt(1, vo.getSeq());
            stmt.setInt(1, vo.getSeq());

            stmt2.executeUpdate();
            rs = stmt.executeQuery();
            if (rs.next()) &#123;
                board = new BoardVO();
                board.setSeq(rs.getInt(&quot;SEQ&quot;));
                board.setTitle(rs.getString(&quot;TITLE&quot;));
                board.setWriter(rs.getString(&quot;WRITER&quot;));
                board.setContent(rs.getString(&quot;CONTENT&quot;));
                board.setRegDate(rs.getDate(&quot;REGDATE&quot;));
                board.setCnt(rs.getInt(&quot;CNT&quot;));
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            JDBCUtil.close(rs, stmt, conn);
            JDBCUtil.close(stmt2, conn);
        &#125;
        return board;
    &#125;
&#125;</code></pre>
<hr>
<h2 id="InsertBoardTest-java"><a href="#InsertBoardTest-java" class="headerlink" title="InsertBoardTest.java"></a>InsertBoardTest.java</h2><pre><code>public class InsertBoardTest &#123;//insert 는 title, writer랑 content정보가 필요해
    public static void main(String[] args) &#123;
        //data access object 와 data value를 선언해준다
        BoardDAO boardDAO = new BoardDAO();
        BoardVO vo = new BoardVO();
        vo.setTitle(&quot;타이틀&quot;);
        vo.setWriter(&quot;테스텉&quot;);
        vo.setContent(&quot;VO 내용...&quot;);

        boardDAO.insertBoard(vo);; //boardDAO로 insertObject명령어를 실행시키고 뭘 담아가서 실행시켜? -&gt; vo를 담아가서 실행시켜
        boardDAO.getBoardList(); // 마지막에 출력해주면 되지.

    &#125;
&#125;</code></pre>
<hr>
<h2 id="DeleteBoardTest-java"><a href="#DeleteBoardTest-java" class="headerlink" title="DeleteBoardTest.java"></a>DeleteBoardTest.java</h2><pre><code>public class DeleteBoardTest &#123;
public static void main(String[] args) &#123;
    BoardDAO boardDAO = new BoardDAO();
    BoardVO vo = new BoardVO();

    vo.setSeq(3);
    boardDAO.deleteBoard(vo);
    boardDAO.getBoardList();
&#125;
&#125;</code></pre>
<hr>
<h2 id="UpdateBoardTest-java"><a href="#UpdateBoardTest-java" class="headerlink" title="UpdateBoardTest.java"></a>UpdateBoardTest.java</h2><pre><code>public class UpdateBoardTest &#123;//업데이트에는 seq, title, content가 필요해
//data access object, Value object
public static void main(String[] args) &#123;
    BoardDAO boardDAO = new BoardDAO();
    BoardVO vo = new BoardVO();
    vo.setSeq(4);
    vo.setTitle(&quot;새로운 타이틀&quot;);
    vo.setContent(&quot;새로운 컨텐트&quot;);

    boardDAO.updateBoard(vo);
    BoardVO board = boardDAO.getBoard(vo);
    System.out.println(board.getSeq() + &quot;번 게시 글의 상세 정보&quot;);
    System.out.println(&quot;제목 : &quot; + board.getTitle());
    System.out.println(&quot;작성자 : &quot; + board.getWriter());
    System.out.println(&quot;내용 : &quot; + board.getContent());
    System.out.println(&quot;등록일 : &quot; + board.getRegDate());
    System.out.println(&quot;조회수 : &quot; + board.getCnt());

&#125;
&#125;</code></pre>
<hr>
<h2 id="GetBoardList-java"><a href="#GetBoardList-java" class="headerlink" title="GetBoardList.java"></a>GetBoardList.java</h2><pre><code>public class GetBoardList &#123;
public static void main(String[] args) &#123;
    BoardDAO boardDAO = new BoardDAO();
    BoardVO vo = new BoardVO();

    List&lt;BoardVO&gt; list = new ArrayList&lt;BoardVO&gt;();
    list = boardDAO.getBoardList();
    for (BoardVO board : list) &#123;
        System.out.print(&quot;제목: &quot; + board.getTitle());
        System.out.println(&quot; 조회수: &quot; + board.getCnt());
    &#125;
    System.out.println(&quot;총 글 수 : &quot; + list.size());
&#125;
&#125;</code></pre>
<hr>
<h2 id="GetBoardTest-java"><a href="#GetBoardTest-java" class="headerlink" title="GetBoardTest.java"></a>GetBoardTest.java</h2><pre><code>public class GetBoardTest &#123;
public static void main(String[] args) &#123;
    BoardDAO boardDAO = new BoardDAO();
    BoardVO vo = new BoardVO();

    vo.setSeq(4);
    vo = boardDAO.getBoard(vo);
    System.out.println(vo.getSeq() + &quot;번 글의 상세정보&quot;);
    System.out.println(&quot;제목:  &quot;+vo.getTitle());
    System.out.println(&quot;작성자: &quot; + vo.getWriter());
    System.out.println(&quot;내용: &quot; + vo.getContent());
    System.out.println(&quot;등록일: &quot; + vo.getRegDate());
    System.out.println(&quot;조회수: &quot; + vo.getCnt());
&#125;
&#125;</code></pre>
<hr>
<h2 id="JDBCUtil-java"><a href="#JDBCUtil-java" class="headerlink" title="JDBCUtil.java"></a>JDBCUtil.java</h2><ul>
<li>일일히 커넥션 만들고 닫고 할 수 없으니 따로 분리 시켜 놓은 클래스</li>
</ul>
<pre><code>  public class JDBCUtil &#123;

    public static Connection getConnection() &#123;
        try &#123;
   //            DriverManager.registerDriver(new org.h2.Driver());
            Class.forName(&quot;org.h2.Driver&quot;);
            return DriverManager.getConnection(&quot;jdbc:h2:tcp://localhost/~/test&quot;, &quot;sa&quot;, &quot;&quot;);

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

    public static void close(PreparedStatement stmt, Connection conn) &#123;
        try &#123;
            if(stmt != null) &#123;
                stmt.close();
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            stmt = null;
        &#125;
        try &#123;
            if(!conn.isClosed() &amp;&amp; conn != null)
                conn.close();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            conn = null;
        &#125;
    &#125;

    public static void close(ResultSet rs, PreparedStatement stmt, Connection conn) &#123;

        try &#123;
            if(rs != null) &#123;
                rs.close();
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            rs = null;
        &#125;
        try &#123;
            if(stmt != null) &#123;
                stmt.close();
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            stmt = null;
        &#125;
        try &#123;
            if(!conn.isClosed() &amp;&amp; conn != null)
                conn.close();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            conn = null;
        &#125;

    &#125;
  &#125;</code></pre>
<p>느낀점: 롬복 쩐다</p>
<p>+과제: 조회 할 때 마다 CNT(조회수)를 늘려보세요.(CNT 디폴트값: 0)<br>처음에 BoardDAO에 BOARD_GET쿼리 문에 “아무튼 쿼리문1”+”아무튼 쿼리문2”이렇게 하고 각각의 ?에 stmt.setInt(1, vo.getSeq()); stmt.setInt(2, vo.getSeq());할라 햇는데 아무튼 안되더라 -&gt; PreparedStatement객체를 두개 만들었다.</p>
<pre><code> private static final String BOARD_GET = &quot;select * from board where seq = ?&quot;;</code></pre>
<p>-&gt;</p>
<pre><code>private PreparedStatement stmt;
private PreparedStatement stmt2;</code></pre>
<hr>
<pre><code>private static final String BOARD_INCREASE = &quot;UPDATE BOARD SET CNT=CNT+1 WHERE SEQ=?&quot;;
private static final String BOARD_GET = &quot;select * from board where seq = ?&quot;;</code></pre>
<hr>
<pre><code>stmt = conn.prepareStatement(BOARD_GET);
stmt2 = conn.prepareStatement(BOARD_INCREASE);</code></pre>
<p>결과:<br><img src="https://user-images.githubusercontent.com/50402288/99501821-a2b20480-29bf-11eb-8f4a-49253d21280c.png" alt="20201118170049"></p>
<p>잘됩니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/18/Spring/fastcampus/day_2/" data-id="ckhn4bosf0000rwv12rvl9ech" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DAO/" rel="tag">DAO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lombok/" rel="tag">Lombok</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VO/" rel="tag">VO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/h2/" rel="tag">h2</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/fastcampus/day_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/17/Spring/fastcampus/day_1/" class="article-date">
  <time datetime="2020-11-17T07:05:51.000Z" itemprop="datePublished">2020-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/day-1/">day_1</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/17/Spring/fastcampus/day_1/">day_1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-images.githubusercontent.com/50402288/99357311-0caea900-28ef-11eb-9bcb-7e21b79d6a1d.png" alt="image"><br> 바보야, 문제는 다형성이야. - 빌 클린턴</p>
<h1 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h1><ul>
<li><p>유지보수  측면에서 다형성은 매우매우 중요합니다.</p>
<h2 id="ex1"><a href="#ex1" class="headerlink" title="ex1"></a>ex1</h2><ul>
<li>엘지티비와 삼성티비를 구현할겁니다 </li>
<li>다형성이 구현되어 있지 않을 경우</li>
</ul>
</li>
</ul>
<pre><code>public class LgTv &#123;  
        public LgTv() &#123;  
            System.out.println(&quot;===&gt; LgTv 생성&quot;);  
  &#125; //  
  public void turnOn() &#123;  
            System.out.println(&quot;LgTv---전원 켠다&quot;);  
  &#125;  
        public void turnOff() &#123;  
            System.out.println(&quot;LgTv---전원 끈다&quot;);  
  &#125;  
        public void soundUp() &#123;  
            System.out.println(&quot;LgTv---소리 올린다&quot;);  
  &#125;  
        public void soundDown() &#123;  
            System.out.println(&quot;LgTv---소리 내린다&quot;);  

  &#125;  
&#125;</code></pre>
<hr>
<pre><code>    public class SamsungTV &#123;  
    public SamsungTV() &#123;  
        System.out.println(&quot;===&gt; SamsungTV 생성&quot;);  
  &#125; //  
  public void powerOn() &#123;  
        System.out.println(&quot;SamsungTV---전원 켠다&quot;);  
  &#125;  
    public void powerOff() &#123;  
        System.out.println(&quot;SamsungTV---전원 끈다&quot;);  
  &#125;  
    public void volumeUp() &#123;  
        System.out.println(&quot;SamsungTV---소리 올린다&quot;);  
  &#125;  
    public void volumeDown() &#123;  
        System.out.println(&quot;SamsungTV---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<pre><code>SamsungTV tv = new SamsungTV();  
tv.powerOn();  
tv.powerOff();  
tv.volumeDown();  
tv.volumeUp();  
LgTv tv2 = new LgTv();  
tv2.soundDown();  
tv2.soundUp();  
tv2.turnOff();  
tv2.turnOn(); //뭐하러 이렇게 하냐 하나하나 다 뜯어고쳐야 되잖아</code></pre>
<p>써있는 것처럼 메소드 하나하나 다 뜯어 고쳐야 하니 힘들죠? 그죠?</p>
<h2 id="ex2"><a href="#ex2" class="headerlink" title="ex2"></a>ex2</h2><ul>
<li><h2 id="인터페이스를-구현한-경우"><a href="#인터페이스를-구현한-경우" class="headerlink" title="인터페이스를 구현한 경우"></a>인터페이스를 구현한 경우</h2><p>  public interface TV {  </p>
<pre><code>  void powerOn();  </code></pre>
<p>   void powerOff();  </p>
<p>   void volumeUp();  </p>
<p>   void volumeDown();<br>  }</p>
</li>
</ul>
<hr>
<pre><code>public class LgTv implements TV&#123;  
        public LgTv() &#123;  
            System.out.println(&quot;===&gt; LgTv 생성&quot;);  
  &#125; //  


  @Override  
  public void powerOn() &#123;  
        System.out.println(&quot;LgTv---전원 켠다&quot;);  
  &#125;  

    @Override  
  public void powerOff() &#123;  
        System.out.println(&quot;LgTv---전원 끈다&quot;);  
  &#125;  
    @Override  
  public void volumeUp() &#123;  
            System.out.println(&quot;LgTv---소리 올린다&quot;);  
  &#125;  

    @Override  
  public void volumeDown() &#123;  
            System.out.println(&quot;LgTv---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<pre><code>public class SamsungTV implements TV &#123;  
    public SamsungTV() &#123;  
        System.out.println(&quot;===&gt; SamsungTV 생성&quot;);  
  &#125; //  
  @Override  
  public void powerOn() &#123;  
        System.out.println(&quot;SamsungTV---전원 켠다&quot;);  
  &#125;  
    @Override  
  public void powerOff() &#123;  
        System.out.println(&quot;SamsungTV---전원 끈다&quot;);  
  &#125;  
    @Override  
  public void volumeUp() &#123;  
        System.out.println(&quot;SamsungTV---소리 올린다&quot;);  
  &#125;  
    @Override  
  public void volumeDown() &#123;  
        System.out.println(&quot;SamsungTV---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<pre><code>  public static void main(String[] args) &#123;  
  TV tv = new SamsungTV();  
  tv.powerOn();  
  tv.powerOff();  
  tv.volumeDown();  
  tv.volumeUp();  
  TV tv2 = new LgTv();  
  tv2.powerOn();  
  tv2.powerOff();  
  tv2.volumeDown();  
  tv2.volumeUp(); 
// Polymorhpism: one interface multiful implementation.  
 //어떻게 하면 클라이언트를 아예 안바꾸고 수정할 수 있을까 -&gt; 디자인 패턴  
  &#125;</code></pre>
<hr>
<h2 id="인터페이스를-사용해도-여전히-클라이언트-수정이-불가피합니다-그러면-gt-디자인패턴-Factory-Pattern-을-씁니다"><a href="#인터페이스를-사용해도-여전히-클라이언트-수정이-불가피합니다-그러면-gt-디자인패턴-Factory-Pattern-을-씁니다" class="headerlink" title="인터페이스를 사용해도 여전히 클라이언트 수정이 불가피합니다 그러면 -&gt; 디자인패턴(Factory Pattern)을 씁니다."></a>인터페이스를 사용해도 여전히 클라이언트 수정이 불가피합니다 그러면 -&gt; 디자인패턴(Factory Pattern)을 씁니다.</h2><h2 id="ex3"><a href="#ex3" class="headerlink" title="ex3"></a>ex3</h2><ul>
<li>팩토리 디자인 패턴을 구현한 경우</li>
</ul>
<hr>
<ul>
<li><h2 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h2><p>  public interface TV {<br>   void powerOn();  </p>
<p>   void powerOff();  </p>
<p>   void volumeUp();  </p>
<p>   void volumeDown();<br>  }</p>
</li>
</ul>
<hr>
<ul>
<li>엘지 티비</li>
</ul>
<hr>
<pre><code>public class LgTv implements TV &#123;  
        public LgTv() &#123;  
            System.out.println(&quot;===&gt; LgTv 생성&quot;);  
  &#125; //  


  @Override  
  public void powerOn() &#123;  
        System.out.println(&quot;LgTv---전원 켠다&quot;);  
  &#125;  

    @Override  
  public void powerOff() &#123;  
        System.out.println(&quot;LgTv---전원 끈다&quot;);  
  &#125;  
    @Override  
  public void volumeUp() &#123;  
            System.out.println(&quot;LgTv---소리 올린다&quot;);  
  &#125;  

    @Override  
  public void volumeDown() &#123;  
            System.out.println(&quot;LgTv---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<ul>
<li>삼성 티비</li>
</ul>
<hr>
<pre><code>  public class SamsungTV implements TV &#123;  
    public SamsungTV() &#123;  
        System.out.println(&quot;===&gt; SamsungTV 생성&quot;);  
  &#125; //  
  @Override  
  public void powerOn() &#123;  
        System.out.println(&quot;SamsungTV---전원 켠다&quot;);  
  &#125;  
    @Override  
  public void powerOff() &#123;  
        System.out.println(&quot;SamsungTV---전원 끈다&quot;);  
  &#125;  
    @Override  
  public void volumeUp() &#123;  
        System.out.println(&quot;SamsungTV---소리 올린다&quot;);  
  &#125;  
    @Override  
  public void volumeDown() &#123;  
        System.out.println(&quot;SamsungTV---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<ul>
<li>구글 티비</li>
</ul>
<hr>
<pre><code>public class GoogleTV implements TV &#123;  
    public GoogleTV() &#123;  
        System.out.println(&quot;===&gt; GoogleTV 생성&quot;);  
  &#125; //  
  @Override  
  public void powerOn() &#123;  
        System.out.println(&quot;GoogleTV---전원 켠다&quot;);  
  &#125;  
    @Override  
  public void powerOff() &#123;  
        System.out.println(&quot;GoogleTV---전원 끈다&quot;);  
  &#125;  
    @Override  
  public void volumeUp() &#123;  
        System.out.println(&quot;GoogleTV---소리 올린다&quot;);  
  &#125;  
    @Override  
  public void volumeDown() &#123;  
        System.out.println(&quot;GoogleTV---소리 내린다&quot;);  
  &#125;  
&#125;</code></pre>
<hr>
<ul>
<li>팩토리 패턴</li>
</ul>
<hr>
<pre><code>public class BeanFactory &#123;//Factory디자인 패턴  
  //Bean -&gt; 객체, BeanFactory:객체 공장  
  public Object getBean(String id) &#123;  
        if(id.equals(&quot;lg&quot;)) &#123;  
            return new LgTv();  
  &#125; else if(id.equals(&quot;samsung&quot;)) &#123;  
            return new SamsungTV();  
  &#125;  
        else if(id.equals(&quot;Google&quot;)) &#123;  
            return new GoogleTV();  
  &#125;//분기 계속 만들어줘야해 -&gt; Spring frame work로 간다!(자바 소스 안건드리고 유지보수가 가능하다.)  
  return null;  
  &#125;  
&#125;</code></pre>
<p>   <img src="https://user-images.githubusercontent.com/50402288/99366591-2aced600-28fc-11eb-90ca-72bef96101ad.png" alt="20201117174111"></p>
<p>(빨간색은 무시하세요 왜저럴까요) arg에 Google을 넣으면</p>
<hr>
<ul>
<li>TVUser</li>
</ul>
<hr>
<pre><code>public class TVUser3 &#123;  
    public static void main(String[] args) &#123;  
        BeanFactory factory = new BeanFactory();  

  TV tv = (TV) factory.getBean(args[0]);  
  tv.powerOff();  
  tv.powerOn();  
  tv.volumeDown();  
  tv.volumeUp();  
  &#125;  
&#125;</code></pre>
<p>  보이는 것처럼 args[0]에 Google이 들어가서 팩토리 패턴에 id에 Google을 넘겨주는 것을 알 수 있습니다. 그러면 우리는 클라이언트를 수정 할 필요 없이 서로다른 클래스를 args에 다른 문자열을 넣는것으로 생성 가능 합니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/17/Spring/fastcampus/day_1/" data-id="ckhlqimcn0008dov17lt9bkwd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Polymorphism/" rel="tag">Polymorphism</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/book/day_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/08/Spring/book/day_2/" class="article-date">
  <time datetime="2020-11-08T11:11:57.000Z" itemprop="datePublished">2020-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/til/">til</a>►<a class="article-category-link" href="/categories/Spring/til/day-2/">day_2</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/08/Spring/book/day_2/">day_2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="스프링-부트-시작하기"><a href="#스프링-부트-시작하기" class="headerlink" title="스프링 부트 시작하기"></a>스프링 부트 시작하기</h2><ul>
<li>Spring Initializer의 웹 인터페이스를 사용한다.</li>
<li>Spring Tool Suite에서 스프링 부트 프로젝트 만들기</li>
<li>IntelliJ에서 스프링 부트 프로젝트 새로 만들기</li>
<li>스프링 부트 CLI에서 Initializr사용<br>$ spring init<br>init 명령은 Initializr 웹 애플리케이션에 접속 후 demo.zip파일을 다운로드 한다. 이 프로젝트 파일의 압축을 풀면 메이븐의 pom.xml 빌드 명세가 들어있는 프로젝트 구조를 볼 수 있다. 메이븐의 빌드 명세는 스프링 부트와 테스트에 필요한 최소한의 스타터 의존성만으로 구성되어 있다.<br>$ spring init -dweb,jpa,security<br>데이터 영속성으로 JPA를 사용하고 스프링 시큐리티로 보안을 적용하는 웹 애플리케이션 명령이다.<br>명령을 실행하면 이전과 구조가 똑같은 demo.zip파일을 만드는데 스프링 부트의 웹, JPA, 시큐리티 스타터가 의존성으로 pom.xml에 포함된다. -d와 의존성 사이에는 공백이 없어야 한다는 점에 주의하자. 이 때 gradle로 만들고 싶다면<br>$ spring init -dewb,jpa,security –build gradle 이라고 해주면 됩니다.<br>$ spring init -dewb,jpa,security –build gradle -p war myapp<br>이 명령문의 의미는 프로젝트 압축파일을 myapp 디렉터리에 풀기를 원한다는 의미다. 생성된 프로젝트 압축 파일을 현재 디렉터리에 풀고 싶다면 –extract나 -x 매개 변수를 사용한다.( $ spring init -dweb,jpa,security –build gradle -p war -x<br>도움말은 $ spring help init<br>Spring Initializr 서비스가 지원하는 기능을 모두 확인하려면 $ spring init –list</li>
</ul>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><ul>
<li>스프링 부트는 프레임워크 자체에 저항을 최소화 하면서 스프링 애플리케이션을 개발할 수 있는 방법입니다.</li>
<li>자동 구성은 전통적인 스프링 애플리케이션에 있던 많은 보일러 플레이트 구성을 제거했다.</li>
<li>스프링 부트 스타터는 명시적인 라이브러리 이름이나 버전 대신에 스프링 부트가 제공하는 기능으로 빌드 의존성을 지정할 수 있게 했다.</li>
<li>스프링 부트 CLI는 명령줄에서 그루비를 사용하여 빠르고 간편하게 개발할 수 있게 하여 스프링 부트의 저항없는 개발모델을 완전히 새로운 수준으로 끌어올렸다.</li>
<li>액추에이터는 작동 중인 애플리케이션 내부를 살펴보면서 스프링 부트가 어떤 식으로 처리하는지 알 수 있게 했다.<br>@1장 끝@<h1 id="2장"><a href="#2장" class="headerlink" title="2장"></a>2장</h1><h2 id="스프링-부트-사용하기"><a href="#스프링-부트-사용하기" class="headerlink" title="스프링 부트 사용하기"></a>스프링 부트 사용하기</h2></li>
<li>애플리케이션을 최소한의 구성으로 빠르게 개발하려고 스프링 부트를 사용하는 것이다.</li>
<li>스프링 MVC(model-view-controller)로 웹 요청을 처리하고, Thymeleaf로 뷰를 정의하며 JPA로 데이터베이스 독서목록을 영속화 할 것이다. 일단은 내장 H2데이터베이스를 사용하자-&gt;이것이 뭔 소리냐 해석을 해보자<ul>
<li>Thymeleaf: html태그를 기반으로 하여 th: 속성을 이용하여 동적인 View를 제공합니다. 출처: <a target="_blank" rel="noopener" href="http://blog.naver.com/PostView.nhn?blogId=bgpoilkj&amp;logNo=221982228705&amp;parentCategoryNo=20&amp;categoryNo=&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postView">http://blog.naver.com/PostView.nhn?blogId=bgpoilkj&amp;logNo=221982228705&amp;parentCategoryNo=20&amp;categoryNo=&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postView</a></li>
<li>JPA: DB테이블과 자바 객체 사이의 매핑을 처리해ㅔ주는 ORM이란 기술의 표준이다. 따라서 JPA에는 객체와 DB사이의 매핑을 어떻게 설정하고 어떻게 동작해야 하는지 기술하고 있다. 즉 자바의 클래스와 DB의 테이블을 매핑하는 기술이다. 출처: <a target="_blank" rel="noopener" href="https://dev-troh.tistory.com/150">https://dev-troh.tistory.com/150</a></li>
<li>H2 Database: 자바 기반의 오픈소스 관계형 데이터 베이스 관리 시스템, 그냥 자바에 기본적으로 있는 데이터베이스라고 생각하면 될 것이다.<br><img src="https://user-images.githubusercontent.com/50402288/98490762-e301dc00-2275-11eb-91a5-22c7af18177a.png" alt="20201109102453"></li>
</ul>
</li>
<li>의존성으로  web, Thymeleaf, Security, JPA, H2, Actuator, DevTools를 넣었다.<h2 id="뭐가-들어있는지-살펴보자"><a href="#뭐가-들어있는지-살펴보자" class="headerlink" title="뭐가 들어있는지 살펴보자@@"></a>뭐가 들어있는지 살펴보자@@</h2><img src="https://user-images.githubusercontent.com/50402288/98491373-f2822480-2277-11eb-87f2-a459226ae5ea.png" alt="20201109103855"></li>
<li>build.gradle: 그래이들 빌드 명세</li>
<li>gradlew: 그래이들 래퍼<ul>
<li>그래이들 래퍼란? :</li>
<li>gradle wrapper*  줄여서 gradlew 는 새로운 환경에서 프로젝트를 설정할 때 java나 gradle을 설치하지 않고 바로 빌드할 수 있게 해주는 역할을 한다.<br>출처: <a target="_blank" rel="noopener" href="https://gihyun.com/120">https://gihyun.com/120</a> [Note]</li>
</ul>
</li>
<li>Demo2.Application: 애플리케이션의 부트스트랩 클래스이자 주 스트링 구성 클래스<ul>
<li>부트스트랩이란? : <img src="https://user-images.githubusercontent.com/50402288/98491886-91f3e700-2279-11eb-8be7-ba8e4c77049f.jpg" alt="다운로드"></li>
</ul>
</li>
</ul>
<ul>
<li>application.properties: 애플리케이션과 스프링 부트 프로퍼티를 구성하는 데 사용하는 파일</li>
<li>Demo2AookucatuibTests.java: 기본 통합 테스트 클래스 </li>
</ul>
<h3 id="스프링-부트스트래핑"><a href="#스프링-부트스트래핑" class="headerlink" title="스프링 부트스트래핑"></a>스프링 부트스트래핑</h3><p>Demo2Application 클래스는 스프링 부트 애플리케이션에서 구성과 부트 스트래핑 두 가지 역할을 담당한다. 첫째, 가장 중요한 스프링 구성 클래스다. 스프링 부트의 자동구성이 수많은 스프링 구성을 제거하지만, 자동 구성을 활성화하는 최소한의 구성은 해야한다.  해당 클래스의 내부를 보면 구성 코드는 단 한줄 뿐이다.</p>
<ul>
<li>실제 코드</li>
</ul>
<hr>
<pre><code>package com.example.demo2;  
import org.springframework.boot.SpringApplication;  
import org.springframework.boot.autoconfigure.SpringBootApplication;  
@SpringBootApplication  
public class Demo2Application &#123;  
   public static void main(String[] args) &#123;  
      SpringApplication.run(Demo2Application.class, args);  
  &#125;  
&#125;</code></pre>
<hr>
<p>여기서 @SpringBootApplication 애너테이션은 스프링 컴포넌트 검색과 스프링 부트 자동구성을 활성화 한다. 사실 @SpringBootApplication 애너테이션은 유용한 애너테이션 세 개를 묶은 것이다.</p>
<ul>
<li>@Configuration: 이 애너테이션이 붙은 클래스를 스프링의 자바 기반 구성 클래스로 지정한다. -&gt; 이게 무슨소린가요? 강사님한테 질문할것입니다.</li>
<li>@ComponentScan: 컴포넌트 검색 기능을 활성화해서 웹 컨트롤러 클래스나 다른 컴포넌트 클래스들을 자동으로 검색하여 스프링 애플리케이션 컨텍스트에 빈으로 등록시킨다. -&gt; 예제로 해볼 것입니다.</li>
<li>@EnableAutoConfiguration: 이 작은 애너테이션은 @Abracadabra라고 해도 무방하다. 이 구성 한 줄로 스프링 부트의 자동구성 마법이 일어나기 때문이다. 이것으로 수 많은 구성 코드를 대체할 수 있다.<h2 id="여기서-잠깐-WAR-JAR-그게뭔데"><a href="#여기서-잠깐-WAR-JAR-그게뭔데" class="headerlink" title="여기서 잠깐! WAR? JAR? 그게뭔데?"></a>여기서 잠깐! WAR? JAR? 그게뭔데?</h2>WAR: Web Application Archive<br>.war 확장자 파일은 servlet/ jsp 컨테이너에 배치할 수 있는 웹 어플리케이션 압축 파일 포맷입니다. JSP, SERVLET, JAR, CLASS, XML, THML, JAVASCRIPT 등 Servlet Context 관련 파일들로 패키징 되어 있습니다. WAR는 웹 응용프로그램을 위한 포맷이기 때문에 웹 관련 자원만 포함하고 있으며 이를 사용하면 웹 어플리케이션을 쉽게 배포하고 테스트 할 수 있습니다.<ul>
<li>여기서 또잠깐! Servlet, JSP는 뭐였더라?(복습)<ul>
<li>Servlet: 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술<ul>
<li>스프링의 DispatcherServlet을 선언한 web.xml파일 또는 WebApplicationInitializer구현<ul>
<li>JSP: JavaServer Pages의 약자이며, HTML코드에 JAVA코드를 넣어 동적 웹페이지를 생성하는 웹 어플리케이션 도구이다.<br>JSP가 실행되면 자바 Servlet으로 변환되며 웹 어플리케이션 서버에서 동작 되면서 필요한 기능을 수행하고 그렇게 생성된 데이터를 웹 페이지와 함께 클라이언트로 응답한다.<br>JAR: Java Archive<br>.jar 확장자는 파일에는 Class와 같은 Java 리소스와 속성파일, 라이브러리 및 액세서리 파일이 포함되어 있습니다. 쉽게 JAVA 어플리케이션이 동작할 수 있도록 자바 프로젝트를 압축한 파일로 생각하비면 되겠습니다. 실제로 JAR파일은 플랫폼에 귀속되는 점만 제외하면 WIN ZIP 파일과 동일한 구조입니다.<br>출처: <a target="_blank" rel="noopener" href="https://ifuwanna.tistory.com/224">https://ifuwanna.tistory.com/224</a> 항상 감사합니다 선배님들@@</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
앞에서 언급했듯이 Demo2Application은 부트스트랩 클래스이기도 하다. 전통적인 WAR파일 배포를 포함하여 스트링 부트 애플리케이션을 실행하는 방법은 여러가지다. 하지만 여기서는 main() 메서드가 명령줄에서 실행 가능한 JAR파일로 애플리케이션을 실행할 수 있게 한다. main() 메서드에서는 Demo2Application 클래스 참조와 명령줄 인자를 SpringApplication.run() 메서드에 전달하여 애플리케이션을 실행한다.<h3 id="gradle-bootRun"><a href="#gradle-bootRun" class="headerlink" title="gradle bootRun"></a>gradle bootRun</h3>bootRun 테스크는 스프링 부트 그레이들 플러그인에 포함되어 있다. 이것은 나중에 더 자세히 살펴본다. 이것은 아래의 코드와 동일하다<br>$ gradle build<br>$ graild -jar build/libs/readinglist-0.0.1-SNAPSHOT.jar<br>명령을 실행하면 애플리케이션이 정상적으로 작동하고 8080포트에서 수신하는 톰캣 서버가 작동해야 한다. 원한다면 웹 브라우저로 접속해도 된다. 하지만 아직 컨트롤러 클래스를 작성하지 않았기 때문에 404 오류가 뜰 것이다.<br>여기서 막혔어 gradle bootRun이 되지않아<br>‘gradle’은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는<br>배치 파일이 아닙니다.<br>나한테 왜이러는거야정말</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/08/Spring/book/day_2/" data-id="ckhlqimcm0007dov1coug2ece" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/day-2/" rel="tag">day_2</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/book/day_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/03/Spring/book/day_1/" class="article-date">
  <time datetime="2020-11-03T13:15:21.000Z" itemprop="datePublished">2020-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/til/">til</a>►<a class="article-category-link" href="/categories/Spring/til/day-1/">day_1</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/03/Spring/book/day_1/">day_1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="day-1"><a href="#day-1" class="headerlink" title="day_1"></a>day_1</h1><h2 id="스프링의-새로운-시작"><a href="#스프링의-새로운-시작" class="headerlink" title="스프링의 새로운 시작"></a>스프링의 새로운 시작</h2><ul>
<li>스프링은 JEE, J2EE 와 같은 자바 엔터프라이즈 에디션을 경량화 하기 위해 만들어짐<ul>
<li>의존성 주입과 관점 지향 프로그래밍을 활용해서 간단하게 엔터프라이즈 자바 개발에 접근<ul>
<li>엔터프라이즈 자바: 기업을 대상으로 하는, 매우 큰 규모의 환경을 구축하는 자바</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>초기 스프링: XML기반 -&gt; 애너테이션 기반</li>
</ul>
<ul>
<li>애플리케이션 로직 작성 대신 구성 작업에 쓰는 시간은 모두 낭비다!</li>
<li>의존성 라이브러리를 추가하는 것은 중요하지만 의존 라이브러리의 버전을 잘못 선택해서 발생하는 모든 호환성문제 -&gt; 스프링은 이것을 해결하였다.</li>
</ul>
<h2 id="Hello-World-웹-어플리케이션을-개발한다고-할-때-필요한-것들"><a href="#Hello-World-웹-어플리케이션을-개발한다고-할-때-필요한-것들" class="headerlink" title="Hello World 웹 어플리케이션을 개발한다고 할 때 필요한 것들"></a>Hello World 웹 어플리케이션을 개발한다고 할 때 필요한 것들</h2><ul>
<li><p>메이븐이나 그레이들 빌드 파일이 완비된 프로젝트 구조</p>
<ul>
<li>메이븐, 그레이들: 자바용 프로젝트 관리 도구</li>
</ul>
</li>
<li><p>스프링 MVC, 서블릿 API를 의존성으로 지정</p>
<ul>
<li>MVC: model - view - controller</li>
<li>Servlet: 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술</li>
</ul>
</li>
<li><p>스프링의 DispatcherServlet을 선언한 web.xml파일 또는 WebApplicationInitializer구현</p>
<ul>
<li>DispatcherServlet: Servlet Container에서 HTTP 프로토콜을 통해 들어오는 모든 요청을 프레젠테이션 계층의 제일 앞에 둬서 중앙집중식으로 처리해 주는 프론트 컨트롤러<ul>
<li>프론트 컨트롤러: 주로 서블릿 컨테이너의 제일 앞에서 서버로 들어오는 클라이언트의 모든 요청을 받아서 처리해 주는 컨트롤러, MVC 구조에서 함께 사용되는 패턴이다.</li>
</ul>
</li>
<li>XML파일: extensible Markup Language 즉 확장 가능한 마크업 언어, HTML과 같지만 임의로 태그를 만들 수 있는 언어</li>
</ul>
</li>
<li><p>스프링 MVC를 사용할 수 있는 스프링 구성</p>
</li>
<li><p>HTTP 요청에 “Hello World!” 라고 응답할 컨트롤러 클래스</p>
</li>
<li><p>애플리케이션을 배포할 웹 애플리케이션 서버(톰캣같은)</p>
<p>사실 상 개발자가 해야 할 것은 컨트롤러 작성 하나 뿐이다. 그렇다면 나머지는 ‘스프링’에게 맡기면 된다.<br>Groovy: java와 비슷한 하지만 약간 다른 언어</p>
</li>
</ul>
<h2 id="스프링-부트의-핵심-살펴보기"><a href="#스프링-부트의-핵심-살펴보기" class="headerlink" title="스프링 부트의 핵심 살펴보기"></a>스프링 부트의 핵심 살펴보기</h2><ul>
<li>자동구성: 많은 스프링 애플리케이션에서 공통으로 필요한 애플리케이션 기능을 자동으로 구성한다.</li>
<li>스타터 의존성: 스프링 부트에 어떤 기능이 필요한 지 알려주면 필요한 라이브러리를 빌드에 추가한다는 것을 보장한다.</li>
<li>명령줄 인터페이스: 이 부가기능을 이용하면 애플리케이션 코드만 작성해도 완전한 애플리케이션을 개발할 수 있다.</li>
<li>액추에이터: 스프링 부트 애플리케이션을 실행할 때 내부에서 어떤 일이 일어나는지 알 수 있다.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/11/03/Spring/book/day_1/" data-id="ckhlqimcc0000dov1eta3axw7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/day-1/" rel="tag">day_1</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/MultiThread(6)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/30/java/MultiThread(6)/" class="article-date">
  <time datetime="2020-10-29T23:44:34.000Z" itemprop="datePublished">2020-10-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/til/">til</a>►<a class="article-category-link" href="/categories/java/til/MultiThread/">MultiThread</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/30/java/MultiThread(6)/">MultiThread(6)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MultiThread-6"><a href="#MultiThread-6" class="headerlink" title="MultiThread(6)"></a>MultiThread(6)</h1><h1 id="synchronizedList"><a href="#synchronizedList" class="headerlink" title="synchronizedList"></a>synchronizedList</h1><pre><code>List&lt;Integer&gt; list1 = new Vector&lt;&gt;();  
List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();  
List&lt;Integer&gt; list3 = Collections.synchronizedList(list2);  
// list3: list2의 싱크된 버전  


for (int i = 0; i &lt; 1000; i++) &#123;  
    new Thread(() -&gt; &#123;  
        for (int j = 0; j &lt; 100; j++) &#123;  
            list1.add(1);  
  &#125;  
    &#125;).start();  
&#125;  

for (int i = 0; i &lt; 1000; i++) &#123;  
    new Thread(() -&gt; &#123;  
        for (int j = 0; j &lt; 100; j++) &#123;  
            list3.add(1);  
  &#125;  
    &#125;).start();  
&#125;  



Thread.sleep(1000);  

System.out.println(list1.size());  
System.out.println(list2.size());</code></pre>
<p>  리스트를 sync해서 쓸 수 있는데 대표적으로 우리가 아는 sync된 리스트는 Vector이다. 때문에 기본적으로 벡터는 다른 자료구조에 비해 느린 이유가 여기있다. 따로 Vector를 쓰지 않고 싱크된 자료구조를 쓰고 싶다면 위의 코드처럼 Collections.synchronizedList(list) 로 만들어 주면 될 것이다.</p>
<h1 id="쓰레드-풀-Thread-Pool"><a href="#쓰레드-풀-Thread-Pool" class="headerlink" title="쓰레드 풀(Thread Pool)"></a>쓰레드 풀(Thread Pool)</h1><p>  쓰레드는 생성하고 관리하기가 어렵다. 때문에 쓰레드 풀이란 것이있다. 이미 만들어진 쓰레드 뭉텅이에 SynchronousQueue(작업 큐)를 제출(submit)해주면 된다. 이 스레드 풀을 생성하는 방법은 Executors.newCachedThreadPool(), Executors.newFixedThreadPool(n),new ThreadPoolExecutor ( 여러가지 ) 이렇게 세 가지가 있으며 공통점은 작업큐를 제출할 때 작업큐는 Runnable객체 또는 Callable객체여야 한다는 것이다. 활용 예는 아래와 같다.</p>
<pre><code>public class Main &#123;  
    public static void main(String[] args) throws InterruptedException &#123;  
        ExecutorService pool1 = Executors.newCachedThreadPool();  
  /**  
 * newCachedThreadPool * - 초기 스레드가 0개 -&gt; 오버헤드가 없다.  
 * - 코어 스레드가 0개(일하지 않아도 살려두는 스레드)  
 * - 요청 작업보다 스레드가 부족하면 새 스레드를 생성  
  * - 60초 동안 일하지 않은 스레드는 제거  
  */  
  ExecutorService pool2 = Executors.newFixedThreadPool(10);  
  /**  
 *  newFixedThreadPool *  - 최대 스레드 nThread개  
  *  - 코어 스레드 nThread개  
  *  - 요청 작업보다 스레드가 부족하면 새 스레드 생성  
  *  - 작업하지 않는 스레드도 제거하지 않고 동작  
  */  

  ExecutorService es = new ThreadPoolExecutor (  
                10, //코어 스레드  
  100, // 최대 스레드 개수  
  120, // 스레드가 이 시간동안 일 하지 않으면 제거  
  TimeUnit.SECONDS,  
 new SynchronousQueue&lt;Runnable&gt;() // 요청 -&gt; 작업을 쌓아둔 큐 -&gt;스레드 풀  
  );  
  //2.스레드에 할당할 작업 생성  
  class Work implements Runnable &#123;  

            @Override  
  public void run() &#123;  
                for(int i = 0; i&lt; 100; i++) &#123;  
                    System.out.println(i);  
  &#125;  
            &#125;  
        &#125;  
        class CallableWork implements Callable&lt;String&gt; &#123;  

            @Override  
  public String call() throws Exception &#123;  
                return &quot;작업종료&quot;;  
  &#125;  
        &#125;  
        //3.스레드에 작업 요청  
  Future&lt;String&gt; future;  
  future=pool1.submit(new CallableWork());  
 for (int i = 0; i&lt;100; i++) &#123;  
            pool1.submit(new Work());  
 ;  &#125;//4. 스레드 종료(동기화)  
 //스레드 풀은 자동 종료가 안되기 때문에, 직접 스레드풀을 종료해 주어야 한다.  
  pool1.shutdown(); // Thread.join()과 마찬가지로 끝나길 기다려서 종료  
  Thread.sleep(1000);  
 try &#123;  
            System.out.println(future.get()); //get()은 Blocking method 즉59번 째 줄에 future에 값이 들어오기 전까진 get()에서 블러킹한다.  
 //get()을 영원히 기다릴 수 도 있음으로 timeout 설정 가능  
  future.cancel(true); //실행중인 Callable객체를 강제종료 인터럽트해서 강제종료  
  System.out.println(future.isCancelled());  
  System.out.println(future.isDone());  
  &#125; catch (InterruptedException e) &#123;  
            e.printStackTrace();  
  &#125; catch (ExecutionException e) &#123;  
            e.printStackTrace();  
  &#125;  
    &#125;  
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hansol-jeong.github.io/2020/10/30/java/MultiThread(6)/" data-id="ckh2ffo6k001ycov19h6ra8gu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MultiThread/" rel="tag">MultiThread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/Level1/">Level1</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/Level1/Crain/">Crain</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/Level1/One-Plus-One/">One_Plus_One</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/">MySQL</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/Quiz-1/">Quiz_1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/Quiz-2/">Quiz_2</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/day-1/">day_1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/day-2/">day_2</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/day-3/">day_3</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Front-End/">Front-End</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Front-End/day-1/">day_1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Front-End/day-2/">day_2</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Front-End/day-3/">day_3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Front-End/day-4/">day_4</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-1/">day_1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-2/">day_2</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-3/">day_3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-4/">day_4</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-5/">day_5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-6/">day_6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/day-7/">day_7</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/til/">til</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/til/day-1/">day_1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/til/day-2/">day_2</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/">til</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Abstract-Class/">Abstract_Class</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Annotations/">Annotations</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Arrays/">Arrays</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Class/">Class</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Conditional-Statements/">Conditional_Statements</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/DataType/">DataType</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Enum/">Enum</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Generic/">Generic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Handling-Exception/">Handling_Exception</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Inheritance/">Inheritance</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/InnerClasses/">InnerClasses</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Input-and-Output/">Input and Output</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Interface/">Interface</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/JCF/">JCF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Lambda/">Lambda</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Loops/">Loops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Modifier/">Modifier</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/MultiThread/">MultiThread</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/N-D-Arrays/">N-D_Arrays</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/OOP/">OOP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Package/">Package</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Polymorphism/">Polymorphism</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Polymorphism1/">Polymorphism1</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Regular-Expression/">Regular_Expression</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/StringTokenizer/">StringTokenizer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Strings/">Strings</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Variable/">Variable</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/Wrapper-Class/">Wrapper Class</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/til/java-lang/">java_lang</a></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Abstract-Class/" rel="tag">Abstract_Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Annotations/" rel="tag">Annotations</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arrays/" rel="tag">Arrays</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Class/" rel="tag">Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Conditional-Statements/" rel="tag">Conditional_Statements</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DAO/" rel="tag">DAO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataType/" rel="tag">DataType</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/" rel="tag">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Enum/" rel="tag">Enum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Front-End/" rel="tag">Front-End</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Generic/" rel="tag">Generic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handling-Exception/" rel="tag">Handling_Exception</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Inheritance/" rel="tag">Inheritance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/InnerClasses/" rel="tag">InnerClasses</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Input-and-Output/" rel="tag">Input and Output</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interface/" rel="tag">Interface</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JCF/" rel="tag">JCF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda/" rel="tag">Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Level1/" rel="tag">Level1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lombok/" rel="tag">Lombok</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Loops/" rel="tag">Loops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/" rel="tag">MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Modifier/" rel="tag">Modifier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MultiThread/" rel="tag">MultiThread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/N-D-Arrays/" rel="tag">N-D_Arrays</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOP/" rel="tag">OOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Package/" rel="tag">Package</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Polymorphism/" rel="tag">Polymorphism</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Programmers/" rel="tag">Programmers</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quiz-1/" rel="tag">Quiz_1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quiz-2/" rel="tag">Quiz_2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Regular-Expression/" rel="tag">Regular_Expression</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/StringTokenizer/" rel="tag">StringTokenizer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Strings/" rel="tag">Strings</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VO/" rel="tag">VO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Variable/" rel="tag">Variable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wrapper-Class/" rel="tag">Wrapper Class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/day-1/" rel="tag">day_1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/day-2/" rel="tag">day_2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/day-3/" rel="tag">day_3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/day-4/" rel="tag">day_4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h2/" rel="tag">h2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-lang/" rel="tag">java_lang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/til/" rel="tag">til</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Abstract-Class/" style="font-size: 10px;">Abstract_Class</a> <a href="/tags/Algorithm/" style="font-size: 11.25px;">Algorithm</a> <a href="/tags/Annotations/" style="font-size: 10px;">Annotations</a> <a href="/tags/Arrays/" style="font-size: 10px;">Arrays</a> <a href="/tags/CSS/" style="font-size: 13.75px;">CSS</a> <a href="/tags/Class/" style="font-size: 10px;">Class</a> <a href="/tags/Conditional-Statements/" style="font-size: 10px;">Conditional_Statements</a> <a href="/tags/DAO/" style="font-size: 10px;">DAO</a> <a href="/tags/DataType/" style="font-size: 10px;">DataType</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/Enum/" style="font-size: 10px;">Enum</a> <a href="/tags/Front-End/" style="font-size: 13.75px;">Front-End</a> <a href="/tags/Generic/" style="font-size: 10px;">Generic</a> <a href="/tags/HTML/" style="font-size: 13.75px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 12.5px;">HTTP</a> <a href="/tags/Handling-Exception/" style="font-size: 10px;">Handling_Exception</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Inheritance/" style="font-size: 10px;">Inheritance</a> <a href="/tags/InnerClasses/" style="font-size: 10px;">InnerClasses</a> <a href="/tags/Input-and-Output/" style="font-size: 10px;">Input and Output</a> <a href="/tags/Interface/" style="font-size: 10px;">Interface</a> <a href="/tags/JCF/" style="font-size: 13.75px;">JCF</a> <a href="/tags/JSP/" style="font-size: 11.25px;">JSP</a> <a href="/tags/Lambda/" style="font-size: 10px;">Lambda</a> <a href="/tags/Level1/" style="font-size: 11.25px;">Level1</a> <a href="/tags/Lombok/" style="font-size: 10px;">Lombok</a> <a href="/tags/Loops/" style="font-size: 10px;">Loops</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/Modifier/" style="font-size: 10px;">Modifier</a> <a href="/tags/MultiThread/" style="font-size: 16.25px;">MultiThread</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/N-D-Arrays/" style="font-size: 10px;">N-D_Arrays</a> <a href="/tags/OOP/" style="font-size: 10px;">OOP</a> <a href="/tags/Package/" style="font-size: 10px;">Package</a> <a href="/tags/Polymorphism/" style="font-size: 12.5px;">Polymorphism</a> <a href="/tags/Programmers/" style="font-size: 11.25px;">Programmers</a> <a href="/tags/Quiz-1/" style="font-size: 10px;">Quiz_1</a> <a href="/tags/Quiz-2/" style="font-size: 10px;">Quiz_2</a> <a href="/tags/Regular-Expression/" style="font-size: 10px;">Regular_Expression</a> <a href="/tags/Servlet/" style="font-size: 12.5px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 17.5px;">Spring</a> <a href="/tags/StringTokenizer/" style="font-size: 10px;">StringTokenizer</a> <a href="/tags/Strings/" style="font-size: 10px;">Strings</a> <a href="/tags/VO/" style="font-size: 10px;">VO</a> <a href="/tags/Variable/" style="font-size: 10px;">Variable</a> <a href="/tags/Wrapper-Class/" style="font-size: 10px;">Wrapper Class</a> <a href="/tags/day-1/" style="font-size: 12.5px;">day_1</a> <a href="/tags/day-2/" style="font-size: 12.5px;">day_2</a> <a href="/tags/day-3/" style="font-size: 11.25px;">day_3</a> <a href="/tags/day-4/" style="font-size: 10px;">day_4</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/h2/" style="font-size: 10px;">h2</a> <a href="/tags/java/" style="font-size: 18.75px;">java</a> <a href="/tags/java-lang/" style="font-size: 10px;">java_lang</a> <a href="/tags/til/" style="font-size: 20px;">til</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/25/Spring/fastcampus/day_7/">day_6</a>
          </li>
        
          <li>
            <a href="/2020/11/24/Spring/fastcampus/day_6/">day_6</a>
          </li>
        
          <li>
            <a href="/2020/11/23/Spring/fastcampus/day_5/">day_5</a>
          </li>
        
          <li>
            <a href="/2020/11/20/Spring/fastcampus/day_4/">day_4</a>
          </li>
        
          <li>
            <a href="/2020/11/19/Spring/fastcampus/day_3/">day_3</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Hansol<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>